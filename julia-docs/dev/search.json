[
  {
    "objectID": "reference/fileformats.html",
    "href": "reference/fileformats.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "MEDYAN.jl uses HDF5 with Blosc compression for saving trajectories and snapshots.\nIn HDF5.jl Blosc is built in.\n\n\n\n\n\n\nOther Languages\n\n\n\nTo open these files with h5py you must also install the blosc plugin\nhttps://pypi.org/project/hdf5plugin/\nFor other HDF5 tools see\nhttps://github.com/Blosc/hdf5-blosc\nIn addition, HDF5.jl transposes all arrays on load and store.\nSo any column described below is a row, and vice versa, in the HDF5 file and when read with h5py.\n\n\n\n\nThis file is composed of two groups, “header” and “snapshots”.\n“snapshots” has a subgroup for each snapshot with names “0”, “1”, …\nThe following describe the format of the groups.\n\n\n\nA snapshot describes the state of a Context at a single point in time.\nA snapshot can be used to set the state of a Context if it was constructed with the same system and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nThe snapshot doesn’t hold the exact full state of a Context, simulations restarted from a snapshot may not have the exact same results because:\n\nThe snapshot doesn’t store the state of the random number generator.\nCoordinates may be rounded to save disk space.\nDictionaries and other internal data structures may get reordered and or resorted when the snapshot is loaded.\nMultithreading may be non determanistic.\n\nBut if rounding isn’t too extreme, the reloaded Context should have the same statistics.\n\n\nThe snapshot format is versioned by the “version” attribute. The current snapshot version is:\n\nusing MEDYAN\nusing HDF5\nMEDYAN.SNAPSHOT_VERSION\n\nv\"0.4.0\"\n\n\nCurrently before snapshot version 1.0.0 anything goes.\nAfter snapshot version 1.0.0 is released.\nSnapshots written with a previous snapshot version above v\"1\" should be readable. Snapshots written with a newer snapshot version are generally not readable.\nIf new agent types are added to MEDYAN.jl, usually only the minor version needs to be updated, as nothing special needs to be done to read older snapshot versions without that added agent type.\nIf new data is added to an existing agent type, also usually only the minor version needs to be increment, though the case of the new data not existing must be handled with some default.\nIf the way an existing agent type is stored significantly changes, such that external code analyzing the snapshot would need to be modified, the major version must be incremented. Also if possible there should be a function to update a snapshot from the old version to the new version.\n\n\nAny group, dataset, or attribute name prefixed with with “#” can change format or be removed without changing the snapshot version.\n“#experimental” is used for saving new types of agents or other data that doesn’t have a stable format yet.\n“#comment” is used for saving human readable comments that could change in format or wording.\n\n\n\n\n\nusing MEDYAN\nusing HDF5\nfname = tempname()\nfid = h5open(fname, \"w\")\ncinit, s = MEDYAN.example_all_sites_context()\nMEDYAN.snapshot(cinit,fid)\n\n\n\n\n\n\n\nSnapshot 📂\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\ntime (s)\n\n\nattrs(fid)[\"time (s)\"]\n\n0.0\n\n\nDefault: No change\nSee MEDYAN.set_time!\n\n\n\nversion\n\n\nattrs(fid)[\"version\"]\n\n\"0.4.0\"\n\n\nDefault: No change\nSee Snapshot Versioning\n\n\n\n\n\n\n\n\n\n\n\n\n🔢\n\n\n\n\n\n\n\ndiffusingcounts\n\n\nread(fid[\"diffusingcounts\"])\n\n2×4 Matrix{Int32}:\n 0   100  0   40\n 0  1000  0  400\n\n\nDefault: Empty\nIndexed by [species id, compartment id] to give count.\nSee MEDYAN.chem_adddiffusingcount!\n\n\n\nfixedcounts\n\n\nread(fid[\"fixedcounts\"])\n\n2×4 Matrix{Float64}:\n 10.25  0.0  0.0   0.0\n  0.0   0.0  0.0  20.25\n\n\nDefault: Empty\nIndexed by [species id, compartment id] to give count.\nSee MEDYAN.chem_addfixedcount!\n\n\n\n\n\n\n\n\n\n\n\n\n📂\n\n\n\n\n\n\n\n\n\n\n\n\nchemboundary\n\n\n\n\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.set_chemboundary!\n\n\n🔢 capsules\n\n\nread(fid[\"chemboundary/capsules\"])\n\n8×1 Matrix{Float64}:\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n 10000.0\n     1.0\n\n\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 planes\n\n\nread(fid[\"chemboundary/planes\"])\n\n4×6 Matrix{Float64}:\n -10.0     10.0    0.0     0.0    0.0     0.0\n   0.0      0.0  -10.0    10.0    0.0     0.0\n   0.0      0.0    0.0     0.0  -10.0    10.0\n   0.0  20000.0    0.0  5000.0    0.0  5000.0\n\n\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nfilaments\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nposition_scale\n\n\nattrs(fid[\"filaments\"])[\"position_scale\"]\n\n3\n\n\nDefault: No effect\nFilament positions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\nThere is a subgroup for each filament type with at least one filament. The subgroups are named by their filament type id. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n🔢 endloadforces\n\n\nread(fid[\"filaments/1/endloadforces\"])\n\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\n\nFilament end load forces (pN).\nEach row is the load force on the minus and plus ends of a filament.\n\n\n\n🔢 fids\n\n\nread(fid[\"filaments/1/fids\"])\n\n2-element Vector{Int32}:\n 1\n 2\n\n\nFilament ids.\n\n\n\n🔢 minusend_num_notminimized\n\n\nread(fid[\"filaments/1/minusend_num_notminimized\"])\n\n2-element Vector{Int32}:\n 0\n 0\n\n\nNumber of newly added monomers to the filament minus ends since last minimization.\n\n\n\n🔢 plusend_num_notminimized\n\n\nread(fid[\"filaments/1/plusend_num_notminimized\"])\n\n2-element Vector{Int32}:\n 0\n 0\n\n\nNumber of newly added monomers to the filament plus ends since last minimization.\n\n\n\n🔢 num_cylinders\n\n\nread(fid[\"filaments/1/num_cylinders\"])\n\n2-element Vector{Int32}:\n 1\n 1\n\n\nNumber of cylinders per filament.\n\n\n\n🔢 num_monomers\n\n\nread(fid[\"filaments/1/num_monomers\"])\n\n2-element Vector{Int32}:\n 9\n 9\n\n\nNumber of monomers per filament.\n\n\n\n🔢 node_mids\n\n\nread(fid[\"filaments/1/node_mids\"])\n\n2-element Vector{Int32}:\n 1\n 1\n\n\nThe monomer ids at the minus ends of the cylinders.\n                                   |\n                        -----+-----|-----+-----\n    minus end <----       M  |  M  | (M) |  M        ----> plus end\n                        -----+-----|-----+-----\n                                   |\n                                   ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\n\n\n\n🔢 nodepositions\n\n\nread(fid[\"filaments/1/nodepositions\"])\n\n4×3 Matrix{Float64}:\n 470.0  200.0  200.0\n 560.0  200.0  200.0\n 480.0  201.0  200.0\n 570.0  201.0  200.0\n\n\nEach row is a node position in nm.\n\n\n\n🔢 monomerstates\n\n\nread(fid[\"filaments/1/monomerstates\"])\n\n18-element Vector{UInt8}:\n 0x01\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x05\n 0x01\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x05\n\n\nMonomer states.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlinkers\n\n\n\n\n\nThere is a subgroup for each linker type with at least one linker. The subgroups are named by their linker type id. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nnum_linkers\n\n\nattrs(fid[\"linkers/1\"])[\"num_linkers\"]\n\n2\n\n\nNumber of linkers of this type.\n\n\n\n\n\n\n\n\n\n\n\n\n📂 endnames\n\n\n\n\n\nThe pairs of monomers that the linkers are linked between. The monomer pairs are directed and unique.\n\n\n🔢 minusend/ftid\n\n\nread(fid[\"linkers/1/endnames/minusend/ftid\"])\n\n2-element Vector{Int64}:\n 1\n 1\n\n\nMinus end filament type id.\n\n\n\n🔢 minusend/fid\n\n\nread(fid[\"linkers/1/endnames/minusend/fid\"])\n\n2-element Vector{Int64}:\n 1\n 1\n\n\nMinus end filament id.\n\n\n\n🔢 minusend/mid\n\n\nread(fid[\"linkers/1/endnames/minusend/mid\"])\n\n2-element Vector{Int64}:\n 2\n 2\n\n\nMinus end monomer id.\n\n\n\n🔢 plusend/ftid\n\n\nread(fid[\"linkers/1/endnames/plusend/ftid\"])\n\n2-element Vector{Int64}:\n 1\n 1\n\n\nPlus end filament type id.\n\n\n\n🔢 plusend/fid\n\n\nread(fid[\"linkers/1/endnames/plusend/fid\"])\n\n2-element Vector{Int64}:\n 1\n 2\n\n\nPlus end filament id.\n\n\n\n🔢 plusend/mid\n\n\nread(fid[\"linkers/1/endnames/plusend/mid\"])\n\n2-element Vector{Int64}:\n 2\n 2\n\n\nPlus end monomer id.\n\n\n\n\n\n\n\n📂 state\n\nDefault: default linkerstate\nSee MEDYAN.chem_setlinkerstate! and MEDYAN.LinkerState\nThe state of a linker, organized in a nested struct of vector like form. Any static arrays will be unwrapped into a tuple of vectors, in column major order. The “name” attribute of each subgroup and dataset is the corresponding property name in the StructArray Any property in the default state that isn’t in the snapshot will stay at its default value.\n\nfid[\"linkers/1/state\"]\n\n📂 HDF5.Group: /linkers/1/state (file: /tmp/jl_r6HVBV)\n├─ 📂 1\n│  ├─ 🏷️ name\n│  ├─ 🔢 1\n│  │  └─ 🏷️ name\n│  └─ 🔢 2\n│     └─ 🏷️ name\n├─ 📂 2\n│  ├─ 🏷️ name\n│  └─ 📂 1\n│     ├─ 🏷️ name\n│     ├─ 🔢 1\n│     │  └─ 🏷️ name\n│     ├─ 🔢 2\n│     │  └─ 🏷️ name\n│     └─ 🔢 3\n│        └─ 🏷️ name\n└─ 🔢 3\n   └─ 🏷️ name\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmechboundary\n\n\n\n\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.set_mechboundary!\n\n\n🔢 capsules\n\n\nread(fid[\"mechboundary/capsules\"])\n\n8×1 Matrix{Float64}:\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n 10000.0\n     1.0\n\n\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 planes\n\n\nread(fid[\"mechboundary/planes\"])\n\n4×6 Matrix{Float64}:\n -10.0     10.0    0.0     0.0    0.0     0.0\n   0.0      0.0  -10.0    10.0    0.0     0.0\n   0.0      0.0    0.0     0.0  -10.0    10.0\n   0.0  20000.0    0.0  5000.0    0.0  5000.0\n\n\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nmembranes\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nnum_membranes\n\n\nattrs(fid[\"membranes\"])[\"num_membranes\"]\n\n1\n\n\nTotal number of membranes.\n\n\n\nposition_scale\n\n\nattrs(fid[\"membranes\"])[\"position_scale\"]\n\n3\n\n\nDefault: No effect\nPositions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\nThere is a subgroup for each membrane. The subgroups are named by the membrane index. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\ntype_id\n\n\nattrs(fid[\"membranes/1\"])[\"type_id\"]\n\n1\n\n\nThis membrane’s type id.\n\n\n\n\n\n\n\n🔢 trilist\n\n\nread(fid[\"membranes/1/trilist\"])\n\n3×404 Matrix{Int64}:\n  46   52  139   23  75   47  92  133  …   99  154   62   20   17  130  109\n 103  200  178  170  51   53  15  180      38   34   28   36  135  164  164\n  31  121   67  125  60  145  65    3     163  124  138  175   57   80  162\n\n\nEach column is the 3 vertex indexes of a triangle. Indexes are one based, and follow the right hand rule. Looking at the triangle from the outside in, they have counterclockwise winding.\n\n\n\n🔢 vertlist\n\n\nread(fid[\"membranes/1/vertlist\"])\n\n3×204 Matrix{Float64}:\n 1335.88  1429.25  1688.25  1664.0   …  1522.25  1343.62  1418.25  1314.88\n 1572.12  1588.75  1450.88  1476.5      1675.62  1453.0   1562.62  1474.25\n 1580.62  1341.25  1484.88  1395.62     1582.75  1607.25  1666.38  1441.62\n\n\nEach column is a vertex coordinate in nm."
  },
  {
    "objectID": "reference/sitesinfo.html",
    "href": "reference/sitesinfo.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Abstractly, sites are an interface that allow more complex structures like filaments to interact with diffusing species and compartment reaction propensities.\nEach site type has an associated fixed species. During chemistry that fixed species count will always be the total counts of the site in the compartment.\nChemistry callbacks can try and pick a random site in a compartment to get specific information about exactly where in a compartment some event should happen.\nThese are the groups of sites currently in MEDYAN.jl:\n\n\nFilament sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament site.\n\n\nHow many monomer states in the plus direction this site looks at.\n\n\n\nHow many monomer states in the minus direction this site looks at.\n\n\n\nReturn site count at a monomer given states, A vector of MonomerState with length length(states) == getminusrange(filamentsite) + 1 + getplusrange(filamentsite)\nThe site count gets put in the compartment of the center monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomfilamentsite function\nMEDYAN.Context#filamentsites field\n\n\n\nMEDYAN.SysDef#filamentsite field\nMEDYAN.addfilamentsite! function\nMEDYAN.addfilament_reaction! function\n\n\n\n\n\nFilament end sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament end site.\n\n\nHow many monomer states this site looks at.\n\n\n\nTrue if the filament end site is on the minus end, false if on the plus end.\n\n\n\nReturn spacing needed for the filament end site reaction to happen, units of nm.\n\n\n\nReturn the filament end site count at the end of a filament with monomer states vector states The rate of filament end reaction will be modified by the brownian ratchet model:\nexp(-β*F*L) where F is the compression force on the filament end, and L is spacing(site).\nlength(states) == getrange(filamentendsite)\nThe site count gets put in the compartment of the end monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomfilamentendsite\nMEDYAN.Context#filamentendsites field\n\n\n\nMEDYAN.SysDef#filamentendsite field\nMEDYAN.addfilamentendsite!\nMEDYAN.addfilamentend_reaction!\n\n\n\n\n\nLinker sites can only be associated with one linker type. They can represent propensities for reactions to happen to a linker attached to two monomers, like unbinding or motor walking, or a site for a diffusing species to interact with a bound linker.\n\n\nA type T must implement the following functions to be a linker site.\n\n\nReturn the site count given the state of the linker, the minusftid, plusftid filament type ids, the minusmonomerstates, plusmonomerstates monomer states, and the positions and orientations of the two monomers.\nminusmonomerstates and plusmonomerstates should be collections of 3 MonomerState ordered from minus to plus end, with the linker attached to the center monomer.\nIf a monomer doesn’t exist, its state should be input as zero.\nThe site count gets put in the compartment of the minus end of the linker.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomlinkersite\nMEDYAN.Context#linkersites field\n\n\n\nMEDYAN.SysDef#linkersite field\nMEDYAN.addlinkersite!\n\n\n\n\n\nLinkable sites represent a potential link between two monomers, potentially on two different filaments. The site count is added to the compartment of the potential monomer that could attach to the minus end of the linker.\n\n\nA type T must implement the following functions to be a linkable site.\n\n\nReturn the maximum distance in nm of a linkable site.\n\n\n\nReturn if two monomers are in range to possibly link in the forward direction, and if they are in range to possibly link in the reverse direction.\n\n\n\nReturn the filament types of the minus and plus monomers.\n\n\n\nReturn the monomer step size starting with mid 0 in the search for potential linkable sites on the minus and plus ends respectively.\n1 searches every monomer. 2 searches every monomer with even mid …\nIf the plus and minus filament types are the same, then getmidsteps(site)[1] == getmidsteps(site)[2]\n\n\n\nReturn the site count of two monomers getting linked given their states, their positions, and their plus vectors.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomlinkablesite\nMEDYAN.Context#linkablesites field\n\n\n\nMEDYAN.SysDef#linkablesite field\nMEDYAN.addlinkablesite!"
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "src/sysdefs.jl\n\nMEDYAN.StateDef\nMEDYAN.SysDef\naddreaction!\naddreactioncallback!\naddfilamentsite!\naddfilament_reaction!\naddfilamentendsite!\naddfilamentend_reaction!\naddlinker!\n\n\n\n\n\nMEDYAN.Context\ndeepcopy, note: rng is shared\n\n\n\n\n\nBase.empty!\nload_snapshot!\nchem_newfilament!\nchem_removefilament!\nchem_polymerize!\nchem_depolymerize!\nchem_setmonomerstate!\nchem_newlinker!\nchem_removelinker!\nchem_setlinkerstate!\nchem_adddiffusingcount!\nchem_addfixedcount!\nadddiffusingcount_rand!\nnewfilament_rand!\nset_time!\nset_enable_cylinder_volume_exclusion!\nset_chemboundary!\nset_mechboundary!\n\n\n\n\n\n\n\n\nrun_chemistry!\nminimize_energy!\n\n\n\n\n\n\n\n\n\n\nfilament sites\nfilament end sites\nlinker sites\nlinkable sites"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Documentation for MEDYAN."
  },
  {
    "objectID": "index.html#warning-the-api-is-very-unstable-and-this-package-is-not-released-yet.",
    "href": "index.html#warning-the-api-is-very-unstable-and-this-package-is-not-released-yet.",
    "title": "MEDYAN.jl",
    "section": "Warning, the API is very unstable, and this package is not released yet.",
    "text": "Warning, the API is very unstable, and this package is not released yet.\nWelcome to Papoian Lab’s Mechanochemical Dynamics of Active Networks Julia package.\nThis is based on the C++ medyan command line tool also developed by the Papoian Lab.\nCopyright 2022, Papoian lab at the University of Maryland.\nThis code is distributed under the license found in this directory, license.txt."
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "MEDYAN.jl",
    "section": "Usage",
    "text": "Usage\nFirst install and run Julia https://julialang.org/downloads/\nThen if you haven’t yet, set up ssh keys with github.\nAlso, currently you may have to install git and ensure you have a .julia/config/startup.jl with\nENV[\"JULIA_PKG_USE_CLI_GIT\"]= \"true\"\nFinally, to add the current MEDYAN.jl, in Julia run:\n] add git@github.com:medyan-dev/MEDYAN.jl.git\nTo add a specific commit id, for example 2d31e2a, in Julia run:\n] add \"git@github.com:medyan-dev/MEDYAN.jl.git\"#2d31e2a\nSee the docs for tutorials and more information."
  },
  {
    "objectID": "index.html#authors",
    "href": "index.html#authors",
    "title": "MEDYAN.jl",
    "section": "Authors",
    "text": "Authors\nActive developers:\n\n\n\nName\nEmail\n\n\n\n\nHaoran Ni\nhaoranni@umd.edu\n\n\nNathan Zimmerberg\nnzimmerb@umd.edu\n\n\n\nAll developers including developers of C++ medyan:\nGaregin Papoian (gpapoian@umd.edu), Konstantin Popov, James Komianos, Aravind Chandrasekaran, Qin Ni, Carlos Floyd, Haoran Ni, Nathan Zimmerberg, Joshua Lucker.\nAll general correspondence about the code and its applications should be directed to Garegin Papoian. All developer and more specific code, installation, and usage correspondence should be directed to Active developers via email or the issue tracker."
  },
  {
    "objectID": "index.html#running-notebooks",
    "href": "index.html#running-notebooks",
    "title": "MEDYAN.jl",
    "section": "Running notebooks",
    "text": "Running notebooks\nTo run interactively in a Pluto Notebook, run the following shell commands:\ncd notebooks\njulia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=\\\"..\\\")); Pkg.instantiate()'\njulia --project -e 'import Pluto; Pluto.run()'\nTo generate static html files, run the following shell commands:\ncd notebooks\njulia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=\\\"..\\\")); Pkg.instantiate()'\njulia --project runnotebooks.jl"
  },
  {
    "objectID": "index.html#editing-documentation",
    "href": "index.html#editing-documentation",
    "title": "MEDYAN.jl",
    "section": "Editing Documentation",
    "text": "Editing Documentation\nRun the following to set up the environment.\njulia --project=docs -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'\nThen run the following from the main directory to view the docs.\nAny changes to the markdown files in docs/src will automatically be updated on the browser by LiveServer.\njulia --project=docs -e \"using LiveServer; servedocs(port=8000)\"\ndocs/src/tutorials has a few Pluto notebook tutorials.\nThese can be exported along with the other documentation to html by using the tutorials argument with make.jl.\njulia --project=docs docs/make.jl tutorials"
  },
  {
    "objectID": "docstrings.html",
    "href": "docstrings.html",
    "title": "Docstrings",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\n\n\n\n\n\n\nNo matching items"
  }
]