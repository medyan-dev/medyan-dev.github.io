[
  {
    "objectID": "docstrings/medyan.num_directions-89697a0fca8de12f.html",
    "href": "docstrings/medyan.num_directions-89697a0fca8de12f.html",
    "title": "MEDYAN.num_directions",
    "section": "",
    "text": "num_directions(::Union{Place, Type{&lt;:Place}})::Int\nReturn the number of directions associated with a place."
  },
  {
    "objectID": "docstrings/medyan.num_directions-89697a0fca8de12f.html#tuple-type-medyan.filatipidx---8171ee85c8e9c62d",
    "href": "docstrings/medyan.num_directions-89697a0fca8de12f.html#tuple-type-medyan.filatipidx---8171ee85c8e9c62d",
    "title": "MEDYAN.num_directions",
    "section": "",
    "text": "num_directions(::Union{Place, Type{&lt;:Place}})::Int\nReturn the number of directions associated with a place."
  },
  {
    "objectID": "docstrings/medyan.pick_rand_fila_mono_site-6641f66ed8873af1.html",
    "href": "docstrings/medyan.pick_rand_fila_mono_site-6641f66ed8873af1.html",
    "title": "MEDYAN.pick_rand_fila_mono_site",
    "section": "",
    "text": "pick_rand_fila_mono_site(c::Context, chem_voxel, fila_typeid, fsid)::Union{FilaMonoIdx, Nothing}\nReturn a FilaMonoIdx of a random filamonosite, or return nothing if rejected weighted by counts, using the default RNG."
  },
  {
    "objectID": "docstrings/medyan.pick_rand_fila_mono_site-6641f66ed8873af1.html#tuple-medyan.context--any--any--any--3e36a14adf838425",
    "href": "docstrings/medyan.pick_rand_fila_mono_site-6641f66ed8873af1.html#tuple-medyan.context--any--any--any--3e36a14adf838425",
    "title": "MEDYAN.pick_rand_fila_mono_site",
    "section": "",
    "text": "pick_rand_fila_mono_site(c::Context, chem_voxel, fila_typeid, fsid)::Union{FilaMonoIdx, Nothing}\nReturn a FilaMonoIdx of a random filamonosite, or return nothing if rejected weighted by counts, using the default RNG."
  },
  {
    "objectID": "docstrings/medyan.get_bond_enabled-c3461fb32deb4276.html",
    "href": "docstrings/medyan.get_bond_enabled-c3461fb32deb4276.html",
    "title": "MEDYAN.get_bond_enabled",
    "section": "",
    "text": "get_bond_enabled(c::Context, link::Link, [d::LinkData])\nReturn the bond_enabled flags of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.get_bond_enabled-c3461fb32deb4276.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--any---03b671600f22589f",
    "href": "docstrings/medyan.get_bond_enabled-c3461fb32deb4276.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--any---03b671600f22589f",
    "title": "MEDYAN.get_bond_enabled",
    "section": "",
    "text": "get_bond_enabled(c::Context, link::Link, [d::LinkData])\nReturn the bond_enabled flags of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.chem_adddiffusingcount--2264be341b81a600.html",
    "href": "docstrings/medyan.chem_adddiffusingcount--2264be341b81a600.html",
    "title": "MEDYAN.chem_adddiffusingcount!",
    "section": "",
    "text": "chem_adddiffusingcount!(c::Context, sid, cid, inccount)\nAdd inccount to diffusing species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/medyan.chem_adddiffusingcount--2264be341b81a600.html#tuple-medyan.context--any--any--any--3e36a14adf838425",
    "href": "docstrings/medyan.chem_adddiffusingcount--2264be341b81a600.html#tuple-medyan.context--any--any--any--3e36a14adf838425",
    "title": "MEDYAN.chem_adddiffusingcount!",
    "section": "",
    "text": "chem_adddiffusingcount!(c::Context, sid, cid, inccount)\nAdd inccount to diffusing species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/medyan.chem_addfixedcount--0286edfebf8ea5e6.html",
    "href": "docstrings/medyan.chem_addfixedcount--0286edfebf8ea5e6.html",
    "title": "MEDYAN.chem_addfixedcount!",
    "section": "",
    "text": "chem_addfixedcount!(c::Context, sid, cid, inccount)\nAdd inccount to fixed species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/medyan.chem_addfixedcount--0286edfebf8ea5e6.html#tuple-medyan.context--any--any--any--3e36a14adf838425",
    "href": "docstrings/medyan.chem_addfixedcount--0286edfebf8ea5e6.html#tuple-medyan.context--any--any--any--3e36a14adf838425",
    "title": "MEDYAN.chem_addfixedcount!",
    "section": "",
    "text": "chem_addfixedcount!(c::Context, sid, cid, inccount)\nAdd inccount to fixed species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/medyan.remove_fila--9938182befad3cb9.html",
    "href": "docstrings/medyan.remove_fila--9938182befad3cb9.html",
    "title": "MEDYAN.remove_fila!",
    "section": "",
    "text": "remove_fila!(c::Context, filaidx::Union{FilaIdx, Tag})\nRemove the filament.\nUnlink any monomers or tips on the filament that are referenced by any links. The links will not be removed, but will have a null reference."
  },
  {
    "objectID": "docstrings/medyan.remove_fila--9938182befad3cb9.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "href": "docstrings/medyan.remove_fila--9938182befad3cb9.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "title": "MEDYAN.remove_fila!",
    "section": "",
    "text": "remove_fila!(c::Context, filaidx::Union{FilaIdx, Tag})\nRemove the filament.\nUnlink any monomers or tips on the filament that are referenced by any links. The links will not be removed, but will have a null reference."
  },
  {
    "objectID": "docstrings/medyan.boundary_cylinder-33a45da15f9672d3.html",
    "href": "docstrings/medyan.boundary_cylinder-33a45da15f9672d3.html",
    "title": "MEDYAN.boundary_cylinder",
    "section": "",
    "text": "boundary_cylinder(\n;\n    center,\n    axis,\n    radius,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a cylinder boundary.\ncenter(nm): The center of the cylinder.\naxis(nm): The direction and length of the cylinder. The spine line segment goes from center - axis/2 to center + axis/2 the full length of the cylinder is norm(axis).\nradius(nm): Radius of cylinder.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/medyan.boundary_cylinder-33a45da15f9672d3.html#tuple---3937a4f1811c9dc1",
    "href": "docstrings/medyan.boundary_cylinder-33a45da15f9672d3.html#tuple---3937a4f1811c9dc1",
    "title": "MEDYAN.boundary_cylinder",
    "section": "",
    "text": "boundary_cylinder(\n;\n    center,\n    axis,\n    radius,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a cylinder boundary.\ncenter(nm): The center of the cylinder.\naxis(nm): The direction and length of the cylinder. The spine line segment goes from center - axis/2 to center + axis/2 the full length of the cylinder is norm(axis).\nradius(nm): Radius of cylinder.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/medyan.num_vertexwithstate-3cf6fcd964588d37.html",
    "href": "docstrings/medyan.num_vertexwithstate-3cf6fcd964588d37.html",
    "title": "MEDYAN.num_vertexwithstate",
    "section": "",
    "text": "Return the number of vertices with state vertex_state."
  },
  {
    "objectID": "docstrings/medyan.num_vertexwithstate-3cf6fcd964588d37.html#tuple-medyan.dynamichalfedgemesh--integer--d9b9e9640b07196d",
    "href": "docstrings/medyan.num_vertexwithstate-3cf6fcd964588d37.html#tuple-medyan.dynamichalfedgemesh--integer--d9b9e9640b07196d",
    "title": "MEDYAN.num_vertexwithstate",
    "section": "",
    "text": "Return the number of vertices with state vertex_state."
  },
  {
    "objectID": "docstrings/medyan.depolymerize_fila--7aae43ce27544212.html",
    "href": "docstrings/medyan.depolymerize_fila--7aae43ce27544212.html",
    "title": "MEDYAN.depolymerize_fila!",
    "section": "",
    "text": "depolymerize_fila!(c::Context, fila_tip_idx::FilaTipIdx)\nRemove a monomer from the end of the filament.\nThis doesn’t affect the other monomer states, positions, or change any of the monomer ids.\nError if the filament isn’t initially over 2 monomers long.\nUnlink any monomers on the filament that are referenced by any links. The links will not be removed, but will have a null reference. Links attached to the filament tip will remain attached."
  },
  {
    "objectID": "docstrings/medyan.depolymerize_fila--7aae43ce27544212.html#tuple-medyan.context--medyan.filatipidx--d592866d39d8c362",
    "href": "docstrings/medyan.depolymerize_fila--7aae43ce27544212.html#tuple-medyan.context--medyan.filatipidx--d592866d39d8c362",
    "title": "MEDYAN.depolymerize_fila!",
    "section": "",
    "text": "depolymerize_fila!(c::Context, fila_tip_idx::FilaTipIdx)\nRemove a monomer from the end of the filament.\nThis doesn’t affect the other monomer states, positions, or change any of the monomer ids.\nError if the filament isn’t initially over 2 monomers long.\nUnlink any monomers on the filament that are referenced by any links. The links will not be removed, but will have a null reference. Links attached to the filament tip will remain attached."
  },
  {
    "objectID": "docstrings/medyan.get_chem_boundary_oversampling_factor-ceb9b2d946f4fb17.html",
    "href": "docstrings/medyan.get_chem_boundary_oversampling_factor-ceb9b2d946f4fb17.html",
    "title": "MEDYAN.get_chem_boundary_oversampling_factor",
    "section": "",
    "text": "get_chem_boundary_oversampling_factor(\n    c::MEDYAN.Context\n) -&gt; Int64\nGet the oversampling factor used for chem boundary TSDF computation."
  },
  {
    "objectID": "docstrings/medyan.get_chem_boundary_oversampling_factor-ceb9b2d946f4fb17.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.get_chem_boundary_oversampling_factor-ceb9b2d946f4fb17.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.get_chem_boundary_oversampling_factor",
    "section": "",
    "text": "get_chem_boundary_oversampling_factor(\n    c::MEDYAN.Context\n) -&gt; Int64\nGet the oversampling factor used for chem boundary TSDF computation."
  },
  {
    "objectID": "docstrings/medyan.load_snapshot--e534be293ce74465.html",
    "href": "docstrings/medyan.load_snapshot--e534be293ce74465.html",
    "title": "MEDYAN.load_snapshot!",
    "section": "",
    "text": "load_snapshot!(c::Context,group::ZGroup)\nEmpty the context and load the state saved in the snapshot group.\nc should be constructed with the same SysDef and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nSee Snapshot group for more details."
  },
  {
    "objectID": "docstrings/medyan.load_snapshot--e534be293ce74465.html#tuple-medyan.context--smallzarrgroups.zgroup--a98412e602b7637b",
    "href": "docstrings/medyan.load_snapshot--e534be293ce74465.html#tuple-medyan.context--smallzarrgroups.zgroup--a98412e602b7637b",
    "title": "MEDYAN.load_snapshot!",
    "section": "",
    "text": "load_snapshot!(c::Context,group::ZGroup)\nEmpty the context and load the state saved in the snapshot group.\nc should be constructed with the same SysDef and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nSee Snapshot group for more details."
  },
  {
    "objectID": "docstrings/medyan.filamonoidx-94fe5a1112741990.html",
    "href": "docstrings/medyan.filamonoidx-94fe5a1112741990.html",
    "title": "MEDYAN.FilaMonoIdx",
    "section": "",
    "text": "FilaMonoIdx &lt;: Place\nAn index identifying a specific monomer on a filament. This is used for reactions and links that target individual monomers rather than filament tips.\nThis index may be invalidated by mutations (e.g., filament removal or severing). Use a Tag{FilaMonoIdx} for a long-term reference that remains valid across mutations.\n\n\n\nFilaMonoIdx(): Creates a null monomer index\nFilaMonoIdx(fila_idx::FilaIdx, mid::Integer): Creates a monomer index for the specified filament and monomer ID\nFilaMonoIdx(c::Context, f::FilaIdx, m::Integer): Creates a monomer index from a filament index and monomer ID\nFilaMonoIdx(c::Context, ft::FilaTipIdx, offset::Integer=0): Creates a monomer index relative to a tip position\nFilaMonoIdx(c::Context, fm::FilaMonoIdx, offset::Integer=0): Re-resolve a monomer index with optional offset\nFilaMonoIdx(c::Context, x, y::Union{typeof(+), typeof(-)}, offset::Integer=0): Creates a monomer index from a tip direction\nFilaMonoIdx(c::Context, t::Tag, offset::Integer=0): Creates a monomer index from a tag with optional offset\n\n\n\n\n\nfila_idx::FilaIdx: The filament this monomer belongs to\nmid::Int64: The monomer ID (can be obtained from fila_mono_ids)\n\n\n\n\n# Get a specific monomer on a filament\nfidx = FilaIdx(ftid, 1)\nmono_ids = fila_mono_ids(c, fidx)\nmono_idx = FilaMonoIdx(fidx, first(mono_ids))  # First monomer (minus end)\n\n\n\nSee fila_mono_ids, fila_mono_states"
  },
  {
    "objectID": "docstrings/medyan.filamonoidx-94fe5a1112741990.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.filamonoidx-94fe5a1112741990.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.FilaMonoIdx",
    "section": "",
    "text": "FilaMonoIdx &lt;: Place\nAn index identifying a specific monomer on a filament. This is used for reactions and links that target individual monomers rather than filament tips.\nThis index may be invalidated by mutations (e.g., filament removal or severing). Use a Tag{FilaMonoIdx} for a long-term reference that remains valid across mutations.\n\n\n\nFilaMonoIdx(): Creates a null monomer index\nFilaMonoIdx(fila_idx::FilaIdx, mid::Integer): Creates a monomer index for the specified filament and monomer ID\nFilaMonoIdx(c::Context, f::FilaIdx, m::Integer): Creates a monomer index from a filament index and monomer ID\nFilaMonoIdx(c::Context, ft::FilaTipIdx, offset::Integer=0): Creates a monomer index relative to a tip position\nFilaMonoIdx(c::Context, fm::FilaMonoIdx, offset::Integer=0): Re-resolve a monomer index with optional offset\nFilaMonoIdx(c::Context, x, y::Union{typeof(+), typeof(-)}, offset::Integer=0): Creates a monomer index from a tip direction\nFilaMonoIdx(c::Context, t::Tag, offset::Integer=0): Creates a monomer index from a tag with optional offset\n\n\n\n\n\nfila_idx::FilaIdx: The filament this monomer belongs to\nmid::Int64: The monomer ID (can be obtained from fila_mono_ids)\n\n\n\n\n# Get a specific monomer on a filament\nfidx = FilaIdx(ftid, 1)\nmono_ids = fila_mono_ids(c, fidx)\nmono_idx = FilaMonoIdx(fidx, first(mono_ids))  # First monomer (minus end)\n\n\n\nSee fila_mono_ids, fila_mono_states"
  },
  {
    "objectID": "docstrings/medyan.sysdef-c0c4da7a2b3d4fef.html",
    "href": "docstrings/medyan.sysdef-c0c4da7a2b3d4fef.html",
    "title": "MEDYAN.SysDef",
    "section": "",
    "text": "SysDef(agent_names::AgentNames)\nA mutable struct mapping names to id numbers in a simulation\n\nagent_names::MEDYAN.AgentNames\ndiffusing::MEDYAN.PropDictionary\ndiffusing_coeff::MEDYAN.PropDictionary\nbulkspecies_indexmap::MEDYAN.PropDictionary\nmembranediffusing::MEDYAN.PropDictionary\nfixedspecies::MEDYAN.PropDictionary\nfilament::MEDYAN.PropDictionary\nfilament_params::MEDYAN.PropDictionary\nstate::MEDYAN.PropDictionary\nfilamentsite::MEDYAN.PropDictionary\nfilamentendsite::MEDYAN.PropDictionary\nmembranesite::MEDYAN.PropDictionary: Each membrane site represents the membrane patches in each compartment together with some membrane diffusing species.\ndecimated_2mon_site::MEDYAN.PropDictionary\npossiblecadherinsite::MEDYAN.PropDictionary\nallfixedspeciesnames::Vector{String}\ncompartmentreactions::Vector{MEDYAN.CompartmentReaction}\ncompartmentreactioncallbacks::Vector{Any}\nbulkreactions::Vector{MEDYAN.BulkReaction}\nbulkreactioncallbacks::Vector{Any}: Context -&gt; Nothing\nlink::MEDYAN.PropDictionary\ntotal_num_link_types_places::Int64\nlink_reaction_site::MEDYAN.PropDictionary\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreate an empty SysDef with no agents."
  },
  {
    "objectID": "docstrings/medyan.sysdef-c0c4da7a2b3d4fef.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.sysdef-c0c4da7a2b3d4fef.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.SysDef",
    "section": "",
    "text": "SysDef(agent_names::AgentNames)\nA mutable struct mapping names to id numbers in a simulation\n\nagent_names::MEDYAN.AgentNames\ndiffusing::MEDYAN.PropDictionary\ndiffusing_coeff::MEDYAN.PropDictionary\nbulkspecies_indexmap::MEDYAN.PropDictionary\nmembranediffusing::MEDYAN.PropDictionary\nfixedspecies::MEDYAN.PropDictionary\nfilament::MEDYAN.PropDictionary\nfilament_params::MEDYAN.PropDictionary\nstate::MEDYAN.PropDictionary\nfilamentsite::MEDYAN.PropDictionary\nfilamentendsite::MEDYAN.PropDictionary\nmembranesite::MEDYAN.PropDictionary: Each membrane site represents the membrane patches in each compartment together with some membrane diffusing species.\ndecimated_2mon_site::MEDYAN.PropDictionary\npossiblecadherinsite::MEDYAN.PropDictionary\nallfixedspeciesnames::Vector{String}\ncompartmentreactions::Vector{MEDYAN.CompartmentReaction}\ncompartmentreactioncallbacks::Vector{Any}\nbulkreactions::Vector{MEDYAN.BulkReaction}\nbulkreactioncallbacks::Vector{Any}: Context -&gt; Nothing\nlink::MEDYAN.PropDictionary\ntotal_num_link_types_places::Int64\nlink_reaction_site::MEDYAN.PropDictionary"
  },
  {
    "objectID": "docstrings/medyan.sysdef-c0c4da7a2b3d4fef.html#tuple---3937a4f1811c9dc1",
    "href": "docstrings/medyan.sysdef-c0c4da7a2b3d4fef.html#tuple---3937a4f1811c9dc1",
    "title": "MEDYAN.SysDef",
    "section": "",
    "text": "Create an empty SysDef with no agents."
  },
  {
    "objectID": "docstrings/medyan.boundary_plane-2caa9b52b3b3f0cc.html",
    "href": "docstrings/medyan.boundary_plane-2caa9b52b3b3f0cc.html",
    "title": "MEDYAN.boundary_plane",
    "section": "",
    "text": "boundary_plane(\n;\n    normal,\n    point,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a plane boundary.\nnormal(unit vector): Vector pointing normal to the plane. This points outside of the boundary.\npoint(nm): Point on the plane.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/medyan.boundary_plane-2caa9b52b3b3f0cc.html#tuple---3937a4f1811c9dc1",
    "href": "docstrings/medyan.boundary_plane-2caa9b52b3b3f0cc.html#tuple---3937a4f1811c9dc1",
    "title": "MEDYAN.boundary_plane",
    "section": "",
    "text": "boundary_plane(\n;\n    normal,\n    point,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a plane boundary.\nnormal(unit vector): Vector pointing normal to the plane. This points outside of the boundary.\npoint(nm): Point on the plane.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/medyan.is_chem_cache_valid-8336a8adc58a252f.html",
    "href": "docstrings/medyan.is_chem_cache_valid-8336a8adc58a252f.html",
    "title": "MEDYAN.is_chem_cache_valid",
    "section": "",
    "text": "is_chem_cache_valid(c::Context)::Bool\nReturn true if the chemistry cache is valid, false otherwise."
  },
  {
    "objectID": "docstrings/medyan.is_chem_cache_valid-8336a8adc58a252f.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.is_chem_cache_valid-8336a8adc58a252f.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.is_chem_cache_valid",
    "section": "",
    "text": "is_chem_cache_valid(c::Context)::Bool\nReturn true if the chemistry cache is valid, false otherwise."
  },
  {
    "objectID": "docstrings/medyan.num_fila-6aa6f32d094c895e.html",
    "href": "docstrings/medyan.num_fila-6aa6f32d094c895e.html",
    "title": "MEDYAN.num_fila",
    "section": "",
    "text": "num_fila(c::MEDYAN.Context; type) -&gt; Int64\nReturn the number of filaments of a given type."
  },
  {
    "objectID": "docstrings/medyan.num_fila-6aa6f32d094c895e.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.num_fila-6aa6f32d094c895e.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.num_fila",
    "section": "",
    "text": "num_fila(c::MEDYAN.Context; type) -&gt; Int64\nReturn the number of filaments of a given type."
  },
  {
    "objectID": "docstrings/medyan.get_chem_boundary_grid_spacing-3726877b3aae3a2e.html",
    "href": "docstrings/medyan.get_chem_boundary_grid_spacing-3726877b3aae3a2e.html",
    "title": "MEDYAN.get_chem_boundary_grid_spacing",
    "section": "",
    "text": "get_chem_boundary_grid_spacing(c::MEDYAN.Context) -&gt; Float64\nGet the grid spacing used for chem boundary TSDF computation."
  },
  {
    "objectID": "docstrings/medyan.get_chem_boundary_grid_spacing-3726877b3aae3a2e.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.get_chem_boundary_grid_spacing-3726877b3aae3a2e.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.get_chem_boundary_grid_spacing",
    "section": "",
    "text": "get_chem_boundary_grid_spacing(c::MEDYAN.Context) -&gt; Float64\nGet the grid spacing used for chem boundary TSDF computation."
  },
  {
    "objectID": "docstrings/medyan.defer_chem_caching--9538a1c449f3da93.html",
    "href": "docstrings/medyan.defer_chem_caching--9538a1c449f3da93.html",
    "title": "MEDYAN.defer_chem_caching!",
    "section": "",
    "text": "defer_chem_caching!(c::Context)::Nothing\nThis should only be used for advanced optimizations.\nDuring chemistry, the context mutating functions will typically try to avoid invalidating various cached data needed to quickly sample sites.\nHowever, if you want to mutate the context outside of chemistry, for example right before or after minimization, you may not want to pay the cost of revalidating all the caches because minimization will already invalidate the caches. Caching will be enabled again and caches will be made valid the next time chemistry is run. Caching can also be manually refreshed and reenabled with: refresh_chem_cache!"
  },
  {
    "objectID": "docstrings/medyan.defer_chem_caching--9538a1c449f3da93.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.defer_chem_caching--9538a1c449f3da93.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.defer_chem_caching!",
    "section": "",
    "text": "defer_chem_caching!(c::Context)::Nothing\nThis should only be used for advanced optimizations.\nDuring chemistry, the context mutating functions will typically try to avoid invalidating various cached data needed to quickly sample sites.\nHowever, if you want to mutate the context outside of chemistry, for example right before or after minimization, you may not want to pay the cost of revalidating all the caches because minimization will already invalidate the caches. Caching will be enabled again and caches will be made valid the next time chemistry is run. Caching can also be manually refreshed and reenabled with: refresh_chem_cache!"
  },
  {
    "objectID": "docstrings/medyan.set_enable_collision--ff3352f0a3c63ab0.html",
    "href": "docstrings/medyan.set_enable_collision--ff3352f0a3c63ab0.html",
    "title": "MEDYAN.set_enable_collision!",
    "section": "",
    "text": "set_enable_collision!(c::MEDYAN.Context, x::Bool) -&gt; Bool\nAre repulsive forces calculated."
  },
  {
    "objectID": "docstrings/medyan.set_enable_collision--ff3352f0a3c63ab0.html#tuple-medyan.context--bool--89b229b1eef6a22c",
    "href": "docstrings/medyan.set_enable_collision--ff3352f0a3c63ab0.html#tuple-medyan.context--bool--89b229b1eef6a22c",
    "title": "MEDYAN.set_enable_collision!",
    "section": "",
    "text": "set_enable_collision!(c::MEDYAN.Context, x::Bool) -&gt; Bool\nAre repulsive forces calculated."
  },
  {
    "objectID": "docstrings/medyan.get_chem_boundary_tsdf--7c0691ac2b510a3d.html",
    "href": "docstrings/medyan.get_chem_boundary_tsdf--7c0691ac2b510a3d.html",
    "title": "MEDYAN.get_chem_boundary_tsdf!",
    "section": "",
    "text": "get_chem_boundary_tsdf!(\n    c::MEDYAN.Context\n) -&gt; Array{Float64, 3}\nGet the cached chem boundary TSDF, computing it if necessary. The TSDF is a 3D grid of signed distances where inside the boundary is negative and outside is positive. Values are clamped to ±max(usermaxdistance, 2.5*grid_spacing)."
  },
  {
    "objectID": "docstrings/medyan.get_chem_boundary_tsdf--7c0691ac2b510a3d.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.get_chem_boundary_tsdf--7c0691ac2b510a3d.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.get_chem_boundary_tsdf!",
    "section": "",
    "text": "get_chem_boundary_tsdf!(\n    c::MEDYAN.Context\n) -&gt; Array{Float64, 3}\nGet the cached chem boundary TSDF, computing it if necessary. The TSDF is a 3D grid of signed distances where inside the boundary is negative and outside is positive. Values are clamped to ±max(usermaxdistance, 2.5*grid_spacing)."
  },
  {
    "objectID": "docstrings/medyan.add_diffusion_coeff--a77d1ef833cfdedd.html",
    "href": "docstrings/medyan.add_diffusion_coeff--a77d1ef833cfdedd.html",
    "title": "MEDYAN.add_diffusion_coeff!",
    "section": "",
    "text": "add_diffusion_coeff!(s::SysDef, name::Symbol, coeff::Float64)\nUpdate the diffusion coefficient for an existing diffusing species.\nThe species must already exist in s.diffusing (typically added via def_diffusing_species!.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the existing diffusing species.\ncoeff::Float64: The diffusion coefficient in units of nm²/s.\n\n\n\n\nThe modified SysDef.\nSee also: def_diffusing_species! to add a new species with its diffusion coefficient in one step."
  },
  {
    "objectID": "docstrings/medyan.add_diffusion_coeff--a77d1ef833cfdedd.html#tuple-medyan.sysdef--symbol--float64--936450f65416538e",
    "href": "docstrings/medyan.add_diffusion_coeff--a77d1ef833cfdedd.html#tuple-medyan.sysdef--symbol--float64--936450f65416538e",
    "title": "MEDYAN.add_diffusion_coeff!",
    "section": "",
    "text": "add_diffusion_coeff!(s::SysDef, name::Symbol, coeff::Float64)\nUpdate the diffusion coefficient for an existing diffusing species.\nThe species must already exist in s.diffusing (typically added via def_diffusing_species!.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the existing diffusing species.\ncoeff::Float64: The diffusion coefficient in units of nm²/s.\n\n\n\n\nThe modified SysDef.\nSee also: def_diffusing_species! to add a new species with its diffusion coefficient in one step."
  },
  {
    "objectID": "docstrings/medyan.def_fila_type--5a1f6234215ea82d.html",
    "href": "docstrings/medyan.def_fila_type--5a1f6234215ea82d.html",
    "title": "MEDYAN.def_fila_type!",
    "section": "",
    "text": "def_fila_type!(s::SysDef; name::Symbol, mono_states::Vector{Symbol}, param::FilamentMechParams)\nAdd a new filament type to the system definition.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new filament type.\nmono_states::Vector{Symbol}: Vector of monomer state names for this filament type. Must not be empty.\nparam::FilamentMechParams: The filament mechanical parameters.\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if a filament type with the given name already exists.\nError if mono_states is empty."
  },
  {
    "objectID": "docstrings/medyan.def_fila_type--5a1f6234215ea82d.html#tuple-medyan.sysdef--efaa49a98644904f",
    "href": "docstrings/medyan.def_fila_type--5a1f6234215ea82d.html#tuple-medyan.sysdef--efaa49a98644904f",
    "title": "MEDYAN.def_fila_type!",
    "section": "",
    "text": "def_fila_type!(s::SysDef; name::Symbol, mono_states::Vector{Symbol}, param::FilamentMechParams)\nAdd a new filament type to the system definition.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new filament type.\nmono_states::Vector{Symbol}: Vector of monomer state names for this filament type. Must not be empty.\nparam::FilamentMechParams: The filament mechanical parameters.\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if a filament type with the given name already exists.\nError if mono_states is empty."
  },
  {
    "objectID": "docstrings/medyan.filamentendsitegeneral-7a32ac96fb4364ea.html",
    "href": "docstrings/medyan.filamentendsitegeneral-7a32ac96fb4364ea.html",
    "title": "MEDYAN.FilamentEndSiteGeneral",
    "section": "",
    "text": "Filament end site that matches with a vector of monomer states.\n\nisminusend::Bool\nendstates::Vector{UInt8}\nspacing::Float64\nadded_monomers::Int64"
  },
  {
    "objectID": "docstrings/medyan.filamentendsitegeneral-7a32ac96fb4364ea.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.filamentendsitegeneral-7a32ac96fb4364ea.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.FilamentEndSiteGeneral",
    "section": "",
    "text": "Filament end site that matches with a vector of monomer states.\n\nisminusend::Bool\nendstates::Vector{UInt8}\nspacing::Float64\nadded_monomers::Int64"
  },
  {
    "objectID": "docstrings/medyan.boundary_capsule-1700142f310bd9db.html",
    "href": "docstrings/medyan.boundary_capsule-1700142f310bd9db.html",
    "title": "MEDYAN.boundary_capsule",
    "section": "",
    "text": "boundary_capsule(\n;\n    center,\n    axis,\n    radius,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a capsule boundary.\ncenter(nm): The center of the capsule.\naxis(nm): The direction and length of the capsule spine. The spine line segment goes from center - axis/2 to center + axis/2 If zero the capsule is a sphere.\nradius(nm): Radius of capsule, the full length of the capsule is norm(axis) + 2*abs(radius). If negative, the domain is the outside of the capsule, if positive the domain is the inside of the capsule.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/medyan.boundary_capsule-1700142f310bd9db.html#tuple---3937a4f1811c9dc1",
    "href": "docstrings/medyan.boundary_capsule-1700142f310bd9db.html#tuple---3937a4f1811c9dc1",
    "title": "MEDYAN.boundary_capsule",
    "section": "",
    "text": "boundary_capsule(\n;\n    center,\n    axis,\n    radius,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a capsule boundary.\ncenter(nm): The center of the capsule.\naxis(nm): The direction and length of the capsule spine. The spine line segment goes from center - axis/2 to center + axis/2 If zero the capsule is a sphere.\nradius(nm): Radius of capsule, the full length of the capsule is norm(axis) + 2*abs(radius). If negative, the domain is the outside of the capsule, if positive the domain is the inside of the capsule.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/medyan.membranesitediffusing-66734014eb12ddb1.html",
    "href": "docstrings/medyan.membranesitediffusing-66734014eb12ddb1.html",
    "title": "MEDYAN.MembraneSiteDiffusing",
    "section": "",
    "text": "Allows up to 1 membrane diffusing species as reactants. Also stores net stoich of membrane diffusing species.\n\nid_membranediffusing_reactant::Int64: Set to 0 if no membrane diffusing species is involved.\ncanchangerate_bypotentialenergy::Bool: Whether the reaction rate depends on reactant species potential energy.\nmembranediffusingnet_stoich::Vector{Pair{Int64, Int64}}: Pairs of membrane diffusing species index =&gt; Δcount"
  },
  {
    "objectID": "docstrings/medyan.membranesitediffusing-66734014eb12ddb1.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.membranesitediffusing-66734014eb12ddb1.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.MembraneSiteDiffusing",
    "section": "",
    "text": "Allows up to 1 membrane diffusing species as reactants. Also stores net stoich of membrane diffusing species.\n\nid_membranediffusing_reactant::Int64: Set to 0 if no membrane diffusing species is involved.\ncanchangerate_bypotentialenergy::Bool: Whether the reaction rate depends on reactant species potential energy.\nmembranediffusingnet_stoich::Vector{Pair{Int64, Int64}}: Pairs of membrane diffusing species index =&gt; Δcount"
  },
  {
    "objectID": "docstrings/medyan.grididat-8671e01413346deb.html",
    "href": "docstrings/medyan.grididat-8671e01413346deb.html",
    "title": "MEDYAN.grididat",
    "section": "",
    "text": "grididat(grid::CubicGrid, location)\nReturn the grid id of location The origin is in the center. Returns a close by voxel if out of the grid"
  },
  {
    "objectID": "docstrings/medyan.grididat-8671e01413346deb.html#tuple-medyan.cubicgrid--any--1be3c03f7960c1a3",
    "href": "docstrings/medyan.grididat-8671e01413346deb.html#tuple-medyan.cubicgrid--any--1be3c03f7960c1a3",
    "title": "MEDYAN.grididat",
    "section": "",
    "text": "grididat(grid::CubicGrid, location)\nReturn the grid id of location The origin is in the center. Returns a close by voxel if out of the grid"
  },
  {
    "objectID": "docstrings/medyan.make_link--0fd0bab9dac08837.html",
    "href": "docstrings/medyan.make_link--0fd0bab9dac08837.html",
    "title": "MEDYAN.make_link!",
    "section": "",
    "text": "make_link!(c::Context; kwargs...)::Link\nReturn the new link.\nThe type keyword argument is required.\nThe other keyword arguments can be used to change the link from default.\n\n\n\ntype::Union{Symbol,Integer}: the link type id or symbol.\nplaces=(): places or tags to attach to the link.\nSet an element to nothing not change the attached place. Set an element to a null place or tag to detach that place.\nstate=(;): state properties to change.\nA NamedTuple of changes. For example, state = (;k1 = 3.6, k7 = 2.0,) to change state.k1 to 3.6 and state.k7 to 2.0.\nbond_states=(): bond state properties to change.\nA Tuple of changes. If an element in the tuple is nothing, the corresponding bond state isn’t changed. For example, bond_states = (nothing, (;L0 = 3.6,)) to change bond_states[2].L0 to 3.6.\nbond_enabled=(): bond enable flags to change.\nA Tuple of Union{Bool, Nothing}. If an element in the tuple isnothing, the corresponding bond enable flag isn't changed. For example,bond_enabled = (nothing, true, false)` to not change bond 1, enable bond 2, and disable bond 3.\nreaction_enabled=(): reaction enable flags to change.\nA Tuple of NamedTuple of changes. If an element in the tuple is nothing, the corresponding reaction enable flags aren’t changed. For example, reaction_enabled = (nothing, (;a=true, b=false)) to not change any reactions on place 1, enable reaction a on place 2, and disable reaction b on place 2.\nis_minimized::Bool=false: is the link marked as minimized.\nBy default links are marked as minimized at the end of mechanics when updated."
  },
  {
    "objectID": "docstrings/medyan.make_link--0fd0bab9dac08837.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.make_link--0fd0bab9dac08837.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.make_link!",
    "section": "",
    "text": "make_link!(c::Context; kwargs...)::Link\nReturn the new link.\nThe type keyword argument is required.\nThe other keyword arguments can be used to change the link from default.\n\n\n\ntype::Union{Symbol,Integer}: the link type id or symbol.\nplaces=(): places or tags to attach to the link.\nSet an element to nothing not change the attached place. Set an element to a null place or tag to detach that place.\nstate=(;): state properties to change.\nA NamedTuple of changes. For example, state = (;k1 = 3.6, k7 = 2.0,) to change state.k1 to 3.6 and state.k7 to 2.0.\nbond_states=(): bond state properties to change.\nA Tuple of changes. If an element in the tuple is nothing, the corresponding bond state isn’t changed. For example, bond_states = (nothing, (;L0 = 3.6,)) to change bond_states[2].L0 to 3.6.\nbond_enabled=(): bond enable flags to change.\nA Tuple of Union{Bool, Nothing}. If an element in the tuple isnothing, the corresponding bond enable flag isn't changed. For example,bond_enabled = (nothing, true, false)` to not change bond 1, enable bond 2, and disable bond 3.\nreaction_enabled=(): reaction enable flags to change.\nA Tuple of NamedTuple of changes. If an element in the tuple is nothing, the corresponding reaction enable flags aren’t changed. For example, reaction_enabled = (nothing, (;a=true, b=false)) to not change any reactions on place 1, enable reaction a on place 2, and disable reaction b on place 2.\nis_minimized::Bool=false: is the link marked as minimized.\nBy default links are marked as minimized at the end of mechanics when updated."
  },
  {
    "objectID": "docstrings/medyan.context-736368ed32b08894.html",
    "href": "docstrings/medyan.context-736368ed32b08894.html",
    "title": "MEDYAN.Context",
    "section": "",
    "text": "Context(sys_def::SysDef, grid::CubicGrid; kwargs...)\n\nagent_names::MEDYAN.AgentNames\nsys_def::MEDYAN.SysDef\ncompartments::Vector{MEDYAN.Compartment}\ngrid::MEDYAN.CubicGrid\ntime::Float64: time (s)\nstats::MEDYAN.PerformanceStats\nβ::Float64: inverse kT (1/(nm*pN))\nbase_diffusion_coeffs::Vector{Float64}: Diffusion coefficients indexed by diffusing species id (nm²/s)\nmembrane_species_params::StaticArraysCore.SVector{NUM_MEMBRANEDIFFUSINGSPECIES, MEDYAN.MembraneSpeciesParams} where NUM_MEMBRANEDIFFUSINGSPECIES: Membrane species parameters indexed by membrane diffusing species id.\nmin_chem_voxel_volume_ratio::Float64: Smallest volume a chem voxel can have before being deactivated as a ratio to a full chem voxel volume.\nchemistryengine::MEDYAN.RDMESampler: The reaction diffusion master equation sampler, contains the diffusing and regular fixed species state\nchem_voxel_volumes::Array{Float64, 3}: Volume of each chemical voxel\nchem_voxel_areas::Array{Float64, 4}: Areas of (-x, -y, -z) faces of each chemical voxel\nchem_cylinders::Vector{MEDYAN.ChemCylinders}: Data about filament cylinders, indexed by filament type id\nballs::StructArrays.StructVector{MEDYAN.Ball, @NamedTuple{position::Vector{StaticArraysCore.SVector{3, Float64}}, radius::Vector{Float32}, stiffness::Vector{Float32}, state::Vector{StaticArraysCore.SVector{3, Int64}}, is_minimized::Vector{Bool}}, Int64}\nmembranes::Vector: All membrane meshes.\nnext_membid::Ref{MEDYAN.MembId}: Next memb id\nmembid2membidx::Dict{MEDYAN.MembId, UInt32}: map from memb id to index memb indexes can change whenever a memb is removed, but id’s are stable\nmembidx2membid::Vector{MEDYAN.MembId}: map from memb index to id\nlink_manager::MEDYAN.LinkManager\ndecimated_2mon_site_managers::Vector{MEDYAN.AbstractDecimated2MonSiteManager}: Site managers, indexed by site id\nfilamentsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filament site definitions, indexed by filament type id, filament site id to get a SiteData with fields of id, site, fxsid\nfilamentendsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filamentend site definitions, indexed by filament type id, filamentend site id to get a SiteData with fields of id, site, fxsid\nmaxfilsite_plusrange::Vector{Int64}: The maximum plus range in monomers that any filament site or end site can see. Indexed by filament type id\nmaxfilsite_minusrange::Vector{Int64}: The maximum minus range in monomers that any filament site or end site can see. Indexed by filament type id\nmembranesites::Tuple{Vararg{MEDYAN.SiteData}}: Maps membrane site id to a SiteData with fields of id, site, fxsid.\nmap_membranediffusingspeciesindex_membranesiteindices::Tuple{Vararg{Vector{Int64}}}: Maps membrane diffusing species index to a list of membrane sites using this species as reactant. This is initialized during context init and should not be changed.\ndecimated_2mon_sites::Vector{MEDYAN.SiteData}: Site definitions, indexed by site id to get a SiteData with fields of id, site, fxsid\npossiblecadherinsite_managers::Tuple{Vararg{MEDYAN.AbstractPossibleCadherinSiteManager}}: Site managers, indexed by site id\ncheck_sitecount_error::Bool: If true site counts are checked for errors on every chem update. This is extremely slow, but useful for testing chem update errors.\ncompartmentreactioncallbacks::Any\nbulkreactioncallbacks::Any\nmemdiff_bulks_index::Int64: Mock bulk species index for membrane diffusion.\nviscosity::Float64: viscosity (pNs/nm² or MPas) water is about 1E-9\ng_tol::Float64: maximum force magnitude after minimization (pN)\nnforce_fractbit::Int64: number of fractional bits used to scale force values into Int64\nnenergy_fractbit::Int64: number of fractional bits used to scale energy values into Int64\nshake_before_minimization::Float64: Standard deviation of noise added to coordinates before starting minimization.\niter_max_cg_minimization::Int64: Max number of steps in conjugate gradient minimization.\nmaxstep::Float64: max step to take during line search (nm)\ncheck_neighborlist_error::Bool: If true neighborlists are checked for errors on every force calc. This is extremely slow, but useful for testing neighborlist errors.\nnthreads::Int64: Experimental Set to more than 1 to enable multi threading. This is currently may result in non bitwise reproducable simulations. Results should be statistcally identical, but this is currently not well tested.\nenable_collision::Ref{Bool}: Are collision forces calculated\ncollision_skin::Float64: Extra collision neighbor list cutoff radius in nm. The neighbor lists are reset after something moves over this amount\ncollision_switchover_scale_unitless::Float32: Smoothing scale to avoid sharp forces when two cylinders are collinear\nfilamentmechparams::Vector{MEDYAN.FilamentMechParams}: The filament mechanical parameters, indexed by filament type id\nfunc_membranespeciespotentialenergy::Any: Membrane species potential energy function. See docs on default function for more info.\nexternal_energy_forces!::Any: External energy/force expressions. This should be a mutating function taking a (fc::MEDYAN.ForceContext, vectorized_x), which adds to fc.forces, fc.energies, and fc.energy. The energy and force must be consistent, and this is not checked. This can be used as ad-hoc solutions to experiment with uncommon forces, such as specifically designed attachments, etc. If this variable is used often, consider moving it into MEDYAN.\nchemboundary::MEDYAN.Boundary: chemical boundary, updates compartment volumes and diffusion rates\nchem_boundary_oversampling_factor::Int64: Oversampling factor for chem boundary TSDF computation. Default is 4.\nchem_boundary_tsdf_max_distance::Float64: Maximum distance for TSDF truncation (nm). Actual max is max(this, 2.5*grid_spacing). Default is 312.5 nm.\nchem_boundary_tsdf_cache::Union{Nothing, Array{Float64, 3}}: Cached truncated signed distance field for chem boundary. nothing means cache is invalid.\nmechboundary::MEDYAN.Boundary: mechanical boundary\nsharedtypedconfigs::MEDYAN.SharedTypedConfigs: Shared configurations stored in type parameters.\nvalidflags::MEDYAN.ValidFlags: Interval system consistency validation flags.\nprofiler::ZoneProfilers.Profiler"
  },
  {
    "objectID": "docstrings/medyan.context-736368ed32b08894.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.context-736368ed32b08894.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.Context",
    "section": "",
    "text": "Context(sys_def::SysDef, grid::CubicGrid; kwargs...)\n\nagent_names::MEDYAN.AgentNames\nsys_def::MEDYAN.SysDef\ncompartments::Vector{MEDYAN.Compartment}\ngrid::MEDYAN.CubicGrid\ntime::Float64: time (s)\nstats::MEDYAN.PerformanceStats\nβ::Float64: inverse kT (1/(nm*pN))\nbase_diffusion_coeffs::Vector{Float64}: Diffusion coefficients indexed by diffusing species id (nm²/s)\nmembrane_species_params::StaticArraysCore.SVector{NUM_MEMBRANEDIFFUSINGSPECIES, MEDYAN.MembraneSpeciesParams} where NUM_MEMBRANEDIFFUSINGSPECIES: Membrane species parameters indexed by membrane diffusing species id.\nmin_chem_voxel_volume_ratio::Float64: Smallest volume a chem voxel can have before being deactivated as a ratio to a full chem voxel volume.\nchemistryengine::MEDYAN.RDMESampler: The reaction diffusion master equation sampler, contains the diffusing and regular fixed species state\nchem_voxel_volumes::Array{Float64, 3}: Volume of each chemical voxel\nchem_voxel_areas::Array{Float64, 4}: Areas of (-x, -y, -z) faces of each chemical voxel\nchem_cylinders::Vector{MEDYAN.ChemCylinders}: Data about filament cylinders, indexed by filament type id\nballs::StructArrays.StructVector{MEDYAN.Ball, @NamedTuple{position::Vector{StaticArraysCore.SVector{3, Float64}}, radius::Vector{Float32}, stiffness::Vector{Float32}, state::Vector{StaticArraysCore.SVector{3, Int64}}, is_minimized::Vector{Bool}}, Int64}\nmembranes::Vector: All membrane meshes.\nnext_membid::Ref{MEDYAN.MembId}: Next memb id\nmembid2membidx::Dict{MEDYAN.MembId, UInt32}: map from memb id to index memb indexes can change whenever a memb is removed, but id’s are stable\nmembidx2membid::Vector{MEDYAN.MembId}: map from memb index to id\nlink_manager::MEDYAN.LinkManager\ndecimated_2mon_site_managers::Vector{MEDYAN.AbstractDecimated2MonSiteManager}: Site managers, indexed by site id\nfilamentsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filament site definitions, indexed by filament type id, filament site id to get a SiteData with fields of id, site, fxsid\nfilamentendsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filamentend site definitions, indexed by filament type id, filamentend site id to get a SiteData with fields of id, site, fxsid\nmaxfilsite_plusrange::Vector{Int64}: The maximum plus range in monomers that any filament site or end site can see. Indexed by filament type id\nmaxfilsite_minusrange::Vector{Int64}: The maximum minus range in monomers that any filament site or end site can see. Indexed by filament type id\nmembranesites::Tuple{Vararg{MEDYAN.SiteData}}: Maps membrane site id to a SiteData with fields of id, site, fxsid.\nmap_membranediffusingspeciesindex_membranesiteindices::Tuple{Vararg{Vector{Int64}}}: Maps membrane diffusing species index to a list of membrane sites using this species as reactant. This is initialized during context init and should not be changed.\ndecimated_2mon_sites::Vector{MEDYAN.SiteData}: Site definitions, indexed by site id to get a SiteData with fields of id, site, fxsid\npossiblecadherinsite_managers::Tuple{Vararg{MEDYAN.AbstractPossibleCadherinSiteManager}}: Site managers, indexed by site id\ncheck_sitecount_error::Bool: If true site counts are checked for errors on every chem update. This is extremely slow, but useful for testing chem update errors.\ncompartmentreactioncallbacks::Any\nbulkreactioncallbacks::Any\nmemdiff_bulks_index::Int64: Mock bulk species index for membrane diffusion.\nviscosity::Float64: viscosity (pNs/nm² or MPas) water is about 1E-9\ng_tol::Float64: maximum force magnitude after minimization (pN)\nnforce_fractbit::Int64: number of fractional bits used to scale force values into Int64\nnenergy_fractbit::Int64: number of fractional bits used to scale energy values into Int64\nshake_before_minimization::Float64: Standard deviation of noise added to coordinates before starting minimization.\niter_max_cg_minimization::Int64: Max number of steps in conjugate gradient minimization.\nmaxstep::Float64: max step to take during line search (nm)\ncheck_neighborlist_error::Bool: If true neighborlists are checked for errors on every force calc. This is extremely slow, but useful for testing neighborlist errors.\nnthreads::Int64: Experimental Set to more than 1 to enable multi threading. This is currently may result in non bitwise reproducable simulations. Results should be statistcally identical, but this is currently not well tested.\nenable_collision::Ref{Bool}: Are collision forces calculated\ncollision_skin::Float64: Extra collision neighbor list cutoff radius in nm. The neighbor lists are reset after something moves over this amount\ncollision_switchover_scale_unitless::Float32: Smoothing scale to avoid sharp forces when two cylinders are collinear\nfilamentmechparams::Vector{MEDYAN.FilamentMechParams}: The filament mechanical parameters, indexed by filament type id\nfunc_membranespeciespotentialenergy::Any: Membrane species potential energy function. See docs on default function for more info.\nexternal_energy_forces!::Any: External energy/force expressions. This should be a mutating function taking a (fc::MEDYAN.ForceContext, vectorized_x), which adds to fc.forces, fc.energies, and fc.energy. The energy and force must be consistent, and this is not checked. This can be used as ad-hoc solutions to experiment with uncommon forces, such as specifically designed attachments, etc. If this variable is used often, consider moving it into MEDYAN.\nchemboundary::MEDYAN.Boundary: chemical boundary, updates compartment volumes and diffusion rates\nchem_boundary_oversampling_factor::Int64: Oversampling factor for chem boundary TSDF computation. Default is 4.\nchem_boundary_tsdf_max_distance::Float64: Maximum distance for TSDF truncation (nm). Actual max is max(this, 2.5*grid_spacing). Default is 312.5 nm.\nchem_boundary_tsdf_cache::Union{Nothing, Array{Float64, 3}}: Cached truncated signed distance field for chem boundary. nothing means cache is invalid.\nmechboundary::MEDYAN.Boundary: mechanical boundary\nsharedtypedconfigs::MEDYAN.SharedTypedConfigs: Shared configurations stored in type parameters.\nvalidflags::MEDYAN.ValidFlags: Interval system consistency validation flags.\nprofiler::ZoneProfilers.Profiler"
  },
  {
    "objectID": "docstrings/medyan.agentnames-948e6a24b4fb0cb5.html",
    "href": "docstrings/medyan.agentnames-948e6a24b4fb0cb5.html",
    "title": "MEDYAN.AgentNames",
    "section": "",
    "text": "The names of the agents in a simulation\n\ndiffusingspeciesnames::Vector{Symbol}\nbulkspeciesnames::Vector{Symbol}\nmembranediffusingspeciesnames::Vector{Symbol}\nfixedspeciesnames::Vector{Symbol}\nfilamentnames::Vector{Tuple{Symbol, Vector{Symbol}}}"
  },
  {
    "objectID": "docstrings/medyan.agentnames-948e6a24b4fb0cb5.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.agentnames-948e6a24b4fb0cb5.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.AgentNames",
    "section": "",
    "text": "The names of the agents in a simulation\n\ndiffusingspeciesnames::Vector{Symbol}\nbulkspeciesnames::Vector{Symbol}\nmembranediffusingspeciesnames::Vector{Symbol}\nfixedspeciesnames::Vector{Symbol}\nfilamentnames::Vector{Tuple{Symbol, Vector{Symbol}}}"
  },
  {
    "objectID": "docstrings/medyan.addreaction--da9bd35e7d1df7c3.html",
    "href": "docstrings/medyan.addreaction--da9bd35e7d1df7c3.html",
    "title": "MEDYAN.addreaction!",
    "section": "",
    "text": "addreaction!(s::SysDef,reactionexpr::AbstractString,rate::Float64,invvolumepower::Int)::SysDef\nAdd a reaction to the system. Return s\nreactionexpr is a string describing the reaction stoichiometry\nreactionexpr is comprised of reactant and product parts seperated by a \"--&gt;\"\nAll whitespace characters are ignored.\nEach side is then split by \"+\" to get the species names.\nRepeated or extra \"+\" are ignored.\nA species name can be prepended by a positive integer to represent multiple copies.\n\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s) rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)).\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\"diffusing.a + diffusing.b --&gt; diffusing.c\"\n\"diffusing.c --&gt; diffusing.a + diffusing.b\"\n\"+ + diffusing.c + --&gt; + diffusing.a + + diffusing.b + +\"\n\" --&gt; diffusing.a + diffusing.b\"\n\"diffusing.a + diffusing.b --&gt; \"\n\"diffusing.a + diffusing.a --&gt; \"\n\"2diffusing.a --&gt; \"\n\"2diffusing.a --&gt; 20diffusing.a\"\n\"diffusing.c + diffusing.b --&gt; diffusing.c + diffusing.b\"\n\"fixedspecies.rate1b --&gt; fixedspecies.g\"\n\"fixedspecies.rate1b + fixedspecies.g --&gt; fixedspecies.g\"\n\"fixedspecies.rate1b + 23fixedspecies.g --&gt; fixedspecies.g\"\n\"fixedspecies.g --&gt; fixedspecies.rate1b + 23fixedspecies.g\"\n\"fixedspecies.g + fixedspecies.rate1b--&gt; 2fixedspecies.rate1b + 23fixedspecies.g\"\n\"filamentsite.MT.d --&gt; filamentsite.MT.d\"\n\"filamentsite.MT.d + diffusing.a --&gt; filamentsite.MT.d\"\n\"fixedspecies.g --&gt; diffusing.a\"\n\"diffusing.a --&gt; fixedspecies.g\"\n\"filamentsite.actin.pm + diffusing.a --&gt; filamentsite.actin.pm\""
  },
  {
    "objectID": "docstrings/medyan.addreaction--da9bd35e7d1df7c3.html#tuple-medyan.sysdef--abstractstring--float64--int64--458efa379d290938",
    "href": "docstrings/medyan.addreaction--da9bd35e7d1df7c3.html#tuple-medyan.sysdef--abstractstring--float64--int64--458efa379d290938",
    "title": "MEDYAN.addreaction!",
    "section": "",
    "text": "addreaction!(s::SysDef,reactionexpr::AbstractString,rate::Float64,invvolumepower::Int)::SysDef\nAdd a reaction to the system. Return s\nreactionexpr is a string describing the reaction stoichiometry\nreactionexpr is comprised of reactant and product parts seperated by a \"--&gt;\"\nAll whitespace characters are ignored.\nEach side is then split by \"+\" to get the species names.\nRepeated or extra \"+\" are ignored.\nA species name can be prepended by a positive integer to represent multiple copies.\n\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s) rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)).\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\"diffusing.a + diffusing.b --&gt; diffusing.c\"\n\"diffusing.c --&gt; diffusing.a + diffusing.b\"\n\"+ + diffusing.c + --&gt; + diffusing.a + + diffusing.b + +\"\n\" --&gt; diffusing.a + diffusing.b\"\n\"diffusing.a + diffusing.b --&gt; \"\n\"diffusing.a + diffusing.a --&gt; \"\n\"2diffusing.a --&gt; \"\n\"2diffusing.a --&gt; 20diffusing.a\"\n\"diffusing.c + diffusing.b --&gt; diffusing.c + diffusing.b\"\n\"fixedspecies.rate1b --&gt; fixedspecies.g\"\n\"fixedspecies.rate1b + fixedspecies.g --&gt; fixedspecies.g\"\n\"fixedspecies.rate1b + 23fixedspecies.g --&gt; fixedspecies.g\"\n\"fixedspecies.g --&gt; fixedspecies.rate1b + 23fixedspecies.g\"\n\"fixedspecies.g + fixedspecies.rate1b--&gt; 2fixedspecies.rate1b + 23fixedspecies.g\"\n\"filamentsite.MT.d --&gt; filamentsite.MT.d\"\n\"filamentsite.MT.d + diffusing.a --&gt; filamentsite.MT.d\"\n\"fixedspecies.g --&gt; diffusing.a\"\n\"diffusing.a --&gt; fixedspecies.g\"\n\"filamentsite.actin.pm + diffusing.a --&gt; filamentsite.actin.pm\""
  },
  {
    "objectID": "docstrings/medyan.get_all_tags-3a8e6bc0634c8a4d.html",
    "href": "docstrings/medyan.get_all_tags-3a8e6bc0634c8a4d.html",
    "title": "MEDYAN.get_all_tags",
    "section": "",
    "text": "get_all_tags(c::Context, p::Place) -&gt; Tag{typeof(p)} iterator\nReturn an iterator of existing tags for the type of p."
  },
  {
    "objectID": "docstrings/medyan.get_all_tags-3a8e6bc0634c8a4d.html#union-tuple-p---tuple-medyan.context--p---where-p--medyan.place-316eaf4f0092762b",
    "href": "docstrings/medyan.get_all_tags-3a8e6bc0634c8a4d.html#union-tuple-p---tuple-medyan.context--p---where-p--medyan.place-316eaf4f0092762b",
    "title": "MEDYAN.get_all_tags",
    "section": "",
    "text": "get_all_tags(c::Context, p::Place) -&gt; Tag{typeof(p)} iterator\nReturn an iterator of existing tags for the type of p."
  },
  {
    "objectID": "docstrings/medyan.make_memb--3b9234d85f7612ed.html",
    "href": "docstrings/medyan.make_memb--3b9234d85f7612ed.html",
    "title": "MEDYAN.make_memb!",
    "section": "",
    "text": "make_memb!(c::Context; vertex_positions, triangles)::MembId\nReturn a membrane identifier of the newly created membrane.\n\n\n\nvertex_positions: Each element is a vertex position (nm).\ntriangles::Vector{SVector{3, Int}}: Each element is the 3 vertex indexes of a triangle.\nIndexes are one based, and follow the right hand rule. Looking at the triangle from the outside in, they have counterclockwise winding.\nvertex_states::Union{Vector{Int64}, Nothing} = nothing: Each element is a vertex state.\nBy default vertices have a state of zero. If a vertex has a non zero state, it will not be removed during mesh adaption.\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior."
  },
  {
    "objectID": "docstrings/medyan.make_memb--3b9234d85f7612ed.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.make_memb--3b9234d85f7612ed.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.make_memb!",
    "section": "",
    "text": "make_memb!(c::Context; vertex_positions, triangles)::MembId\nReturn a membrane identifier of the newly created membrane.\n\n\n\nvertex_positions: Each element is a vertex position (nm).\ntriangles::Vector{SVector{3, Int}}: Each element is the 3 vertex indexes of a triangle.\nIndexes are one based, and follow the right hand rule. Looking at the triangle from the outside in, they have counterclockwise winding.\nvertex_states::Union{Vector{Int64}, Nothing} = nothing: Each element is a vertex state.\nBy default vertices have a state of zero. If a vertex has a non zero state, it will not be removed during mesh adaption.\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior."
  },
  {
    "objectID": "docstrings/medyan.addmembranesite--892875b2c079002d.html",
    "href": "docstrings/medyan.addmembranesite--892875b2c079002d.html",
    "title": "MEDYAN.addmembranesite!",
    "section": "",
    "text": "addmembranesite!(\n    s::MEDYAN.SysDef,\n    membranesitename::Symbol,\n    site\n) -&gt; MEDYAN.SysDef\nAdd a new site with a specified name. During this process, a new fixed species is created suffixed with “membranesite.”."
  },
  {
    "objectID": "docstrings/medyan.addmembranesite--892875b2c079002d.html#tuple-medyan.sysdef--symbol--any--444c61f2a1ac78e1",
    "href": "docstrings/medyan.addmembranesite--892875b2c079002d.html#tuple-medyan.sysdef--symbol--any--444c61f2a1ac78e1",
    "title": "MEDYAN.addmembranesite!",
    "section": "",
    "text": "addmembranesite!(\n    s::MEDYAN.SysDef,\n    membranesitename::Symbol,\n    site\n) -&gt; MEDYAN.SysDef\nAdd a new site with a specified name. During this process, a new fixed species is created suffixed with “membranesite.”."
  },
  {
    "objectID": "docstrings/base.push--8715d52e2302aaeb.html",
    "href": "docstrings/base.push--8715d52e2302aaeb.html",
    "title": "Base.push!",
    "section": "",
    "text": "Add a new index. Returns its ID."
  },
  {
    "objectID": "docstrings/base.push--8715d52e2302aaeb.html#tuple-medyan.stableindex--integer--14e9a5b3c446a8fc",
    "href": "docstrings/base.push--8715d52e2302aaeb.html#tuple-medyan.stableindex--integer--14e9a5b3c446a8fc",
    "title": "Base.push!",
    "section": "",
    "text": "Add a new index. Returns its ID."
  },
  {
    "objectID": "docstrings/medyan.filter_grididat-58a94154d21e32b0.html",
    "href": "docstrings/medyan.filter_grididat-58a94154d21e32b0.html",
    "title": "MEDYAN.filter_grididat",
    "section": "",
    "text": "filter_grididat(f, grid::CubicGrid, location)\nReturn the nearest grid id of location where f(id) evaluates to true. The origin is in the center. errors if there is no id that evaluates to true. Returns a close by voxel if out of the grid."
  },
  {
    "objectID": "docstrings/medyan.filter_grididat-58a94154d21e32b0.html#tuple-any--medyan.cubicgrid--any--68d3cc6d4c523833",
    "href": "docstrings/medyan.filter_grididat-58a94154d21e32b0.html#tuple-any--medyan.cubicgrid--any--68d3cc6d4c523833",
    "title": "MEDYAN.filter_grididat",
    "section": "",
    "text": "filter_grididat(f, grid::CubicGrid, location)\nReturn the nearest grid id of location where f(id) evaluates to true. The origin is in the center. errors if there is no id that evaluates to true. Returns a close by voxel if out of the grid."
  },
  {
    "objectID": "docstrings/medyan.boundary-f1e7be79002a27f8.html",
    "href": "docstrings/medyan.boundary-f1e7be79002a27f8.html",
    "title": "MEDYAN.Boundary",
    "section": "",
    "text": "Mechanical boundary\nSee also boundary_box\n\nplanes::Vector{StaticArraysCore.SVector{4, Float64}}: Planes that make up the mechanical boundary of the simulation.\nE = 1//2 * relu(pos ⋅ planes[bi][1:3] - planes[bi][4])^2\nFor example, a mech bounding plane [1,0,0,3] would try and make x &lt; 3 nm with a spring constant of 1 pN/nm.\n2.0*[1,0,0,3] would try and make x &lt; 3 nm with a spring constant of 4 pN/nm.\ncapsules::Vector{StaticArraysCore.SVector{8, Float64}}: Capsules that make up the mechanical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). If the radius is negative, the domain is the outside of the capsule, if the radius is positive the domain is inside the capsule. capsules[bi][8] is the spring constant (pN/nm).\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\nE = 1//2*k*relu(sign(r0)*d - r0)^2 where:\n\nd is the distance of the point to the spine line segment described by capsules[bi][1:6].\nr0 is capsules[bi][7]\nk is capsules[bi][8]"
  },
  {
    "objectID": "docstrings/medyan.boundary-f1e7be79002a27f8.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.boundary-f1e7be79002a27f8.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.Boundary",
    "section": "",
    "text": "Mechanical boundary\nSee also boundary_box\n\nplanes::Vector{StaticArraysCore.SVector{4, Float64}}: Planes that make up the mechanical boundary of the simulation.\nE = 1//2 * relu(pos ⋅ planes[bi][1:3] - planes[bi][4])^2\nFor example, a mech bounding plane [1,0,0,3] would try and make x &lt; 3 nm with a spring constant of 1 pN/nm.\n2.0*[1,0,0,3] would try and make x &lt; 3 nm with a spring constant of 4 pN/nm.\ncapsules::Vector{StaticArraysCore.SVector{8, Float64}}: Capsules that make up the mechanical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). If the radius is negative, the domain is the outside of the capsule, if the radius is positive the domain is inside the capsule. capsules[bi][8] is the spring constant (pN/nm).\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\nE = 1//2*k*relu(sign(r0)*d - r0)^2 where:\n\nd is the distance of the point to the spine line segment described by capsules[bi][1:6].\nr0 is capsules[bi][7]\nk is capsules[bi][8]"
  },
  {
    "objectID": "docstrings/medyan.def_fila_reaction--070b0fa01eaea608.html",
    "href": "docstrings/medyan.def_fila_reaction--070b0fa01eaea608.html",
    "title": "MEDYAN.def_fila_reaction!",
    "section": "",
    "text": "def_fila_reaction!(s::SysDef; fila_type, name, match, ...)\nAdd a filament monomer reaction. The reaction fires at monomers whose local neighborhood matches a pattern of states. When it fires, the matched monomers can be changed to new, or a custom affect! callback can handle arbitrary side effects.\nAll pattern positions must lie on the filament. Monomers near the ends where the pattern would extend past the boundary are automatically skipped. Use def_fila_tip_reaction! for reactions at filament ends.\n\n\n\n\n\nfila_type::Symbol: Filament type (e.g., :actin).\nname::Symbol: Unique name for this reaction site.\nmatch::Vector: Pattern of monomer states to match, ordered minus → plus end. Each element can be:\n\nSymbol — exact state (e.g., :a)\nVector{Symbol} — any of these states (e.g., [:a, :b])\nanystate — any state\n\n\n\n\n\n\nnew::Vector{Symbol}: States to assign to the matched monomers after firing. Must be the same length as match. Cannot be used with affect!.\naffect!: Custom callback (c::Context; chem_voxel::Int, center::FilaMonoIdx, kwargs...) -&gt; Int. Called instead of automatic state changes. The returned Int is a status code. Cannot be used with new.\n\n\n\n\n\nnet_stoich::Vector{Pair{Symbol,Int}} = Pair{Symbol,Int}[]: Net change to diffusing species when the reaction fires. Each entry is species_name =&gt; amount, e.g. [:ligand =&gt; -1] to consume one ligand per firing. The callback handles the count update automatically. Can only be used with new, not with affect!.\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s.\ninvvolumepower::Int = 0: Set to 0 for unimolecular, 1 for bimolecular.\nreactants_extra::String = \"\": Additional reactant species that contribute to propensity (e.g., \"diffusing.ligand\"). The species is not consumed automatically.\n\n\n\n\n\ncenter::Int = cld(length(match), 2): Which position in match is the center of the reaction. Determines which chem_voxel the reaction is assigned to.\n\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_fila_type!(s; name=:actin, mono_states=[:a, :b, :c], param=MEDYAN.ACTIN_TWIST_PARAMS)\n\n# Aging: every :a monomer transitions to :b\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :aging,\n    match = [:a],\n    new = [:b],\n    base_rate = 2.4,\n)\n\n# Cooperative transition: :a next to :b on the minus side becomes :b\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :cooperate,\n    match = [:b, :a],\n    new = [:b, :b],\n    center = 2,\n    base_rate = 0.4,\n)\n\n# Bimolecular binding with a diffusing ligand using affect!\ndef_diffusing_species!(s, :ligand; coeff=2.5e7)\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :bind_affect,\n    match = [:a],\n    affect! = (c; center, chem_voxel, kwargs...) -&gt; let\n        update_fila_mono_state!(c, center, :b)\n        add_diffusing_count!(c; species=:ligand, chem_voxel, amount=-1)\n        1\n    end,\n    base_rate = 1e6,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.ligand\",\n)\n\n# Bimolecular binding with a diffusing ligand using net_stoich\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :bind_stoich,\n    match = [:a],\n    new = [:b],\n    net_stoich = [:ligand =&gt; -1],\n    base_rate = 1e6,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.ligand\",\n)\n\n# Match a set of states: :a or :b → :c\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :a_or_b,\n    match = [[:a, :b]],\n    new = [:c],\n    base_rate = 1.0,\n)\n\n# anystate with neighbor constraint: any monomer whose plus neighbor is :a\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :any_then_a,\n    match = [anystate, :a],\n    new = [:a, :b],\n    center = 2,\n    base_rate = 1.0,\n)"
  },
  {
    "objectID": "docstrings/medyan.def_fila_reaction--070b0fa01eaea608.html#tuple-medyan.sysdef--efaa49a98644904f",
    "href": "docstrings/medyan.def_fila_reaction--070b0fa01eaea608.html#tuple-medyan.sysdef--efaa49a98644904f",
    "title": "MEDYAN.def_fila_reaction!",
    "section": "",
    "text": "def_fila_reaction!(s::SysDef; fila_type, name, match, ...)\nAdd a filament monomer reaction. The reaction fires at monomers whose local neighborhood matches a pattern of states. When it fires, the matched monomers can be changed to new, or a custom affect! callback can handle arbitrary side effects.\nAll pattern positions must lie on the filament. Monomers near the ends where the pattern would extend past the boundary are automatically skipped. Use def_fila_tip_reaction! for reactions at filament ends.\n\n\n\n\n\nfila_type::Symbol: Filament type (e.g., :actin).\nname::Symbol: Unique name for this reaction site.\nmatch::Vector: Pattern of monomer states to match, ordered minus → plus end. Each element can be:\n\nSymbol — exact state (e.g., :a)\nVector{Symbol} — any of these states (e.g., [:a, :b])\nanystate — any state\n\n\n\n\n\n\nnew::Vector{Symbol}: States to assign to the matched monomers after firing. Must be the same length as match. Cannot be used with affect!.\naffect!: Custom callback (c::Context; chem_voxel::Int, center::FilaMonoIdx, kwargs...) -&gt; Int. Called instead of automatic state changes. The returned Int is a status code. Cannot be used with new.\n\n\n\n\n\nnet_stoich::Vector{Pair{Symbol,Int}} = Pair{Symbol,Int}[]: Net change to diffusing species when the reaction fires. Each entry is species_name =&gt; amount, e.g. [:ligand =&gt; -1] to consume one ligand per firing. The callback handles the count update automatically. Can only be used with new, not with affect!.\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s.\ninvvolumepower::Int = 0: Set to 0 for unimolecular, 1 for bimolecular.\nreactants_extra::String = \"\": Additional reactant species that contribute to propensity (e.g., \"diffusing.ligand\"). The species is not consumed automatically.\n\n\n\n\n\ncenter::Int = cld(length(match), 2): Which position in match is the center of the reaction. Determines which chem_voxel the reaction is assigned to.\n\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_fila_type!(s; name=:actin, mono_states=[:a, :b, :c], param=MEDYAN.ACTIN_TWIST_PARAMS)\n\n# Aging: every :a monomer transitions to :b\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :aging,\n    match = [:a],\n    new = [:b],\n    base_rate = 2.4,\n)\n\n# Cooperative transition: :a next to :b on the minus side becomes :b\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :cooperate,\n    match = [:b, :a],\n    new = [:b, :b],\n    center = 2,\n    base_rate = 0.4,\n)\n\n# Bimolecular binding with a diffusing ligand using affect!\ndef_diffusing_species!(s, :ligand; coeff=2.5e7)\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :bind_affect,\n    match = [:a],\n    affect! = (c; center, chem_voxel, kwargs...) -&gt; let\n        update_fila_mono_state!(c, center, :b)\n        add_diffusing_count!(c; species=:ligand, chem_voxel, amount=-1)\n        1\n    end,\n    base_rate = 1e6,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.ligand\",\n)\n\n# Bimolecular binding with a diffusing ligand using net_stoich\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :bind_stoich,\n    match = [:a],\n    new = [:b],\n    net_stoich = [:ligand =&gt; -1],\n    base_rate = 1e6,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.ligand\",\n)\n\n# Match a set of states: :a or :b → :c\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :a_or_b,\n    match = [[:a, :b]],\n    new = [:c],\n    base_rate = 1.0,\n)\n\n# anystate with neighbor constraint: any monomer whose plus neighbor is :a\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :any_then_a,\n    match = [anystate, :a],\n    new = [:a, :b],\n    center = 2,\n    base_rate = 1.0,\n)"
  },
  {
    "objectID": "docstrings/medyan.remove_anchor--5ded3fc420c1ef42.html",
    "href": "docstrings/medyan.remove_anchor--5ded3fc420c1ef42.html",
    "title": "MEDYAN.remove_anchor!",
    "section": "",
    "text": "remove_anchor!(c::Context, anchor::Union{Anchor, Tag{Anchor}})::Nothing\nRemove an anchor. Any attached links will be unlinked."
  },
  {
    "objectID": "docstrings/medyan.remove_anchor--5ded3fc420c1ef42.html#tuple-medyan.context--medyan.anchor--d87b2d0c5fce340d",
    "href": "docstrings/medyan.remove_anchor--5ded3fc420c1ef42.html#tuple-medyan.context--medyan.anchor--d87b2d0c5fce340d",
    "title": "MEDYAN.remove_anchor!",
    "section": "",
    "text": "remove_anchor!(c::Context, anchor::Union{Anchor, Tag{Anchor}})::Nothing\nRemove an anchor. Any attached links will be unlinked."
  },
  {
    "objectID": "docstrings/medyan.set_chem_boundary_tsdf_max_distance--6d2b2e3f7c85a2e1.html",
    "href": "docstrings/medyan.set_chem_boundary_tsdf_max_distance--6d2b2e3f7c85a2e1.html",
    "title": "MEDYAN.set_chem_boundary_tsdf_max_distance!",
    "section": "",
    "text": "set_chem_boundary_tsdf_max_distance!(\n    c::MEDYAN.Context,\n    max_distance::Float64\n)\nSet the maximum distance for TSDF truncation (nm). The actual max distance used is max(this, 2.5*grid_spacing). This will invalidate the TSDF cache."
  },
  {
    "objectID": "docstrings/medyan.set_chem_boundary_tsdf_max_distance--6d2b2e3f7c85a2e1.html#tuple-medyan.context--float64--5f0fd8a48f76a337",
    "href": "docstrings/medyan.set_chem_boundary_tsdf_max_distance--6d2b2e3f7c85a2e1.html#tuple-medyan.context--float64--5f0fd8a48f76a337",
    "title": "MEDYAN.set_chem_boundary_tsdf_max_distance!",
    "section": "",
    "text": "set_chem_boundary_tsdf_max_distance!(\n    c::MEDYAN.Context,\n    max_distance::Float64\n)\nSet the maximum distance for TSDF truncation (nm). The actual max distance used is max(this, 2.5*grid_spacing). This will invalidate the TSDF cache."
  },
  {
    "objectID": "docstrings/medyan.tag_exists-c112bb84254d0b58.html",
    "href": "docstrings/medyan.tag_exists-c112bb84254d0b58.html",
    "title": "MEDYAN.tag_exists",
    "section": "",
    "text": "tag_exists(c::Context, t::Tag)::Bool\nReturn true iff tag t exists in context c. Otherwise return false."
  },
  {
    "objectID": "docstrings/medyan.tag_exists-c112bb84254d0b58.html#union-tuple-p---tuple-medyan.context--medyan.tag-p----where-p-f3255fd0d268d21a",
    "href": "docstrings/medyan.tag_exists-c112bb84254d0b58.html#union-tuple-p---tuple-medyan.context--medyan.tag-p----where-p-f3255fd0d268d21a",
    "title": "MEDYAN.tag_exists",
    "section": "",
    "text": "tag_exists(c::Context, t::Tag)::Bool\nReturn true iff tag t exists in context c. Otherwise return false."
  },
  {
    "objectID": "docstrings/medyan.update_fila_mono_state--02d30b25ab495f22.html",
    "href": "docstrings/medyan.update_fila_mono_state--02d30b25ab495f22.html",
    "title": "MEDYAN.update_fila_mono_state!",
    "section": "",
    "text": "update_fila_mono_state!(c::Context, p::FilaMonoIdx, state::Union{Symbol,MonomerState})\nUpdate a monomer state."
  },
  {
    "objectID": "docstrings/medyan.update_fila_mono_state--02d30b25ab495f22.html#tuple-medyan.context--medyan.filamonoidx--union-uint8--symbol---85b1405fc752dbf8",
    "href": "docstrings/medyan.update_fila_mono_state--02d30b25ab495f22.html#tuple-medyan.context--medyan.filamonoidx--union-uint8--symbol---85b1405fc752dbf8",
    "title": "MEDYAN.update_fila_mono_state!",
    "section": "",
    "text": "update_fila_mono_state!(c::Context, p::FilaMonoIdx, state::Union{Symbol,MonomerState})\nUpdate a monomer state."
  },
  {
    "objectID": "docstrings/src/boundary.html",
    "href": "docstrings/src/boundary.html",
    "title": "src/boundary.jl",
    "section": "",
    "text": "Mechanical boundary\nSee also boundary_box\n\nplanes::Vector{StaticArraysCore.SVector{4, Float64}}: Planes that make up the mechanical boundary of the simulation.\nE = 1//2 * relu(pos ⋅ planes[bi][1:3] - planes[bi][4])^2\nFor example, a mech bounding plane [1,0,0,3] would try and make x &lt; 3 nm with a spring constant of 1 pN/nm.\n2.0*[1,0,0,3] would try and make x &lt; 3 nm with a spring constant of 4 pN/nm.\ncapsules::Vector{StaticArraysCore.SVector{8, Float64}}: Capsules that make up the mechanical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). If the radius is negative, the domain is the outside of the capsule, if the radius is positive the domain is inside the capsule. capsules[bi][8] is the spring constant (pN/nm).\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\nE = 1//2*k*relu(sign(r0)*d - r0)^2 where:\n\nd is the distance of the point to the spine line segment described by capsules[bi][1:6].\nr0 is capsules[bi][7]\nk is capsules[bi][8]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nboundary_plane(\n;\n    normal,\n    point,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a plane boundary.\nnormal(unit vector): Vector pointing normal to the plane. This points outside of the boundary.\npoint(nm): Point on the plane.\nstiffness(pN/nm): How strong the boundary is.\n\n\n\n\n\n\n\n\n\n\n\n\nboundary_box(\n    grid::MEDYAN.CubicGrid;\n    offset,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a box boundary at the edge of a grid.\noffset(nm): How far the bounding planes should be moved in from the edge of the grid. Positive is inside the grid, negative is outside the grid.\nstiffness(pN/nm): How strong the boundary is.\n\n\n\n\n\n\n\n\n\n\n\n\nboundary_capsule(\n;\n    center,\n    axis,\n    radius,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a capsule boundary.\ncenter(nm): The center of the capsule.\naxis(nm): The direction and length of the capsule spine. The spine line segment goes from center - axis/2 to center + axis/2 If zero the capsule is a sphere.\nradius(nm): Radius of capsule, the full length of the capsule is norm(axis) + 2*abs(radius). If negative, the domain is the outside of the capsule, if positive the domain is the inside of the capsule.\nstiffness(pN/nm): How strong the boundary is.\n\n\n\n\n\n\n\n\n\n\n\n\nboundary_cylinder(\n;\n    center,\n    axis,\n    radius,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a cylinder boundary.\ncenter(nm): The center of the cylinder.\naxis(nm): The direction and length of the cylinder. The spine line segment goes from center - axis/2 to center + axis/2 the full length of the cylinder is norm(axis).\nradius(nm): Radius of cylinder.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/src/boundary.html#medyan.boundary-f1e7be79002a27f8",
    "href": "docstrings/src/boundary.html#medyan.boundary-f1e7be79002a27f8",
    "title": "src/boundary.jl",
    "section": "",
    "text": "Mechanical boundary\nSee also boundary_box\n\nplanes::Vector{StaticArraysCore.SVector{4, Float64}}: Planes that make up the mechanical boundary of the simulation.\nE = 1//2 * relu(pos ⋅ planes[bi][1:3] - planes[bi][4])^2\nFor example, a mech bounding plane [1,0,0,3] would try and make x &lt; 3 nm with a spring constant of 1 pN/nm.\n2.0*[1,0,0,3] would try and make x &lt; 3 nm with a spring constant of 4 pN/nm.\ncapsules::Vector{StaticArraysCore.SVector{8, Float64}}: Capsules that make up the mechanical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). If the radius is negative, the domain is the outside of the capsule, if the radius is positive the domain is inside the capsule. capsules[bi][8] is the spring constant (pN/nm).\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\nE = 1//2*k*relu(sign(r0)*d - r0)^2 where:\n\nd is the distance of the point to the spine line segment described by capsules[bi][1:6].\nr0 is capsules[bi][7]\nk is capsules[bi][8]"
  },
  {
    "objectID": "docstrings/src/boundary.html#medyan.boundary_plane-2caa9b52b3b3f0cc",
    "href": "docstrings/src/boundary.html#medyan.boundary_plane-2caa9b52b3b3f0cc",
    "title": "src/boundary.jl",
    "section": "",
    "text": "boundary_plane(\n;\n    normal,\n    point,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a plane boundary.\nnormal(unit vector): Vector pointing normal to the plane. This points outside of the boundary.\npoint(nm): Point on the plane.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/src/boundary.html#medyan.boundary_box-060d4c56df40146a",
    "href": "docstrings/src/boundary.html#medyan.boundary_box-060d4c56df40146a",
    "title": "src/boundary.jl",
    "section": "",
    "text": "boundary_box(\n    grid::MEDYAN.CubicGrid;\n    offset,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a box boundary at the edge of a grid.\noffset(nm): How far the bounding planes should be moved in from the edge of the grid. Positive is inside the grid, negative is outside the grid.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/src/boundary.html#medyan.boundary_capsule-1700142f310bd9db",
    "href": "docstrings/src/boundary.html#medyan.boundary_capsule-1700142f310bd9db",
    "title": "src/boundary.jl",
    "section": "",
    "text": "boundary_capsule(\n;\n    center,\n    axis,\n    radius,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a capsule boundary.\ncenter(nm): The center of the capsule.\naxis(nm): The direction and length of the capsule spine. The spine line segment goes from center - axis/2 to center + axis/2 If zero the capsule is a sphere.\nradius(nm): Radius of capsule, the full length of the capsule is norm(axis) + 2*abs(radius). If negative, the domain is the outside of the capsule, if positive the domain is the inside of the capsule.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/src/boundary.html#medyan.boundary_cylinder-33a45da15f9672d3",
    "href": "docstrings/src/boundary.html#medyan.boundary_cylinder-33a45da15f9672d3",
    "title": "src/boundary.jl",
    "section": "",
    "text": "boundary_cylinder(\n;\n    center,\n    axis,\n    radius,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a cylinder boundary.\ncenter(nm): The center of the cylinder.\naxis(nm): The direction and length of the cylinder. The spine line segment goes from center - axis/2 to center + axis/2 the full length of the cylinder is norm(axis).\nradius(nm): Radius of cylinder.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/src/util/math/cuboidslicing.html",
    "href": "docstrings/src/util/math/cuboidslicing.html",
    "title": "src/util/math/cuboidslicing.jl",
    "section": "",
    "text": "scale the volume and area\n\n\n\n\n\n\n\n\n\nscale the volume and area by different amounts in each direction"
  },
  {
    "objectID": "docstrings/src/util/math/cuboidslicing.html#base.---a21e771ed8ea7d6f",
    "href": "docstrings/src/util/math/cuboidslicing.html#base.---a21e771ed8ea7d6f",
    "title": "src/util/math/cuboidslicing.jl",
    "section": "",
    "text": "scale the volume and area\n\n\n\n\n\n\n\n\n\nscale the volume and area by different amounts in each direction"
  },
  {
    "objectID": "docstrings/src/filament/make_fila_rand.html",
    "href": "docstrings/src/filament/make_fila_rand.html",
    "title": "src/filament/make_fila_rand.jl",
    "section": "",
    "text": "make_fila_rand!(c::Context, mono_states; iterations = 10^9, type = 1)::Tag{FilaTipIdx}\nAdd a filament to the Context with random center position and direction.\nReturn the tag of the plus tip of the new filament.\nmono_states is a collection of the MonomerState of the monomers in the new filament.\nThe filament will be inside the mech boundary, assuming the boundary is convex.\nErrors if it fails to add a filament.\nThe monomer are spaced by the value in the filament type’s mechanical parameters.\n\n\n\ntype=1: filament type id or symbol.\niterations = 10^9: number of positions to try before failing with an error."
  },
  {
    "objectID": "docstrings/src/filament/make_fila_rand.html#medyan.make_fila_rand--7c63c7a09ece60c8",
    "href": "docstrings/src/filament/make_fila_rand.html#medyan.make_fila_rand--7c63c7a09ece60c8",
    "title": "src/filament/make_fila_rand.jl",
    "section": "",
    "text": "make_fila_rand!(c::Context, mono_states; iterations = 10^9, type = 1)::Tag{FilaTipIdx}\nAdd a filament to the Context with random center position and direction.\nReturn the tag of the plus tip of the new filament.\nmono_states is a collection of the MonomerState of the monomers in the new filament.\nThe filament will be inside the mech boundary, assuming the boundary is convex.\nErrors if it fails to add a filament.\nThe monomer are spaced by the value in the filament type’s mechanical parameters.\n\n\n\ntype=1: filament type id or symbol.\niterations = 10^9: number of positions to try before failing with an error."
  },
  {
    "objectID": "docstrings/src/filament/endsites.html",
    "href": "docstrings/src/filament/endsites.html",
    "title": "src/filament/endsites.jl",
    "section": "",
    "text": "Filament end site that matches with a vector of monomer states.\n\nisminusend::Bool\nendstates::Vector{UInt8}\nspacing::Float64\nadded_monomers::Int64"
  },
  {
    "objectID": "docstrings/src/filament/endsites.html#medyan.filamentendsitegeneral-7a32ac96fb4364ea",
    "href": "docstrings/src/filament/endsites.html#medyan.filamentendsitegeneral-7a32ac96fb4364ea",
    "title": "src/filament/endsites.jl",
    "section": "",
    "text": "Filament end site that matches with a vector of monomer states.\n\nisminusend::Bool\nendstates::Vector{UInt8}\nspacing::Float64\nadded_monomers::Int64"
  },
  {
    "objectID": "docstrings/src/filament/polymerize_fila.html",
    "href": "docstrings/src/filament/polymerize_fila.html",
    "title": "src/filament/polymerize_fila.jl",
    "section": "",
    "text": "polymerize_fila!(c::Context, fila_tip_idx::FilaTipIdx, newstate::Union{Symbol,MonomerState})\nAdd a monomer with state newstate to the end of the filament.\nThis doesn’t affect the other monomer states, positions, or change any of the monomer ids. New monomers are not linkable until after minimization."
  },
  {
    "objectID": "docstrings/src/filament/polymerize_fila.html#medyan.polymerize_fila--ef96193868627e48",
    "href": "docstrings/src/filament/polymerize_fila.html#medyan.polymerize_fila--ef96193868627e48",
    "title": "src/filament/polymerize_fila.jl",
    "section": "",
    "text": "polymerize_fila!(c::Context, fila_tip_idx::FilaTipIdx, newstate::Union{Symbol,MonomerState})\nAdd a monomer with state newstate to the end of the filament.\nThis doesn’t affect the other monomer states, positions, or change any of the monomer ids. New monomers are not linkable until after minimization."
  },
  {
    "objectID": "docstrings/src/filament/update_fila_mono_state.html",
    "href": "docstrings/src/filament/update_fila_mono_state.html",
    "title": "src/filament/update_fila_mono_state.jl",
    "section": "",
    "text": "update_fila_mono_state!(c::Context, p::FilaMonoIdx, state::Union{Symbol,MonomerState})\nUpdate a monomer state."
  },
  {
    "objectID": "docstrings/src/filament/update_fila_mono_state.html#medyan.update_fila_mono_state--02d30b25ab495f22",
    "href": "docstrings/src/filament/update_fila_mono_state.html#medyan.update_fila_mono_state--02d30b25ab495f22",
    "title": "src/filament/update_fila_mono_state.jl",
    "section": "",
    "text": "update_fila_mono_state!(c::Context, p::FilaMonoIdx, state::Union{Symbol,MonomerState})\nUpdate a monomer state."
  },
  {
    "objectID": "docstrings/src/filament/structs.html",
    "href": "docstrings/src/filament/structs.html",
    "title": "src/filament/structs.jl",
    "section": "",
    "text": "Filament mechanical parameters\n\nradius::Float64: Cylinder radius (nm)\nspacing::Float64: Monomer spacing length (nm)\nklength::Float64: Length force constant (pN/nm)\nkangle::Float64: Bending force constant (pN*nm/rad²)\nktwist::Float64: Twisting force constant (pN*nm/rad²)\ntwist_per_monomer::Float64: Twist between monomers (rad)\nnumpercylinder::Int32: Number of monomers per cylinder\nkcollide::Float64: Repulsion stiffness (pN/nm)\nmax_num_unmin_end::Int32: Maximum number of unminimized monomers that can be on an end. This should be less than the minimum radius of other filaments + radius divided by spacing."
  },
  {
    "objectID": "docstrings/src/filament/structs.html#medyan.filamentmechparams-003aa222b98c6481",
    "href": "docstrings/src/filament/structs.html#medyan.filamentmechparams-003aa222b98c6481",
    "title": "src/filament/structs.jl",
    "section": "",
    "text": "Filament mechanical parameters\n\nradius::Float64: Cylinder radius (nm)\nspacing::Float64: Monomer spacing length (nm)\nklength::Float64: Length force constant (pN/nm)\nkangle::Float64: Bending force constant (pN*nm/rad²)\nktwist::Float64: Twisting force constant (pN*nm/rad²)\ntwist_per_monomer::Float64: Twist between monomers (rad)\nnumpercylinder::Int32: Number of monomers per cylinder\nkcollide::Float64: Repulsion stiffness (pN/nm)\nmax_num_unmin_end::Int32: Maximum number of unminimized monomers that can be on an end. This should be less than the minimum radius of other filaments + radius divided by spacing."
  },
  {
    "objectID": "docstrings/src/filament/remove_fila.html",
    "href": "docstrings/src/filament/remove_fila.html",
    "title": "src/filament/remove_fila.jl",
    "section": "",
    "text": "remove_fila!(c::Context, filaidx::Union{FilaIdx, Tag})\nRemove the filament.\nUnlink any monomers or tips on the filament that are referenced by any links. The links will not be removed, but will have a null reference."
  },
  {
    "objectID": "docstrings/src/filament/remove_fila.html#medyan.remove_fila--9938182befad3cb9",
    "href": "docstrings/src/filament/remove_fila.html#medyan.remove_fila--9938182befad3cb9",
    "title": "src/filament/remove_fila.jl",
    "section": "",
    "text": "remove_fila!(c::Context, filaidx::Union{FilaIdx, Tag})\nRemove the filament.\nUnlink any monomers or tips on the filament that are referenced by any links. The links will not be removed, but will have a null reference."
  },
  {
    "objectID": "docstrings/src/grids.html",
    "href": "docstrings/src/grids.html",
    "title": "src/grids.jl",
    "section": "",
    "text": "CubicGrid(num_voxels::SVector{3,Int}, spacing::Float64)\n\nn::StaticArraysCore.SVector{3, Int64}\nspacing::Float64\n\n\n\n\n\n\n\n\n\n\n\n\n\nBase.length(grid::CubicGrid)\nTotal number of voxels in the grid\n\n\n\n\n\n\n\n\n\n\n\n\ngrididat(grid::CubicGrid, location)\nReturn the grid id of location The origin is in the center. Returns a close by voxel if out of the grid\n\n\n\n\n\n\n\n\n\n\n\n\nfilter_grididat(f, grid::CubicGrid, location)\nReturn the nearest grid id of location where f(id) evaluates to true. The origin is in the center. errors if there is no id that evaluates to true. Returns a close by voxel if out of the grid.\n\n\n\n\n\n\n\n\n\n\n\n\ncenterof(grid::CubicGrid, cid)\nReturn the location of the center of a grid id The origin is in the center.\n\n\n\n\n\n\n\n\n\ncenterof(grid::CubicGrid)\nReturn the location of the center the grid The origin is in the center.\n\n\n\n\n\n\n\n\n\n\n\n\nrandompoint(grid::CubicGrid,cid)::SVector{3,Float64}\nReturn a random point in a voxel Note, due to floating point rounding, there is a small chance the returned point may be in a nearby voxel.\n\n\n\n\n\n\n\n\n\nrandompoint(grid::CubicGrid)::SVector{3,Float64}\nReturn a random point in the grid"
  },
  {
    "objectID": "docstrings/src/grids.html#medyan.cubicgrid-fe4b7cc2dceb0431",
    "href": "docstrings/src/grids.html#medyan.cubicgrid-fe4b7cc2dceb0431",
    "title": "src/grids.jl",
    "section": "",
    "text": "CubicGrid(num_voxels::SVector{3,Int}, spacing::Float64)\n\nn::StaticArraysCore.SVector{3, Int64}\nspacing::Float64"
  },
  {
    "objectID": "docstrings/src/grids.html#base.length-7ea31a421de7d258",
    "href": "docstrings/src/grids.html#base.length-7ea31a421de7d258",
    "title": "src/grids.jl",
    "section": "",
    "text": "Base.length(grid::CubicGrid)\nTotal number of voxels in the grid"
  },
  {
    "objectID": "docstrings/src/grids.html#medyan.grididat-8671e01413346deb",
    "href": "docstrings/src/grids.html#medyan.grididat-8671e01413346deb",
    "title": "src/grids.jl",
    "section": "",
    "text": "grididat(grid::CubicGrid, location)\nReturn the grid id of location The origin is in the center. Returns a close by voxel if out of the grid"
  },
  {
    "objectID": "docstrings/src/grids.html#medyan.filter_grididat-58a94154d21e32b0",
    "href": "docstrings/src/grids.html#medyan.filter_grididat-58a94154d21e32b0",
    "title": "src/grids.jl",
    "section": "",
    "text": "filter_grididat(f, grid::CubicGrid, location)\nReturn the nearest grid id of location where f(id) evaluates to true. The origin is in the center. errors if there is no id that evaluates to true. Returns a close by voxel if out of the grid."
  },
  {
    "objectID": "docstrings/src/grids.html#medyan.centerof-e902b9bb7b2a6caf",
    "href": "docstrings/src/grids.html#medyan.centerof-e902b9bb7b2a6caf",
    "title": "src/grids.jl",
    "section": "",
    "text": "centerof(grid::CubicGrid, cid)\nReturn the location of the center of a grid id The origin is in the center.\n\n\n\n\n\n\n\n\n\ncenterof(grid::CubicGrid)\nReturn the location of the center the grid The origin is in the center."
  },
  {
    "objectID": "docstrings/src/grids.html#medyan.randompoint-83e939bdee528294",
    "href": "docstrings/src/grids.html#medyan.randompoint-83e939bdee528294",
    "title": "src/grids.jl",
    "section": "",
    "text": "randompoint(grid::CubicGrid,cid)::SVector{3,Float64}\nReturn a random point in a voxel Note, due to floating point rounding, there is a small chance the returned point may be in a nearby voxel.\n\n\n\n\n\n\n\n\n\nrandompoint(grid::CubicGrid)::SVector{3,Float64}\nReturn a random point in the grid"
  },
  {
    "objectID": "docstrings/src/auxprocs.html",
    "href": "docstrings/src/auxprocs.html",
    "title": "src/auxprocs.jl",
    "section": "",
    "text": "Remesh all membrane meshes.\nAlso remove unreferenced MembVertIdx tags.\n\n\n\n\n\n\n\n\n\n\n\n\nGiven an AABB tree corresponding to up-to-date membrane mesh triangles, resolve all filament-membrane intersections.\nRequires\n\nup-to-date unit normals of all triangles in the meshes.\nup-to-date AABB tree corresponding to all membrane meshes.\n\n\n\n\n\n\n\n\n\n\n\n\n\nUpdates all membrane geometries used across various parts of MEDYAN.\nThe list of all items can be found in the document for MEDYAN.compute_geometry!_system function.\nKeyword parameters:\n\ninclude_ff::Bool: If true, compute_geometry! used in energy computations will be applied as well, requiring vectorization of the membrane. This happens before system geometry computation in case some fields are overriden."
  },
  {
    "objectID": "docstrings/src/auxprocs.html#medyan.adapt_membranes--1d26092defd0f4fa",
    "href": "docstrings/src/auxprocs.html#medyan.adapt_membranes--1d26092defd0f4fa",
    "title": "src/auxprocs.jl",
    "section": "",
    "text": "Remesh all membrane meshes.\nAlso remove unreferenced MembVertIdx tags."
  },
  {
    "objectID": "docstrings/src/auxprocs.html#medyan.resolve_all_filament_mesh_crossing--a8be83a7d2ad65c7",
    "href": "docstrings/src/auxprocs.html#medyan.resolve_all_filament_mesh_crossing--a8be83a7d2ad65c7",
    "title": "src/auxprocs.jl",
    "section": "",
    "text": "Given an AABB tree corresponding to up-to-date membrane mesh triangles, resolve all filament-membrane intersections.\nRequires\n\nup-to-date unit normals of all triangles in the meshes.\nup-to-date AABB tree corresponding to all membrane meshes."
  },
  {
    "objectID": "docstrings/src/auxprocs.html#medyan.compute_all_membrane_geometry-_system-05b4d2a32e31560c",
    "href": "docstrings/src/auxprocs.html#medyan.compute_all_membrane_geometry-_system-05b4d2a32e31560c",
    "title": "src/auxprocs.jl",
    "section": "",
    "text": "Updates all membrane geometries used across various parts of MEDYAN.\nThe list of all items can be found in the document for MEDYAN.compute_geometry!_system function.\nKeyword parameters:\n\ninclude_ff::Bool: If true, compute_geometry! used in energy computations will be applied as well, requiring vectorization of the membrane. This happens before system geometry computation in case some fields are overriden."
  },
  {
    "objectID": "docstrings/src/membrane/make_memb_sphere.html",
    "href": "docstrings/src/membrane/make_memb_sphere.html",
    "title": "src/membrane/make_memb_sphere.jl",
    "section": "",
    "text": "make_memb_sphere!(c::Context; radius, center=SA[0.0,0.0,0.0], subdivisions=2)::MembId\nCreate a new spherical membrane in the simulation context and return its membrane identifier.\nThis function generates an icosphere mesh by subdividing the faces of a regular icosahedron. Each subdivision step splits every triangle into four smaller triangles, resulting in a more refined, nearly uniform triangulation of the sphere. The mesh is then scaled by radius, rotated by rotation, and translated to center.\n\n\n\nradius::Float64: Radius of the sphere (nm)\ncenter::SVector{3,Float64}=SA[0.0,0.0,0.0]: Center of the sphere (nm)\nsubdivisions::Int=3: Number of subdivisions (1 = icosahedron, each increment quadruples the number of triangles)\nrotation=I: 3x3 matrix to rotate the sphere around its center\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior.\n\n\n\n\n\nMesh construction method: https://web.archive.org/web/20200210070737/http://blog.andreaskahler.com/2009/06/creating-icosphere-mesh-in-code.html"
  },
  {
    "objectID": "docstrings/src/membrane/make_memb_sphere.html#medyan.make_memb_sphere--5ed5984bc3221359",
    "href": "docstrings/src/membrane/make_memb_sphere.html#medyan.make_memb_sphere--5ed5984bc3221359",
    "title": "src/membrane/make_memb_sphere.jl",
    "section": "",
    "text": "make_memb_sphere!(c::Context; radius, center=SA[0.0,0.0,0.0], subdivisions=2)::MembId\nCreate a new spherical membrane in the simulation context and return its membrane identifier.\nThis function generates an icosphere mesh by subdividing the faces of a regular icosahedron. Each subdivision step splits every triangle into four smaller triangles, resulting in a more refined, nearly uniform triangulation of the sphere. The mesh is then scaled by radius, rotated by rotation, and translated to center.\n\n\n\nradius::Float64: Radius of the sphere (nm)\ncenter::SVector{3,Float64}=SA[0.0,0.0,0.0]: Center of the sphere (nm)\nsubdivisions::Int=3: Number of subdivisions (1 = icosahedron, each increment quadruples the number of triangles)\nrotation=I: 3x3 matrix to rotate the sphere around its center\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior.\n\n\n\n\n\nMesh construction method: https://web.archive.org/web/20200210070737/http://blog.andreaskahler.com/2009/06/creating-icosphere-mesh-in-code.html"
  },
  {
    "objectID": "docstrings/src/membrane/make_memb_rectangle.html",
    "href": "docstrings/src/membrane/make_memb_rectangle.html",
    "title": "src/membrane/make_memb_rectangle.jl",
    "section": "",
    "text": "make_memb_rectangle!(c::Context; width, height=width, center=SA[0.0,0.0,0.0])::MembId\nCreate a new rectangular membrane in the simulation context and return its membrane identifier.\nThe membrane is by default in the X-Y plane, and the outside of the membrane is on the +Z side.\nThe mesh is then scaled by width in the X direction, height in the Y direction, rotated by rotation, and translated to center.\n\n\n\nwidth::Float64: The length of the membrane in the X direction (nm)\nheight::Float64=width: The length of the membrane in the Y direction (nm)\ncenter::SVector{3,Float64}=SA[0.0,0.0,0.0]: Center of the sphere (nm)\nrotation=I: 3x3 matrix to rotate the sphere around its center\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior."
  },
  {
    "objectID": "docstrings/src/membrane/make_memb_rectangle.html#medyan.make_memb_rectangle--68b3d30b96f64135",
    "href": "docstrings/src/membrane/make_memb_rectangle.html#medyan.make_memb_rectangle--68b3d30b96f64135",
    "title": "src/membrane/make_memb_rectangle.jl",
    "section": "",
    "text": "make_memb_rectangle!(c::Context; width, height=width, center=SA[0.0,0.0,0.0])::MembId\nCreate a new rectangular membrane in the simulation context and return its membrane identifier.\nThe membrane is by default in the X-Y plane, and the outside of the membrane is on the +Z side.\nThe mesh is then scaled by width in the X direction, height in the Y direction, rotated by rotation, and translated to center.\n\n\n\nwidth::Float64: The length of the membrane in the X direction (nm)\nheight::Float64=width: The length of the membrane in the Y direction (nm)\ncenter::SVector{3,Float64}=SA[0.0,0.0,0.0]: Center of the sphere (nm)\nrotation=I: 3x3 matrix to rotate the sphere around its center\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior."
  },
  {
    "objectID": "docstrings/src/context.html",
    "href": "docstrings/src/context.html",
    "title": "src/context.jl",
    "section": "",
    "text": "Membrane protein physical parameters.\n\ndiffusion_coeff::Float64: Membrane diffusion coefficients (nm^2/s).\narea::Float64: Protein area projected onto the surface (nm^2).\nkbend::Float64: Bending rigidity (pN nm).\neqcurv::Float64: The protein’s own spontaneous mean curvature (/nm). Can be used in bending energy computations with curvatures.\n\n\n\n\n\n\n\n\n\n\n\n\n\nContext(sys_def::SysDef, grid::CubicGrid; kwargs...)\n\nagent_names::MEDYAN.AgentNames\nsys_def::MEDYAN.SysDef\ncompartments::Vector{MEDYAN.Compartment}\ngrid::MEDYAN.CubicGrid\ntime::Float64: time (s)\nstats::MEDYAN.PerformanceStats\nβ::Float64: inverse kT (1/(nm*pN))\nbase_diffusion_coeffs::Vector{Float64}: Diffusion coefficients indexed by diffusing species id (nm²/s)\nmembrane_species_params::StaticArraysCore.SVector{NUM_MEMBRANEDIFFUSINGSPECIES, MEDYAN.MembraneSpeciesParams} where NUM_MEMBRANEDIFFUSINGSPECIES: Membrane species parameters indexed by membrane diffusing species id.\nmin_chem_voxel_volume_ratio::Float64: Smallest volume a chem voxel can have before being deactivated as a ratio to a full chem voxel volume.\nchemistryengine::MEDYAN.RDMESampler: The reaction diffusion master equation sampler, contains the diffusing and regular fixed species state\nchem_voxel_volumes::Array{Float64, 3}: Volume of each chemical voxel\nchem_voxel_areas::Array{Float64, 4}: Areas of (-x, -y, -z) faces of each chemical voxel\nchem_cylinders::Vector{MEDYAN.ChemCylinders}: Data about filament cylinders, indexed by filament type id\nballs::StructArrays.StructVector{MEDYAN.Ball, @NamedTuple{position::Vector{StaticArraysCore.SVector{3, Float64}}, radius::Vector{Float32}, stiffness::Vector{Float32}, state::Vector{StaticArraysCore.SVector{3, Int64}}, is_minimized::Vector{Bool}}, Int64}\nmembranes::Vector: All membrane meshes.\nnext_membid::Ref{MEDYAN.MembId}: Next memb id\nmembid2membidx::Dict{MEDYAN.MembId, UInt32}: map from memb id to index memb indexes can change whenever a memb is removed, but id’s are stable\nmembidx2membid::Vector{MEDYAN.MembId}: map from memb index to id\nlink_manager::MEDYAN.LinkManager\ndecimated_2mon_site_managers::Vector{MEDYAN.AbstractDecimated2MonSiteManager}: Site managers, indexed by site id\nfilamentsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filament site definitions, indexed by filament type id, filament site id to get a SiteData with fields of id, site, fxsid\nfilamentendsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filamentend site definitions, indexed by filament type id, filamentend site id to get a SiteData with fields of id, site, fxsid\nmaxfilsite_plusrange::Vector{Int64}: The maximum plus range in monomers that any filament site or end site can see. Indexed by filament type id\nmaxfilsite_minusrange::Vector{Int64}: The maximum minus range in monomers that any filament site or end site can see. Indexed by filament type id\nmembranesites::Tuple{Vararg{MEDYAN.SiteData}}: Maps membrane site id to a SiteData with fields of id, site, fxsid.\nmap_membranediffusingspeciesindex_membranesiteindices::Tuple{Vararg{Vector{Int64}}}: Maps membrane diffusing species index to a list of membrane sites using this species as reactant. This is initialized during context init and should not be changed.\ndecimated_2mon_sites::Vector{MEDYAN.SiteData}: Site definitions, indexed by site id to get a SiteData with fields of id, site, fxsid\npossiblecadherinsite_managers::Tuple{Vararg{MEDYAN.AbstractPossibleCadherinSiteManager}}: Site managers, indexed by site id\ncheck_sitecount_error::Bool: If true site counts are checked for errors on every chem update. This is extremely slow, but useful for testing chem update errors.\ncompartmentreactioncallbacks::Any\nbulkreactioncallbacks::Any\nmemdiff_bulks_index::Int64: Mock bulk species index for membrane diffusion.\nviscosity::Float64: viscosity (pNs/nm² or MPas) water is about 1E-9\ng_tol::Float64: maximum force magnitude after minimization (pN)\nnforce_fractbit::Int64: number of fractional bits used to scale force values into Int64\nnenergy_fractbit::Int64: number of fractional bits used to scale energy values into Int64\nshake_before_minimization::Float64: Standard deviation of noise added to coordinates before starting minimization.\niter_max_cg_minimization::Int64: Max number of steps in conjugate gradient minimization.\nmaxstep::Float64: max step to take during line search (nm)\ncheck_neighborlist_error::Bool: If true neighborlists are checked for errors on every force calc. This is extremely slow, but useful for testing neighborlist errors.\nnthreads::Int64: Experimental Set to more than 1 to enable multi threading. This is currently may result in non bitwise reproducable simulations. Results should be statistcally identical, but this is currently not well tested.\nenable_collision::Ref{Bool}: Are collision forces calculated\ncollision_skin::Float64: Extra collision neighbor list cutoff radius in nm. The neighbor lists are reset after something moves over this amount\ncollision_switchover_scale_unitless::Float32: Smoothing scale to avoid sharp forces when two cylinders are collinear\nfilamentmechparams::Vector{MEDYAN.FilamentMechParams}: The filament mechanical parameters, indexed by filament type id\nfunc_membranespeciespotentialenergy::Any: Membrane species potential energy function. See docs on default function for more info.\nexternal_energy_forces!::Any: External energy/force expressions. This should be a mutating function taking a (fc::MEDYAN.ForceContext, vectorized_x), which adds to fc.forces, fc.energies, and fc.energy. The energy and force must be consistent, and this is not checked. This can be used as ad-hoc solutions to experiment with uncommon forces, such as specifically designed attachments, etc. If this variable is used often, consider moving it into MEDYAN.\nchemboundary::MEDYAN.Boundary: chemical boundary, updates compartment volumes and diffusion rates\nchem_boundary_oversampling_factor::Int64: Oversampling factor for chem boundary TSDF computation. Default is 4.\nchem_boundary_tsdf_max_distance::Float64: Maximum distance for TSDF truncation (nm). Actual max is max(this, 2.5*grid_spacing). Default is 312.5 nm.\nchem_boundary_tsdf_cache::Union{Nothing, Array{Float64, 3}}: Cached truncated signed distance field for chem boundary. nothing means cache is invalid.\nmechboundary::MEDYAN.Boundary: mechanical boundary\nsharedtypedconfigs::MEDYAN.SharedTypedConfigs: Shared configurations stored in type parameters.\nvalidflags::MEDYAN.ValidFlags: Interval system consistency validation flags.\nprofiler::ZoneProfilers.Profiler\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_time!(c::MEDYAN.Context, x::Float64) -&gt; Float64\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\nget_time(c::MEDYAN.Context) -&gt; Float64\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\nset_enable_collision!(c::MEDYAN.Context, x::Bool) -&gt; Bool\nAre repulsive forces calculated.\n\n\n\n\n\n\n\n\n\n\n\n\nset_chem_boundary!(\n    c::MEDYAN.Context,\n    boundary::MEDYAN.Boundary\n)\nSet chemical boundary Note, the chem boundary should be outside the mech boundary so that it is rare for filaments to go outside the chem boundary.\nMake sure to call apply_chem_boundary! to update the chem voxels.\nSee also Boundary\n\n\n\n\n\n\n\n\n\n\n\n\nis_chem_boundary_tsdf_cache_valid(c::MEDYAN.Context) -&gt; Bool\nReturn true if the chem boundary TSDF cache is valid.\n\n\n\n\n\n\n\n\n\n\n\n\nget_chem_boundary_oversampling_factor(\n    c::MEDYAN.Context\n) -&gt; Int64\nGet the oversampling factor used for chem boundary TSDF computation.\n\n\n\n\n\n\n\n\n\n\n\n\nget_chem_boundary_grid_spacing(c::MEDYAN.Context) -&gt; Float64\nGet the grid spacing used for chem boundary TSDF computation.\n\n\n\n\n\n\n\n\n\n\n\n\nset_chem_boundary_oversampling_factor!(\n    c::MEDYAN.Context,\n    factor::Int64\n)\nSet the oversampling factor for chem boundary TSDF computation. This will invalidate the TSDF cache.\n\n\n\n\n\n\n\n\n\n\n\n\nget_chem_boundary_tsdf_max_distance(\n    c::MEDYAN.Context\n) -&gt; Float64\nGet the user-specified maximum distance for TSDF truncation (nm). The actual max distance used is max(this, 2.5*grid_spacing).\n\n\n\n\n\n\n\n\n\n\n\n\nset_chem_boundary_tsdf_max_distance!(\n    c::MEDYAN.Context,\n    max_distance::Float64\n)\nSet the maximum distance for TSDF truncation (nm). The actual max distance used is max(this, 2.5*grid_spacing). This will invalidate the TSDF cache.\n\n\n\n\n\n\n\n\n\n\n\n\nget_chem_boundary_tsdf_actual_max_distance(\n    c::MEDYAN.Context\n) -&gt; Float64\nGet the actual maximum distance used for TSDF truncation (nm). This is max(userspecifiedmaxdistance, 2.5grid*spacing).\n\n\n\n\n\n\n\n\n\n\n\n\nget_chem_boundary_tsdf!(\n    c::MEDYAN.Context\n) -&gt; Array{Float64, 3}\nGet the cached chem boundary TSDF, computing it if necessary. The TSDF is a 3D grid of signed distances where inside the boundary is negative and outside is positive. Values are clamped to ±max(usermaxdistance, 2.5*grid_spacing).\n\n\n\n\n\n\n\n\n\n\n\n\nis_inside_chem_boundary!(\n    c::MEDYAN.Context,\n    position::StaticArraysCore.SVector{3, Float64},\n    min_distance::Float64\n) -&gt; Bool\nConservatively check if a position is inside the chem boundary by at least min_distance nm.\nUses the cached TSDF to provide a conservative (never false-positive) estimate. Returns true only if we can guarantee the point is inside by at least min_distance. Returns false if the point might be outside or within min_distance of the boundary.\nThe algorithm uses the TSDF values at the 8 vertices of the containing voxel. For each vertex with TSDF value t_v (negative = inside), and distance r from the query point to that vertex, the boundary is between t_v + r and t_v - r away from the point.\nIf the point is outside the TSDF grid, returns false (conservative).\nThe TSDF grid spacing defaults to the chem voxel spacing / 4. The oversampling factor can be increased with set_chem_boundary_oversampling_factor!. The TSDF max distance can be increased with set_chem_boundary_tsdf_max_distance!. If min_distance &gt; max_distance - sqrt(3)*grid_spacing an error is thrown.\n\n\n\n\n\n\n\n\n\n\n\n\napply_chem_boundary!(c::Context)::Nothing\nUpdate chem voxel volumes and diffusion rates.\nThe chem boundary is the intersection of any boundary set by set_chem_boundary! and membranes with chem_boundary=true.\nset_chem_boundary_oversampling_factor! can be used to increase the boundary sampling resolution at the expense of increased memory use.\nCalling this will invalidate the chem cache.\n\n\n\n\n\n\n\n\n\n\n\n\nset_mechboundary!(\n    c::MEDYAN.Context;\n    kwargs...\n) -&gt; MEDYAN.Boundary\nSee also Boundary\n\n\n\n\n\n\n\n\n\n\n\n\nchem_adddiffusingcount!(c::Context, sid, cid, inccount)\nAdd inccount to diffusing species id sid in compartment id cid\n\n\n\n\n\n\n\n\n\n\n\n\nadd_diffusing_count!(c::Context; species, chem_voxel, inccount)\nAdd inccount to diffusing species id sid in chem_voxel\n\n\n\n\n\n\n\n\n\n\n\n\nchem_addfixedcount!(c::Context, sid, cid, inccount)\nAdd inccount to fixed species id sid in compartment id cid\n\n\n\n\n\n\n\n\n\n\n\n\nadddiffusingcount_rand!(c::Context, dsid, inccount)\nDistribute the added diffusing species count randomly to compartments weighted by volume.\n\ndsid: diffusing species id.\ninccount: amount to add.\n\n\n\n\n\n\n\n\n\n\n\n\n\naddmembranediffusingcount_rand!(\n    c::MEDYAN.Context,\n    membraneindex::Int64,\n    speciesindex::Int64,\n    addcount::Int64\n)\nDistribute the added membrane species count randomly to membrane cells, ignoring cell area difference. Does NOT update propensity.\n\n\n\n\n\n\n\n\n\n\n\n\nrun_chemistry!(c::Context, Δt)\nRun chemistry for Δt time.\nUpdate c.time.\n\n\n\n\n\n\n\n\n\n\n\n\ndefer_chem_caching!(c::Context)::Nothing\nThis should only be used for advanced optimizations.\nDuring chemistry, the context mutating functions will typically try to avoid invalidating various cached data needed to quickly sample sites.\nHowever, if you want to mutate the context outside of chemistry, for example right before or after minimization, you may not want to pay the cost of revalidating all the caches because minimization will already invalidate the caches. Caching will be enabled again and caches will be made valid the next time chemistry is run. Caching can also be manually refreshed and reenabled with: refresh_chem_cache!\n\n\n\n\n\n\n\n\n\n\n\n\nrefresh_chem_cache!(c::Context)::Nothing\nNormally this isn’t needed as it will happen automatically.\n\n\n\n\n\n\n\n\n\n\n\n\nis_chem_cache_valid(c::Context)::Bool\nReturn true if the chemistry cache is valid, false otherwise.\n\n\n\n\n\n\n\n\n\n\n\n\nempty!(c::Context)\nRemove all filaments, membranes, links, diffusing species, fixed species, bulk species, chemboundary, and mechboundary."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.membranespeciesparams-548fecb643fc2599",
    "href": "docstrings/src/context.html#medyan.membranespeciesparams-548fecb643fc2599",
    "title": "src/context.jl",
    "section": "",
    "text": "Membrane protein physical parameters.\n\ndiffusion_coeff::Float64: Membrane diffusion coefficients (nm^2/s).\narea::Float64: Protein area projected onto the surface (nm^2).\nkbend::Float64: Bending rigidity (pN nm).\neqcurv::Float64: The protein’s own spontaneous mean curvature (/nm). Can be used in bending energy computations with curvatures."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.context-736368ed32b08894",
    "href": "docstrings/src/context.html#medyan.context-736368ed32b08894",
    "title": "src/context.jl",
    "section": "",
    "text": "Context(sys_def::SysDef, grid::CubicGrid; kwargs...)\n\nagent_names::MEDYAN.AgentNames\nsys_def::MEDYAN.SysDef\ncompartments::Vector{MEDYAN.Compartment}\ngrid::MEDYAN.CubicGrid\ntime::Float64: time (s)\nstats::MEDYAN.PerformanceStats\nβ::Float64: inverse kT (1/(nm*pN))\nbase_diffusion_coeffs::Vector{Float64}: Diffusion coefficients indexed by diffusing species id (nm²/s)\nmembrane_species_params::StaticArraysCore.SVector{NUM_MEMBRANEDIFFUSINGSPECIES, MEDYAN.MembraneSpeciesParams} where NUM_MEMBRANEDIFFUSINGSPECIES: Membrane species parameters indexed by membrane diffusing species id.\nmin_chem_voxel_volume_ratio::Float64: Smallest volume a chem voxel can have before being deactivated as a ratio to a full chem voxel volume.\nchemistryengine::MEDYAN.RDMESampler: The reaction diffusion master equation sampler, contains the diffusing and regular fixed species state\nchem_voxel_volumes::Array{Float64, 3}: Volume of each chemical voxel\nchem_voxel_areas::Array{Float64, 4}: Areas of (-x, -y, -z) faces of each chemical voxel\nchem_cylinders::Vector{MEDYAN.ChemCylinders}: Data about filament cylinders, indexed by filament type id\nballs::StructArrays.StructVector{MEDYAN.Ball, @NamedTuple{position::Vector{StaticArraysCore.SVector{3, Float64}}, radius::Vector{Float32}, stiffness::Vector{Float32}, state::Vector{StaticArraysCore.SVector{3, Int64}}, is_minimized::Vector{Bool}}, Int64}\nmembranes::Vector: All membrane meshes.\nnext_membid::Ref{MEDYAN.MembId}: Next memb id\nmembid2membidx::Dict{MEDYAN.MembId, UInt32}: map from memb id to index memb indexes can change whenever a memb is removed, but id’s are stable\nmembidx2membid::Vector{MEDYAN.MembId}: map from memb index to id\nlink_manager::MEDYAN.LinkManager\ndecimated_2mon_site_managers::Vector{MEDYAN.AbstractDecimated2MonSiteManager}: Site managers, indexed by site id\nfilamentsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filament site definitions, indexed by filament type id, filament site id to get a SiteData with fields of id, site, fxsid\nfilamentendsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filamentend site definitions, indexed by filament type id, filamentend site id to get a SiteData with fields of id, site, fxsid\nmaxfilsite_plusrange::Vector{Int64}: The maximum plus range in monomers that any filament site or end site can see. Indexed by filament type id\nmaxfilsite_minusrange::Vector{Int64}: The maximum minus range in monomers that any filament site or end site can see. Indexed by filament type id\nmembranesites::Tuple{Vararg{MEDYAN.SiteData}}: Maps membrane site id to a SiteData with fields of id, site, fxsid.\nmap_membranediffusingspeciesindex_membranesiteindices::Tuple{Vararg{Vector{Int64}}}: Maps membrane diffusing species index to a list of membrane sites using this species as reactant. This is initialized during context init and should not be changed.\ndecimated_2mon_sites::Vector{MEDYAN.SiteData}: Site definitions, indexed by site id to get a SiteData with fields of id, site, fxsid\npossiblecadherinsite_managers::Tuple{Vararg{MEDYAN.AbstractPossibleCadherinSiteManager}}: Site managers, indexed by site id\ncheck_sitecount_error::Bool: If true site counts are checked for errors on every chem update. This is extremely slow, but useful for testing chem update errors.\ncompartmentreactioncallbacks::Any\nbulkreactioncallbacks::Any\nmemdiff_bulks_index::Int64: Mock bulk species index for membrane diffusion.\nviscosity::Float64: viscosity (pNs/nm² or MPas) water is about 1E-9\ng_tol::Float64: maximum force magnitude after minimization (pN)\nnforce_fractbit::Int64: number of fractional bits used to scale force values into Int64\nnenergy_fractbit::Int64: number of fractional bits used to scale energy values into Int64\nshake_before_minimization::Float64: Standard deviation of noise added to coordinates before starting minimization.\niter_max_cg_minimization::Int64: Max number of steps in conjugate gradient minimization.\nmaxstep::Float64: max step to take during line search (nm)\ncheck_neighborlist_error::Bool: If true neighborlists are checked for errors on every force calc. This is extremely slow, but useful for testing neighborlist errors.\nnthreads::Int64: Experimental Set to more than 1 to enable multi threading. This is currently may result in non bitwise reproducable simulations. Results should be statistcally identical, but this is currently not well tested.\nenable_collision::Ref{Bool}: Are collision forces calculated\ncollision_skin::Float64: Extra collision neighbor list cutoff radius in nm. The neighbor lists are reset after something moves over this amount\ncollision_switchover_scale_unitless::Float32: Smoothing scale to avoid sharp forces when two cylinders are collinear\nfilamentmechparams::Vector{MEDYAN.FilamentMechParams}: The filament mechanical parameters, indexed by filament type id\nfunc_membranespeciespotentialenergy::Any: Membrane species potential energy function. See docs on default function for more info.\nexternal_energy_forces!::Any: External energy/force expressions. This should be a mutating function taking a (fc::MEDYAN.ForceContext, vectorized_x), which adds to fc.forces, fc.energies, and fc.energy. The energy and force must be consistent, and this is not checked. This can be used as ad-hoc solutions to experiment with uncommon forces, such as specifically designed attachments, etc. If this variable is used often, consider moving it into MEDYAN.\nchemboundary::MEDYAN.Boundary: chemical boundary, updates compartment volumes and diffusion rates\nchem_boundary_oversampling_factor::Int64: Oversampling factor for chem boundary TSDF computation. Default is 4.\nchem_boundary_tsdf_max_distance::Float64: Maximum distance for TSDF truncation (nm). Actual max is max(this, 2.5*grid_spacing). Default is 312.5 nm.\nchem_boundary_tsdf_cache::Union{Nothing, Array{Float64, 3}}: Cached truncated signed distance field for chem boundary. nothing means cache is invalid.\nmechboundary::MEDYAN.Boundary: mechanical boundary\nsharedtypedconfigs::MEDYAN.SharedTypedConfigs: Shared configurations stored in type parameters.\nvalidflags::MEDYAN.ValidFlags: Interval system consistency validation flags.\nprofiler::ZoneProfilers.Profiler"
  },
  {
    "objectID": "docstrings/src/context.html#medyan.set_time--a6dd8f73f68a3759",
    "href": "docstrings/src/context.html#medyan.set_time--a6dd8f73f68a3759",
    "title": "src/context.jl",
    "section": "",
    "text": "set_time!(c::MEDYAN.Context, x::Float64) -&gt; Float64\nTime (s)"
  },
  {
    "objectID": "docstrings/src/context.html#medyan.get_time-6e9303598ae0437c",
    "href": "docstrings/src/context.html#medyan.get_time-6e9303598ae0437c",
    "title": "src/context.jl",
    "section": "",
    "text": "get_time(c::MEDYAN.Context) -&gt; Float64\nTime (s)"
  },
  {
    "objectID": "docstrings/src/context.html#medyan.set_enable_collision--ff3352f0a3c63ab0",
    "href": "docstrings/src/context.html#medyan.set_enable_collision--ff3352f0a3c63ab0",
    "title": "src/context.jl",
    "section": "",
    "text": "set_enable_collision!(c::MEDYAN.Context, x::Bool) -&gt; Bool\nAre repulsive forces calculated."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.set_chem_boundary--8446b49a230e3146",
    "href": "docstrings/src/context.html#medyan.set_chem_boundary--8446b49a230e3146",
    "title": "src/context.jl",
    "section": "",
    "text": "set_chem_boundary!(\n    c::MEDYAN.Context,\n    boundary::MEDYAN.Boundary\n)\nSet chemical boundary Note, the chem boundary should be outside the mech boundary so that it is rare for filaments to go outside the chem boundary.\nMake sure to call apply_chem_boundary! to update the chem voxels.\nSee also Boundary"
  },
  {
    "objectID": "docstrings/src/context.html#medyan.is_chem_boundary_tsdf_cache_valid-3823b443227db869",
    "href": "docstrings/src/context.html#medyan.is_chem_boundary_tsdf_cache_valid-3823b443227db869",
    "title": "src/context.jl",
    "section": "",
    "text": "is_chem_boundary_tsdf_cache_valid(c::MEDYAN.Context) -&gt; Bool\nReturn true if the chem boundary TSDF cache is valid."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.get_chem_boundary_oversampling_factor-ceb9b2d946f4fb17",
    "href": "docstrings/src/context.html#medyan.get_chem_boundary_oversampling_factor-ceb9b2d946f4fb17",
    "title": "src/context.jl",
    "section": "",
    "text": "get_chem_boundary_oversampling_factor(\n    c::MEDYAN.Context\n) -&gt; Int64\nGet the oversampling factor used for chem boundary TSDF computation."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.get_chem_boundary_grid_spacing-3726877b3aae3a2e",
    "href": "docstrings/src/context.html#medyan.get_chem_boundary_grid_spacing-3726877b3aae3a2e",
    "title": "src/context.jl",
    "section": "",
    "text": "get_chem_boundary_grid_spacing(c::MEDYAN.Context) -&gt; Float64\nGet the grid spacing used for chem boundary TSDF computation."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.set_chem_boundary_oversampling_factor--dd246eef62c89b5f",
    "href": "docstrings/src/context.html#medyan.set_chem_boundary_oversampling_factor--dd246eef62c89b5f",
    "title": "src/context.jl",
    "section": "",
    "text": "set_chem_boundary_oversampling_factor!(\n    c::MEDYAN.Context,\n    factor::Int64\n)\nSet the oversampling factor for chem boundary TSDF computation. This will invalidate the TSDF cache."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.get_chem_boundary_tsdf_max_distance-f1ce8ced1faa2c40",
    "href": "docstrings/src/context.html#medyan.get_chem_boundary_tsdf_max_distance-f1ce8ced1faa2c40",
    "title": "src/context.jl",
    "section": "",
    "text": "get_chem_boundary_tsdf_max_distance(\n    c::MEDYAN.Context\n) -&gt; Float64\nGet the user-specified maximum distance for TSDF truncation (nm). The actual max distance used is max(this, 2.5*grid_spacing)."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.set_chem_boundary_tsdf_max_distance--6d2b2e3f7c85a2e1",
    "href": "docstrings/src/context.html#medyan.set_chem_boundary_tsdf_max_distance--6d2b2e3f7c85a2e1",
    "title": "src/context.jl",
    "section": "",
    "text": "set_chem_boundary_tsdf_max_distance!(\n    c::MEDYAN.Context,\n    max_distance::Float64\n)\nSet the maximum distance for TSDF truncation (nm). The actual max distance used is max(this, 2.5*grid_spacing). This will invalidate the TSDF cache."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.get_chem_boundary_tsdf_actual_max_distance-387d81e42009c2e5",
    "href": "docstrings/src/context.html#medyan.get_chem_boundary_tsdf_actual_max_distance-387d81e42009c2e5",
    "title": "src/context.jl",
    "section": "",
    "text": "get_chem_boundary_tsdf_actual_max_distance(\n    c::MEDYAN.Context\n) -&gt; Float64\nGet the actual maximum distance used for TSDF truncation (nm). This is max(userspecifiedmaxdistance, 2.5grid*spacing)."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.get_chem_boundary_tsdf--7c0691ac2b510a3d",
    "href": "docstrings/src/context.html#medyan.get_chem_boundary_tsdf--7c0691ac2b510a3d",
    "title": "src/context.jl",
    "section": "",
    "text": "get_chem_boundary_tsdf!(\n    c::MEDYAN.Context\n) -&gt; Array{Float64, 3}\nGet the cached chem boundary TSDF, computing it if necessary. The TSDF is a 3D grid of signed distances where inside the boundary is negative and outside is positive. Values are clamped to ±max(usermaxdistance, 2.5*grid_spacing)."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.is_inside_chem_boundary--1f7c8bf2ac4afb38",
    "href": "docstrings/src/context.html#medyan.is_inside_chem_boundary--1f7c8bf2ac4afb38",
    "title": "src/context.jl",
    "section": "",
    "text": "is_inside_chem_boundary!(\n    c::MEDYAN.Context,\n    position::StaticArraysCore.SVector{3, Float64},\n    min_distance::Float64\n) -&gt; Bool\nConservatively check if a position is inside the chem boundary by at least min_distance nm.\nUses the cached TSDF to provide a conservative (never false-positive) estimate. Returns true only if we can guarantee the point is inside by at least min_distance. Returns false if the point might be outside or within min_distance of the boundary.\nThe algorithm uses the TSDF values at the 8 vertices of the containing voxel. For each vertex with TSDF value t_v (negative = inside), and distance r from the query point to that vertex, the boundary is between t_v + r and t_v - r away from the point.\nIf the point is outside the TSDF grid, returns false (conservative).\nThe TSDF grid spacing defaults to the chem voxel spacing / 4. The oversampling factor can be increased with set_chem_boundary_oversampling_factor!. The TSDF max distance can be increased with set_chem_boundary_tsdf_max_distance!. If min_distance &gt; max_distance - sqrt(3)*grid_spacing an error is thrown."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.apply_chem_boundary--86fcf1aed37adaf6",
    "href": "docstrings/src/context.html#medyan.apply_chem_boundary--86fcf1aed37adaf6",
    "title": "src/context.jl",
    "section": "",
    "text": "apply_chem_boundary!(c::Context)::Nothing\nUpdate chem voxel volumes and diffusion rates.\nThe chem boundary is the intersection of any boundary set by set_chem_boundary! and membranes with chem_boundary=true.\nset_chem_boundary_oversampling_factor! can be used to increase the boundary sampling resolution at the expense of increased memory use.\nCalling this will invalidate the chem cache."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.set_mechboundary--b5e26b6b690256aa",
    "href": "docstrings/src/context.html#medyan.set_mechboundary--b5e26b6b690256aa",
    "title": "src/context.jl",
    "section": "",
    "text": "set_mechboundary!(\n    c::MEDYAN.Context;\n    kwargs...\n) -&gt; MEDYAN.Boundary\nSee also Boundary"
  },
  {
    "objectID": "docstrings/src/context.html#medyan.chem_adddiffusingcount--2264be341b81a600",
    "href": "docstrings/src/context.html#medyan.chem_adddiffusingcount--2264be341b81a600",
    "title": "src/context.jl",
    "section": "",
    "text": "chem_adddiffusingcount!(c::Context, sid, cid, inccount)\nAdd inccount to diffusing species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/src/context.html#medyan.add_diffusing_count--78fc5fd22c94a7fa",
    "href": "docstrings/src/context.html#medyan.add_diffusing_count--78fc5fd22c94a7fa",
    "title": "src/context.jl",
    "section": "",
    "text": "add_diffusing_count!(c::Context; species, chem_voxel, inccount)\nAdd inccount to diffusing species id sid in chem_voxel"
  },
  {
    "objectID": "docstrings/src/context.html#medyan.chem_addfixedcount--0286edfebf8ea5e6",
    "href": "docstrings/src/context.html#medyan.chem_addfixedcount--0286edfebf8ea5e6",
    "title": "src/context.jl",
    "section": "",
    "text": "chem_addfixedcount!(c::Context, sid, cid, inccount)\nAdd inccount to fixed species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/src/context.html#medyan.adddiffusingcount_rand--9d3ddfabbceeef92",
    "href": "docstrings/src/context.html#medyan.adddiffusingcount_rand--9d3ddfabbceeef92",
    "title": "src/context.jl",
    "section": "",
    "text": "adddiffusingcount_rand!(c::Context, dsid, inccount)\nDistribute the added diffusing species count randomly to compartments weighted by volume.\n\ndsid: diffusing species id.\ninccount: amount to add."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.addmembranediffusingcount_rand--7b719dca63a36b1b",
    "href": "docstrings/src/context.html#medyan.addmembranediffusingcount_rand--7b719dca63a36b1b",
    "title": "src/context.jl",
    "section": "",
    "text": "addmembranediffusingcount_rand!(\n    c::MEDYAN.Context,\n    membraneindex::Int64,\n    speciesindex::Int64,\n    addcount::Int64\n)\nDistribute the added membrane species count randomly to membrane cells, ignoring cell area difference. Does NOT update propensity."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.run_chemistry--dda22fac5c555b9e",
    "href": "docstrings/src/context.html#medyan.run_chemistry--dda22fac5c555b9e",
    "title": "src/context.jl",
    "section": "",
    "text": "run_chemistry!(c::Context, Δt)\nRun chemistry for Δt time.\nUpdate c.time."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.defer_chem_caching--9538a1c449f3da93",
    "href": "docstrings/src/context.html#medyan.defer_chem_caching--9538a1c449f3da93",
    "title": "src/context.jl",
    "section": "",
    "text": "defer_chem_caching!(c::Context)::Nothing\nThis should only be used for advanced optimizations.\nDuring chemistry, the context mutating functions will typically try to avoid invalidating various cached data needed to quickly sample sites.\nHowever, if you want to mutate the context outside of chemistry, for example right before or after minimization, you may not want to pay the cost of revalidating all the caches because minimization will already invalidate the caches. Caching will be enabled again and caches will be made valid the next time chemistry is run. Caching can also be manually refreshed and reenabled with: refresh_chem_cache!"
  },
  {
    "objectID": "docstrings/src/context.html#medyan.refresh_chem_cache--f90ebca1f896ad2c",
    "href": "docstrings/src/context.html#medyan.refresh_chem_cache--f90ebca1f896ad2c",
    "title": "src/context.jl",
    "section": "",
    "text": "refresh_chem_cache!(c::Context)::Nothing\nNormally this isn’t needed as it will happen automatically."
  },
  {
    "objectID": "docstrings/src/context.html#medyan.is_chem_cache_valid-8336a8adc58a252f",
    "href": "docstrings/src/context.html#medyan.is_chem_cache_valid-8336a8adc58a252f",
    "title": "src/context.jl",
    "section": "",
    "text": "is_chem_cache_valid(c::Context)::Bool\nReturn true if the chemistry cache is valid, false otherwise."
  },
  {
    "objectID": "docstrings/src/context.html#base.empty--418304748816268d",
    "href": "docstrings/src/context.html#base.empty--418304748816268d",
    "title": "src/context.jl",
    "section": "",
    "text": "empty!(c::Context)\nRemove all filaments, membranes, links, diffusing species, fixed species, bulk species, chemboundary, and mechboundary."
  },
  {
    "objectID": "docstrings/src/links/link-chemistry.html",
    "href": "docstrings/src/links/link-chemistry.html",
    "title": "src/links/link-chemistry.jl",
    "section": "",
    "text": "get_link_mechanics(c::Context, link::Link, [d::LinkData])\nReturn a NamedTuple of (;energy, inputs, forces, torques) of the link. Throw an error if link doesn’t exist. Parts of inputs that do not exist will be set to NaN."
  },
  {
    "objectID": "docstrings/src/links/link-chemistry.html#medyan.get_link_mechanics-57ba2f1a141d0156",
    "href": "docstrings/src/links/link-chemistry.html#medyan.get_link_mechanics-57ba2f1a141d0156",
    "title": "src/links/link-chemistry.jl",
    "section": "",
    "text": "get_link_mechanics(c::Context, link::Link, [d::LinkData])\nReturn a NamedTuple of (;energy, inputs, forces, torques) of the link. Throw an error if link doesn’t exist. Parts of inputs that do not exist will be set to NaN."
  },
  {
    "objectID": "docstrings/src/links/places.html",
    "href": "docstrings/src/links/places.html",
    "title": "src/links/places.jl",
    "section": "",
    "text": "place_exists(c::Context, p::Place)::Bool\nReturn true iff place p exists in context c. Otherwise return false."
  },
  {
    "objectID": "docstrings/src/links/places.html#medyan.place_exists-fcab2f7674b282f4",
    "href": "docstrings/src/links/places.html#medyan.place_exists-fcab2f7674b282f4",
    "title": "src/links/places.jl",
    "section": "",
    "text": "place_exists(c::Context, p::Place)::Bool\nReturn true iff place p exists in context c. Otherwise return false."
  },
  {
    "objectID": "docstrings/src/links/place-types.html",
    "href": "docstrings/src/links/place-types.html",
    "title": "src/links/place-types.jl",
    "section": "",
    "text": "FilaIdx\nAn index identifying a specific filament in the simulation. This is a lightweight reference that becomes invalid after filament mutations (removal or reordering).\nUnlike the Place subtypes, FilaIdx is not taggable — filaments do not have a stable identity because of operations like severing. To maintain a long-term reference to a filament, store a Tag{FilaTipIdx} or Tag{FilaMonoIdx} instead, and resolve back to a FilaIdx when needed.\n\n\n\nFilaIdx(typeid::Integer, idx::Integer): Direct constructor with filament type ID and filament index\nFilaIdx(c::Context, f::FilaIdx): Re-resolve a filament index\nFilaIdx(c::Context, ft::FilaTipIdx): Extract the filament index from a filament tip index\nFilaIdx(c::Context, t::Tag): Construct from a context and a filament-related tag (e.g., Tag{FilaTipIdx} or Tag{FilaMonoIdx})\nFilaIdx(c::Context, fm::FilaMonoIdx): Extract the filament index from a filament monomer index\n\n\n\n\n\ntypeid::UInt32: The filament type ID (use fila_typeid(c; type=:actin) to get this)\nidx::UInt32: The index of the filament within its type (1-based)\n\n\n\n\n# Iterate over all filaments of a given type\nftid = fila_typeid(c; type=:actin)\nfor i in 1:num_fila(c; type=:actin)\n    fidx = FilaIdx(ftid, i)\n    states = fila_mono_states(c, fidx)\n    positions = fila_node_positions(c, fidx)\nend\n\n\n\nSee num_fila, fila_typeid, fila_mono_ids, fila_mono_states, fila_node_positions, fila_tip_tags.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFilaTipIdx &lt;: Place\nAn index identifying a specific filament tip (either the minus end or plus end).\nThis index may be invalidated by mutations (e.g., filament removal or severing). Use a Tag{FilaTipIdx} for a long-term reference that remains valid across mutations.\n\n\n\nFilaTipIdx(): Creates a null tip index\nFilaTipIdx(fila_idx::FilaIdx, is_minus_end::Bool): Creates a tip index for the specified filament and end\nFilaTipIdx(c::Context, x, ::typeof(-)): Get the minus-end tip\nFilaTipIdx(c::Context, x, ::typeof(+)): Get the plus-end tip\nFilaTipIdx(c::Context, f::FilaTipIdx): Re-resolve a tip index\nFilaTipIdx(c::Context, t::Tag{FilaTipIdx}): Construct from a tag\nFilaTipIdx(c::Context, x::Union{FilaIdx, FilaMonoIdx, FilaTipIdx, Tag}, is_minus_end::Bool): Construct from various filament references\n\n\n\n\n\nfila_idx::FilaIdx: The filament this tip belongs to\nis_minus_end::Bool: true for minus end, false for plus end\n\n\n\n\nSee fila_tip_tags, make_fila!.\n\n\n\n\n\n\n\n\n\n\n\n\n\nnum_directions(::Union{Place, Type{&lt;:Place}})::Int\nReturn the number of directions associated with a place.\n\n\n\n\n\n\n\n\n\n\n\n\nFilaMonoIdx &lt;: Place\nAn index identifying a specific monomer on a filament. This is used for reactions and links that target individual monomers rather than filament tips.\nThis index may be invalidated by mutations (e.g., filament removal or severing). Use a Tag{FilaMonoIdx} for a long-term reference that remains valid across mutations.\n\n\n\nFilaMonoIdx(): Creates a null monomer index\nFilaMonoIdx(fila_idx::FilaIdx, mid::Integer): Creates a monomer index for the specified filament and monomer ID\nFilaMonoIdx(c::Context, f::FilaIdx, m::Integer): Creates a monomer index from a filament index and monomer ID\nFilaMonoIdx(c::Context, ft::FilaTipIdx, offset::Integer=0): Creates a monomer index relative to a tip position\nFilaMonoIdx(c::Context, fm::FilaMonoIdx, offset::Integer=0): Re-resolve a monomer index with optional offset\nFilaMonoIdx(c::Context, x, y::Union{typeof(+), typeof(-)}, offset::Integer=0): Creates a monomer index from a tip direction\nFilaMonoIdx(c::Context, t::Tag, offset::Integer=0): Creates a monomer index from a tag with optional offset\n\n\n\n\n\nfila_idx::FilaIdx: The filament this monomer belongs to\nmid::Int64: The monomer ID (can be obtained from fila_mono_ids)\n\n\n\n\n# Get a specific monomer on a filament\nfidx = FilaIdx(ftid, 1)\nmono_ids = fila_mono_ids(c, fidx)\nmono_idx = FilaMonoIdx(fidx, first(mono_ids))  # First monomer (minus end)\n\n\n\nSee fila_mono_ids, fila_mono_states\n\n\n\n\n\n\n\n\n\n\n\n\n\nMembVertIdx &lt;: Place\nAn index identifying a specific vertex on a membrane mesh. Membranes are represented as triangular meshes, and vertices can participate in chemical reactions and mechanical links.\nThis index may be invalidated by mesh adaptation or membrane removal. Use a Tag{MembVertIdx} for a long-term reference that remains valid across mutations.\n\n\n\nMembVertIdx(): Creates a null vertex index with both indices set to 0\nMembVertIdx(memb_idx::Integer, vert_idx::Integer): Creates a vertex index for the specified membrane and vertex\nMembVertIdx(c::Context, memb_idx::Integer, vert_idx::Integer): Creates a vertex index for the specified membrane and vertex\n\n\n\n\n\nmemb_idx::UInt32: Index of the membrane in the context\nvert_idx::UInt32: Index of the vertex within the membrane mesh\n\n\n\n\nSee make_memb!, make_memb_sphere!, make_memb_rectangle!.\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnchor &lt;: Place\nA position and directions fixed in the simulation frame. Useful for creating links to a point that doesn’t move with any dynamic elements.\n\n\n\nAnchor(): Creates a null anchor with NaN position, NaN directions, and state 0\nAnchor(pos::SVector{3, Float64}): Creates an anchor at the given position with NaN directions and state 0\nAnchor(pos::SVector{3, Float64}, dirs::SVector{2, SVector{3, Float64}}): Creates an anchor at the given position with specified directions and state 0\nAnchor(pos::SVector{3, Float64}, dirs::SVector{2, SVector{3, Float64}}, state::Int64): Full constructor with position, directions, and state\nAnchor(c::Context, pos, dirs, state): Construct from context with position, directions, and state\nAnchor(c::Context, pos::SVector{3, Float64}): Construct from context at the given position\n\n\n\n\n\npos::SVector{3, Float64}: 3D position coordinates\ndirs::SVector{2, SVector{3, Float64}}: Two direction vectors\nstate::Int64: State identifier for chemical reactions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBallIdx &lt;: Place\nAn index referring to a ball (spherical particle) in the simulation. Balls are stored in the balls vector of the Context and represent spherical objects with position, radius, and stiffness that can participate in mechanical interactions and chemical reactions.\nThis index may be invalidated by ball removal or reordering. Use a Tag{BallIdx} for a long-term reference that remains valid across mutations.\n\n\n\nBallIdx(): Creates a null ball index with idx 0\nBallIdx(idx::Int64): Creates a ball index pointing to the ball at position idx in the context’s balls vector\nBallIdx(c::Context, idx::Integer): Construct from context with index\nBallIdx(c::Context, b::BallIdx): Re-resolve a ball index\nBallIdx(c::Context, t::Tag{BallIdx}): Construct from a tag\n\n\n\n\n\nidx::Int64: Index of the ball in the context’s balls vector\n\n\n\n\nSee make_ball!, remove_ball!, and update_ball! for creating, removing, and modifying balls."
  },
  {
    "objectID": "docstrings/src/links/place-types.html#medyan.filaidx-89c89b8bbef4dbda",
    "href": "docstrings/src/links/place-types.html#medyan.filaidx-89c89b8bbef4dbda",
    "title": "src/links/place-types.jl",
    "section": "",
    "text": "FilaIdx\nAn index identifying a specific filament in the simulation. This is a lightweight reference that becomes invalid after filament mutations (removal or reordering).\nUnlike the Place subtypes, FilaIdx is not taggable — filaments do not have a stable identity because of operations like severing. To maintain a long-term reference to a filament, store a Tag{FilaTipIdx} or Tag{FilaMonoIdx} instead, and resolve back to a FilaIdx when needed.\n\n\n\nFilaIdx(typeid::Integer, idx::Integer): Direct constructor with filament type ID and filament index\nFilaIdx(c::Context, f::FilaIdx): Re-resolve a filament index\nFilaIdx(c::Context, ft::FilaTipIdx): Extract the filament index from a filament tip index\nFilaIdx(c::Context, t::Tag): Construct from a context and a filament-related tag (e.g., Tag{FilaTipIdx} or Tag{FilaMonoIdx})\nFilaIdx(c::Context, fm::FilaMonoIdx): Extract the filament index from a filament monomer index\n\n\n\n\n\ntypeid::UInt32: The filament type ID (use fila_typeid(c; type=:actin) to get this)\nidx::UInt32: The index of the filament within its type (1-based)\n\n\n\n\n# Iterate over all filaments of a given type\nftid = fila_typeid(c; type=:actin)\nfor i in 1:num_fila(c; type=:actin)\n    fidx = FilaIdx(ftid, i)\n    states = fila_mono_states(c, fidx)\n    positions = fila_node_positions(c, fidx)\nend\n\n\n\nSee num_fila, fila_typeid, fila_mono_ids, fila_mono_states, fila_node_positions, fila_tip_tags."
  },
  {
    "objectID": "docstrings/src/links/place-types.html#medyan.filatipidx-460debd2fef11ad4",
    "href": "docstrings/src/links/place-types.html#medyan.filatipidx-460debd2fef11ad4",
    "title": "src/links/place-types.jl",
    "section": "",
    "text": "FilaTipIdx &lt;: Place\nAn index identifying a specific filament tip (either the minus end or plus end).\nThis index may be invalidated by mutations (e.g., filament removal or severing). Use a Tag{FilaTipIdx} for a long-term reference that remains valid across mutations.\n\n\n\nFilaTipIdx(): Creates a null tip index\nFilaTipIdx(fila_idx::FilaIdx, is_minus_end::Bool): Creates a tip index for the specified filament and end\nFilaTipIdx(c::Context, x, ::typeof(-)): Get the minus-end tip\nFilaTipIdx(c::Context, x, ::typeof(+)): Get the plus-end tip\nFilaTipIdx(c::Context, f::FilaTipIdx): Re-resolve a tip index\nFilaTipIdx(c::Context, t::Tag{FilaTipIdx}): Construct from a tag\nFilaTipIdx(c::Context, x::Union{FilaIdx, FilaMonoIdx, FilaTipIdx, Tag}, is_minus_end::Bool): Construct from various filament references\n\n\n\n\n\nfila_idx::FilaIdx: The filament this tip belongs to\nis_minus_end::Bool: true for minus end, false for plus end\n\n\n\n\nSee fila_tip_tags, make_fila!."
  },
  {
    "objectID": "docstrings/src/links/place-types.html#medyan.num_directions-89697a0fca8de12f",
    "href": "docstrings/src/links/place-types.html#medyan.num_directions-89697a0fca8de12f",
    "title": "src/links/place-types.jl",
    "section": "",
    "text": "num_directions(::Union{Place, Type{&lt;:Place}})::Int\nReturn the number of directions associated with a place."
  },
  {
    "objectID": "docstrings/src/links/place-types.html#medyan.filamonoidx-94fe5a1112741990",
    "href": "docstrings/src/links/place-types.html#medyan.filamonoidx-94fe5a1112741990",
    "title": "src/links/place-types.jl",
    "section": "",
    "text": "FilaMonoIdx &lt;: Place\nAn index identifying a specific monomer on a filament. This is used for reactions and links that target individual monomers rather than filament tips.\nThis index may be invalidated by mutations (e.g., filament removal or severing). Use a Tag{FilaMonoIdx} for a long-term reference that remains valid across mutations.\n\n\n\nFilaMonoIdx(): Creates a null monomer index\nFilaMonoIdx(fila_idx::FilaIdx, mid::Integer): Creates a monomer index for the specified filament and monomer ID\nFilaMonoIdx(c::Context, f::FilaIdx, m::Integer): Creates a monomer index from a filament index and monomer ID\nFilaMonoIdx(c::Context, ft::FilaTipIdx, offset::Integer=0): Creates a monomer index relative to a tip position\nFilaMonoIdx(c::Context, fm::FilaMonoIdx, offset::Integer=0): Re-resolve a monomer index with optional offset\nFilaMonoIdx(c::Context, x, y::Union{typeof(+), typeof(-)}, offset::Integer=0): Creates a monomer index from a tip direction\nFilaMonoIdx(c::Context, t::Tag, offset::Integer=0): Creates a monomer index from a tag with optional offset\n\n\n\n\n\nfila_idx::FilaIdx: The filament this monomer belongs to\nmid::Int64: The monomer ID (can be obtained from fila_mono_ids)\n\n\n\n\n# Get a specific monomer on a filament\nfidx = FilaIdx(ftid, 1)\nmono_ids = fila_mono_ids(c, fidx)\nmono_idx = FilaMonoIdx(fidx, first(mono_ids))  # First monomer (minus end)\n\n\n\nSee fila_mono_ids, fila_mono_states"
  },
  {
    "objectID": "docstrings/src/links/place-types.html#medyan.membvertidx-4b26f8c9d72f1f49",
    "href": "docstrings/src/links/place-types.html#medyan.membvertidx-4b26f8c9d72f1f49",
    "title": "src/links/place-types.jl",
    "section": "",
    "text": "MembVertIdx &lt;: Place\nAn index identifying a specific vertex on a membrane mesh. Membranes are represented as triangular meshes, and vertices can participate in chemical reactions and mechanical links.\nThis index may be invalidated by mesh adaptation or membrane removal. Use a Tag{MembVertIdx} for a long-term reference that remains valid across mutations.\n\n\n\nMembVertIdx(): Creates a null vertex index with both indices set to 0\nMembVertIdx(memb_idx::Integer, vert_idx::Integer): Creates a vertex index for the specified membrane and vertex\nMembVertIdx(c::Context, memb_idx::Integer, vert_idx::Integer): Creates a vertex index for the specified membrane and vertex\n\n\n\n\n\nmemb_idx::UInt32: Index of the membrane in the context\nvert_idx::UInt32: Index of the vertex within the membrane mesh\n\n\n\n\nSee make_memb!, make_memb_sphere!, make_memb_rectangle!."
  },
  {
    "objectID": "docstrings/src/links/place-types.html#medyan.anchor-0dc7f056c6ce8b51",
    "href": "docstrings/src/links/place-types.html#medyan.anchor-0dc7f056c6ce8b51",
    "title": "src/links/place-types.jl",
    "section": "",
    "text": "Anchor &lt;: Place\nA position and directions fixed in the simulation frame. Useful for creating links to a point that doesn’t move with any dynamic elements.\n\n\n\nAnchor(): Creates a null anchor with NaN position, NaN directions, and state 0\nAnchor(pos::SVector{3, Float64}): Creates an anchor at the given position with NaN directions and state 0\nAnchor(pos::SVector{3, Float64}, dirs::SVector{2, SVector{3, Float64}}): Creates an anchor at the given position with specified directions and state 0\nAnchor(pos::SVector{3, Float64}, dirs::SVector{2, SVector{3, Float64}}, state::Int64): Full constructor with position, directions, and state\nAnchor(c::Context, pos, dirs, state): Construct from context with position, directions, and state\nAnchor(c::Context, pos::SVector{3, Float64}): Construct from context at the given position\n\n\n\n\n\npos::SVector{3, Float64}: 3D position coordinates\ndirs::SVector{2, SVector{3, Float64}}: Two direction vectors\nstate::Int64: State identifier for chemical reactions"
  },
  {
    "objectID": "docstrings/src/links/place-types.html#medyan.ballidx-5a4aba766d557d6a",
    "href": "docstrings/src/links/place-types.html#medyan.ballidx-5a4aba766d557d6a",
    "title": "src/links/place-types.jl",
    "section": "",
    "text": "BallIdx &lt;: Place\nAn index referring to a ball (spherical particle) in the simulation. Balls are stored in the balls vector of the Context and represent spherical objects with position, radius, and stiffness that can participate in mechanical interactions and chemical reactions.\nThis index may be invalidated by ball removal or reordering. Use a Tag{BallIdx} for a long-term reference that remains valid across mutations.\n\n\n\nBallIdx(): Creates a null ball index with idx 0\nBallIdx(idx::Int64): Creates a ball index pointing to the ball at position idx in the context’s balls vector\nBallIdx(c::Context, idx::Integer): Construct from context with index\nBallIdx(c::Context, b::BallIdx): Re-resolve a ball index\nBallIdx(c::Context, t::Tag{BallIdx}): Construct from a tag\n\n\n\n\n\nidx::Int64: Index of the ball in the context’s balls vector\n\n\n\n\nSee make_ball!, remove_ball!, and update_ball! for creating, removing, and modifying balls."
  },
  {
    "objectID": "docstrings/medyan.get_time-6e9303598ae0437c.html",
    "href": "docstrings/medyan.get_time-6e9303598ae0437c.html",
    "title": "MEDYAN.get_time",
    "section": "",
    "text": "get_time(c::MEDYAN.Context) -&gt; Float64\nTime (s)"
  },
  {
    "objectID": "docstrings/medyan.get_time-6e9303598ae0437c.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.get_time-6e9303598ae0437c.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.get_time",
    "section": "",
    "text": "get_time(c::MEDYAN.Context) -&gt; Float64\nTime (s)"
  },
  {
    "objectID": "docstrings/medyan.fila_node_positions-f4c5bac0dcb570ff.html",
    "href": "docstrings/medyan.fila_node_positions-f4c5bac0dcb570ff.html",
    "title": "MEDYAN.fila_node_positions",
    "section": "",
    "text": "fila_node_positions(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{StaticArraysCore.SVector{3, Float64}}\nReturn the mechanical node positions of the filament."
  },
  {
    "objectID": "docstrings/medyan.fila_node_positions-f4c5bac0dcb570ff.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "href": "docstrings/medyan.fila_node_positions-f4c5bac0dcb570ff.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "title": "MEDYAN.fila_node_positions",
    "section": "",
    "text": "fila_node_positions(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{StaticArraysCore.SVector{3, Float64}}\nReturn the mechanical node positions of the filament."
  },
  {
    "objectID": "docstrings/medyan.add_decimated_2mon_site--ad56e7ee56067940.html",
    "href": "docstrings/medyan.add_decimated_2mon_site--ad56e7ee56067940.html",
    "title": "MEDYAN.add_decimated_2mon_site!",
    "section": "",
    "text": "add_decimated_2mon_site!(s::SysDef,decimated_2mon_sitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.add_decimated_2mon_site--ad56e7ee56067940.html#tuple-medyan.sysdef--symbol--any--444c61f2a1ac78e1",
    "href": "docstrings/medyan.add_decimated_2mon_site--ad56e7ee56067940.html#tuple-medyan.sysdef--symbol--any--444c61f2a1ac78e1",
    "title": "MEDYAN.add_decimated_2mon_site!",
    "section": "",
    "text": "add_decimated_2mon_site!(s::SysDef,decimated_2mon_sitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.filamentmechparams-003aa222b98c6481.html",
    "href": "docstrings/medyan.filamentmechparams-003aa222b98c6481.html",
    "title": "MEDYAN.FilamentMechParams",
    "section": "",
    "text": "Filament mechanical parameters\n\nradius::Float64: Cylinder radius (nm)\nspacing::Float64: Monomer spacing length (nm)\nklength::Float64: Length force constant (pN/nm)\nkangle::Float64: Bending force constant (pN*nm/rad²)\nktwist::Float64: Twisting force constant (pN*nm/rad²)\ntwist_per_monomer::Float64: Twist between monomers (rad)\nnumpercylinder::Int32: Number of monomers per cylinder\nkcollide::Float64: Repulsion stiffness (pN/nm)\nmax_num_unmin_end::Int32: Maximum number of unminimized monomers that can be on an end. This should be less than the minimum radius of other filaments + radius divided by spacing."
  },
  {
    "objectID": "docstrings/medyan.filamentmechparams-003aa222b98c6481.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.filamentmechparams-003aa222b98c6481.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.FilamentMechParams",
    "section": "",
    "text": "Filament mechanical parameters\n\nradius::Float64: Cylinder radius (nm)\nspacing::Float64: Monomer spacing length (nm)\nklength::Float64: Length force constant (pN/nm)\nkangle::Float64: Bending force constant (pN*nm/rad²)\nktwist::Float64: Twisting force constant (pN*nm/rad²)\ntwist_per_monomer::Float64: Twist between monomers (rad)\nnumpercylinder::Int32: Number of monomers per cylinder\nkcollide::Float64: Repulsion stiffness (pN/nm)\nmax_num_unmin_end::Int32: Maximum number of unminimized monomers that can be on an end. This should be less than the minimum radius of other filaments + radius divided by spacing."
  },
  {
    "objectID": "docstrings/medyan.update_anchor--d2dbcaf15f4f7c90.html",
    "href": "docstrings/medyan.update_anchor--d2dbcaf15f4f7c90.html",
    "title": "MEDYAN.update_anchor!",
    "section": "",
    "text": "update_anchor!(c::Context, tag::Tag{Anchor}, new_anchor::Anchor)::Nothing\nUpdate an anchor associated with a tag."
  },
  {
    "objectID": "docstrings/medyan.update_anchor--d2dbcaf15f4f7c90.html#tuple-medyan.context--medyan.tag-medyan.anchor---medyan.anchor--0b9803604fcd8370",
    "href": "docstrings/medyan.update_anchor--d2dbcaf15f4f7c90.html#tuple-medyan.context--medyan.tag-medyan.anchor---medyan.anchor--0b9803604fcd8370",
    "title": "MEDYAN.update_anchor!",
    "section": "",
    "text": "update_anchor!(c::Context, tag::Tag{Anchor}, new_anchor::Anchor)::Nothing\nUpdate an anchor associated with a tag."
  },
  {
    "objectID": "docstrings/base.haskey-e7d3f961991e2663.html",
    "href": "docstrings/base.haskey-e7d3f961991e2663.html",
    "title": "Base.haskey",
    "section": "",
    "text": "Whether an ID is in use."
  },
  {
    "objectID": "docstrings/base.haskey-e7d3f961991e2663.html#tuple-medyan.stableindex--integer--14e9a5b3c446a8fc",
    "href": "docstrings/base.haskey-e7d3f961991e2663.html#tuple-medyan.stableindex--integer--14e9a5b3c446a8fc",
    "title": "Base.haskey",
    "section": "",
    "text": "Whether an ID is in use."
  },
  {
    "objectID": "docstrings/medyan.def_fila_tip_reaction--488aa3a14ff39688.html",
    "href": "docstrings/medyan.def_fila_tip_reaction--488aa3a14ff39688.html",
    "title": "MEDYAN.def_fila_tip_reaction!",
    "section": "",
    "text": "def_fila_tip_reaction!(s::SysDef; fila_type, name, is_minus_end, match, spacing, ...)\nAdd a filament tip reaction that fires only at either the plus or minus end of a filament.\nThis mirrors def_fila_reaction! in API style and rate wiring, but the pattern is anchored at a filament end. new may be shorter or longer than match to represent depolymerization or polymerization.\nmatch and new are always ordered from minus end toward plus end. If is_minus_end = true, the pattern is matched against the first length(match) monomers; if is_minus_end = false, it is matched against the last length(match) monomers.\n\n\n\n\n\nfila_type::Symbol: Filament type (e.g., :actin).\nname::Symbol: Unique name for this tip site.\nis_minus_end::Bool: Which filament end to target. true targets the minus end; false targets the plus end.\nmatch::Vector: Pattern of monomer states to match (minus → plus order). Elements can be Symbol, Vector{Symbol} (state set), or anystate.\nspacing::Float64: Space needed at the filament end for this reaction (nm). This affects a load-force rate factor via exp(-β * spacing * loadforce) where β is 1/kT and loadforce is the external force pushing axially on the end of the filament.\n\n\n\n\n\nnew::Vector{Symbol}: New monomer states (minus → plus order) for the tip region. If length(new) &gt; length(match), monomers are added. If length(new) &lt; length(match), monomers are removed. Cannot be used with affect!.\naffect!: Custom callback (c::Context; chem_voxel::Int, tip::FilaTipIdx, kwargs...) -&gt; Int. Called instead of automatic changes. Cannot be used with new.\n\n\n\n\n\nnet_stoich::Vector{Pair{Symbol,Int}} = Pair{Symbol,Int}[]: Net change to diffusing species when the reaction fires. Each entry is species_name =&gt; amount, e.g. [:actin_mon =&gt; -1] to consume one monomer per polymerization. The callback handles the count update automatically. Can only be used with new, not with affect!.\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s.\ninvvolumepower::Int = 0: Set to 0 for unimolecular, 1 for bimolecular.\nreactants_extra::String = \"\": Additional reactant species that contribute to propensity (e.g., \"diffusing.ligand\"). The species is not consumed automatically.\nadded_monomers::Union{Int, Nothing}: The number of monomers added by the reaction. This is automatically determined if new is passed. Each filament has a limited number of monomers that can be added per end\n\nbetween mechanic solves given by FilamentMechParams.max_num_unmin_end. The filament tip reaction is disabled on tips where the added monomers would cause that limit to be exceeded.\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_fila_type!(s; name=:actin, mono_states=[:a, :plusend, :minusend], param=MEDYAN.ACTIN_TWIST_PARAMS)\ndef_diffusing_species!(s, :actin_mon; coeff=2.5e7)\n\n# Plus-end polymerization: add one monomer (bimolecular with diffusing actin)\ndef_fila_tip_reaction!(s;\n    fila_type = :actin,\n    name = :pp,\n    is_minus_end = false,\n    match = [:plusend],\n    spacing = 2.7,\n    new = [:a, :plusend],\n    net_stoich = [:actin_mon =&gt; -1],\n    base_rate = 1.93e7,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.actin_mon\",\n)\n\n# Plus-end polymerization: add one monomer (bimolecular with diffusing actin)\n# Using affect!\ndef_fila_tip_reaction!(s;\n    fila_type = :actin,\n    name = :pp_affect,\n    is_minus_end = false,\n    match = [:a, :plusend],\n    spacing = 2.7,\n    affect! = (c; tip, chem_voxel, kwargs...) -&gt; begin\n        update_fila_mono_state!(c, FilaMonoIdx(c, tip), :a)\n        polymerize_fila!(c, tip, :plusend)\n        add_diffusing_count!(c; species=:actin_mon, chem_voxel, amount=-1)\n        1\n    end,\n    added_monomers = 1,\n    base_rate = 1.93e7,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.actin_mon\",\n)\n\n# Minus-end depolymerization: remove one monomer, release actin back to solution\ndef_fila_tip_reaction!(s;\n    fila_type = :actin, name = :dm,\n    is_minus_end = true,\n    match = [:minusend, :a],\n    spacing = 0.0,\n    new = [:minusend],\n    net_stoich = [:actin_mon =&gt; +1],\n    base_rate = 1.4,\n)"
  },
  {
    "objectID": "docstrings/medyan.def_fila_tip_reaction--488aa3a14ff39688.html#tuple-medyan.sysdef--efaa49a98644904f",
    "href": "docstrings/medyan.def_fila_tip_reaction--488aa3a14ff39688.html#tuple-medyan.sysdef--efaa49a98644904f",
    "title": "MEDYAN.def_fila_tip_reaction!",
    "section": "",
    "text": "def_fila_tip_reaction!(s::SysDef; fila_type, name, is_minus_end, match, spacing, ...)\nAdd a filament tip reaction that fires only at either the plus or minus end of a filament.\nThis mirrors def_fila_reaction! in API style and rate wiring, but the pattern is anchored at a filament end. new may be shorter or longer than match to represent depolymerization or polymerization.\nmatch and new are always ordered from minus end toward plus end. If is_minus_end = true, the pattern is matched against the first length(match) monomers; if is_minus_end = false, it is matched against the last length(match) monomers.\n\n\n\n\n\nfila_type::Symbol: Filament type (e.g., :actin).\nname::Symbol: Unique name for this tip site.\nis_minus_end::Bool: Which filament end to target. true targets the minus end; false targets the plus end.\nmatch::Vector: Pattern of monomer states to match (minus → plus order). Elements can be Symbol, Vector{Symbol} (state set), or anystate.\nspacing::Float64: Space needed at the filament end for this reaction (nm). This affects a load-force rate factor via exp(-β * spacing * loadforce) where β is 1/kT and loadforce is the external force pushing axially on the end of the filament.\n\n\n\n\n\nnew::Vector{Symbol}: New monomer states (minus → plus order) for the tip region. If length(new) &gt; length(match), monomers are added. If length(new) &lt; length(match), monomers are removed. Cannot be used with affect!.\naffect!: Custom callback (c::Context; chem_voxel::Int, tip::FilaTipIdx, kwargs...) -&gt; Int. Called instead of automatic changes. Cannot be used with new.\n\n\n\n\n\nnet_stoich::Vector{Pair{Symbol,Int}} = Pair{Symbol,Int}[]: Net change to diffusing species when the reaction fires. Each entry is species_name =&gt; amount, e.g. [:actin_mon =&gt; -1] to consume one monomer per polymerization. The callback handles the count update automatically. Can only be used with new, not with affect!.\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s.\ninvvolumepower::Int = 0: Set to 0 for unimolecular, 1 for bimolecular.\nreactants_extra::String = \"\": Additional reactant species that contribute to propensity (e.g., \"diffusing.ligand\"). The species is not consumed automatically.\nadded_monomers::Union{Int, Nothing}: The number of monomers added by the reaction. This is automatically determined if new is passed. Each filament has a limited number of monomers that can be added per end\n\nbetween mechanic solves given by FilamentMechParams.max_num_unmin_end. The filament tip reaction is disabled on tips where the added monomers would cause that limit to be exceeded.\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_fila_type!(s; name=:actin, mono_states=[:a, :plusend, :minusend], param=MEDYAN.ACTIN_TWIST_PARAMS)\ndef_diffusing_species!(s, :actin_mon; coeff=2.5e7)\n\n# Plus-end polymerization: add one monomer (bimolecular with diffusing actin)\ndef_fila_tip_reaction!(s;\n    fila_type = :actin,\n    name = :pp,\n    is_minus_end = false,\n    match = [:plusend],\n    spacing = 2.7,\n    new = [:a, :plusend],\n    net_stoich = [:actin_mon =&gt; -1],\n    base_rate = 1.93e7,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.actin_mon\",\n)\n\n# Plus-end polymerization: add one monomer (bimolecular with diffusing actin)\n# Using affect!\ndef_fila_tip_reaction!(s;\n    fila_type = :actin,\n    name = :pp_affect,\n    is_minus_end = false,\n    match = [:a, :plusend],\n    spacing = 2.7,\n    affect! = (c; tip, chem_voxel, kwargs...) -&gt; begin\n        update_fila_mono_state!(c, FilaMonoIdx(c, tip), :a)\n        polymerize_fila!(c, tip, :plusend)\n        add_diffusing_count!(c; species=:actin_mon, chem_voxel, amount=-1)\n        1\n    end,\n    added_monomers = 1,\n    base_rate = 1.93e7,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.actin_mon\",\n)\n\n# Minus-end depolymerization: remove one monomer, release actin back to solution\ndef_fila_tip_reaction!(s;\n    fila_type = :actin, name = :dm,\n    is_minus_end = true,\n    match = [:minusend, :a],\n    spacing = 0.0,\n    new = [:minusend],\n    net_stoich = [:actin_mon =&gt; +1],\n    base_rate = 1.4,\n)"
  },
  {
    "objectID": "docstrings/medyan.cubicgrid-fe4b7cc2dceb0431.html",
    "href": "docstrings/medyan.cubicgrid-fe4b7cc2dceb0431.html",
    "title": "MEDYAN.CubicGrid",
    "section": "",
    "text": "CubicGrid(num_voxels::SVector{3,Int}, spacing::Float64)\n\nn::StaticArraysCore.SVector{3, Int64}\nspacing::Float64"
  },
  {
    "objectID": "docstrings/medyan.cubicgrid-fe4b7cc2dceb0431.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.cubicgrid-fe4b7cc2dceb0431.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.CubicGrid",
    "section": "",
    "text": "CubicGrid(num_voxels::SVector{3,Int}, spacing::Float64)\n\nn::StaticArraysCore.SVector{3, Int64}\nspacing::Float64"
  },
  {
    "objectID": "docstrings/medyan.anchor-0dc7f056c6ce8b51.html",
    "href": "docstrings/medyan.anchor-0dc7f056c6ce8b51.html",
    "title": "MEDYAN.Anchor",
    "section": "",
    "text": "Anchor &lt;: Place\nA position and directions fixed in the simulation frame. Useful for creating links to a point that doesn’t move with any dynamic elements.\n\n\n\nAnchor(): Creates a null anchor with NaN position, NaN directions, and state 0\nAnchor(pos::SVector{3, Float64}): Creates an anchor at the given position with NaN directions and state 0\nAnchor(pos::SVector{3, Float64}, dirs::SVector{2, SVector{3, Float64}}): Creates an anchor at the given position with specified directions and state 0\nAnchor(pos::SVector{3, Float64}, dirs::SVector{2, SVector{3, Float64}}, state::Int64): Full constructor with position, directions, and state\nAnchor(c::Context, pos, dirs, state): Construct from context with position, directions, and state\nAnchor(c::Context, pos::SVector{3, Float64}): Construct from context at the given position\n\n\n\n\n\npos::SVector{3, Float64}: 3D position coordinates\ndirs::SVector{2, SVector{3, Float64}}: Two direction vectors\nstate::Int64: State identifier for chemical reactions"
  },
  {
    "objectID": "docstrings/medyan.anchor-0dc7f056c6ce8b51.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.anchor-0dc7f056c6ce8b51.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.Anchor",
    "section": "",
    "text": "Anchor &lt;: Place\nA position and directions fixed in the simulation frame. Useful for creating links to a point that doesn’t move with any dynamic elements.\n\n\n\nAnchor(): Creates a null anchor with NaN position, NaN directions, and state 0\nAnchor(pos::SVector{3, Float64}): Creates an anchor at the given position with NaN directions and state 0\nAnchor(pos::SVector{3, Float64}, dirs::SVector{2, SVector{3, Float64}}): Creates an anchor at the given position with specified directions and state 0\nAnchor(pos::SVector{3, Float64}, dirs::SVector{2, SVector{3, Float64}}, state::Int64): Full constructor with position, directions, and state\nAnchor(c::Context, pos, dirs, state): Construct from context with position, directions, and state\nAnchor(c::Context, pos::SVector{3, Float64}): Construct from context at the given position\n\n\n\n\n\npos::SVector{3, Float64}: 3D position coordinates\ndirs::SVector{2, SVector{3, Float64}}: Two direction vectors\nstate::Int64: State identifier for chemical reactions"
  },
  {
    "objectID": "docstrings/base.iterate-5228367cd62c0bf2.html",
    "href": "docstrings/base.iterate-5228367cd62c0bf2.html",
    "title": "Base.iterate",
    "section": "",
    "text": "Iterates through valid IDs in the StableIndex."
  },
  {
    "objectID": "docstrings/base.iterate-5228367cd62c0bf2.html#tuple-medyan.stableindex--namedtuple--21f3937ad430e895",
    "href": "docstrings/base.iterate-5228367cd62c0bf2.html#tuple-medyan.stableindex--namedtuple--21f3937ad430e895",
    "title": "Base.iterate",
    "section": "",
    "text": "Iterates through valid IDs in the StableIndex."
  },
  {
    "objectID": "docstrings/medyan.refresh_chem_cache--f90ebca1f896ad2c.html",
    "href": "docstrings/medyan.refresh_chem_cache--f90ebca1f896ad2c.html",
    "title": "MEDYAN.refresh_chem_cache!",
    "section": "",
    "text": "refresh_chem_cache!(c::Context)::Nothing\nNormally this isn’t needed as it will happen automatically."
  },
  {
    "objectID": "docstrings/medyan.refresh_chem_cache--f90ebca1f896ad2c.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.refresh_chem_cache--f90ebca1f896ad2c.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.refresh_chem_cache!",
    "section": "",
    "text": "refresh_chem_cache!(c::Context)::Nothing\nNormally this isn’t needed as it will happen automatically."
  },
  {
    "objectID": "docstrings/medyan.anystate-1965db924963e911.html",
    "href": "docstrings/medyan.anystate-1965db924963e911.html",
    "title": "MEDYAN.AnyState",
    "section": "",
    "text": "AnyState()\nSingleton type used in match in def_fila_reaction! and def_fila_tip_reaction! to match any MonomerState.\nUse the exported constant anystate instead of constructing directly."
  },
  {
    "objectID": "docstrings/medyan.anystate-1965db924963e911.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.anystate-1965db924963e911.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.AnyState",
    "section": "",
    "text": "AnyState()\nSingleton type used in match in def_fila_reaction! and def_fila_tip_reaction! to match any MonomerState.\nUse the exported constant anystate instead of constructing directly."
  },
  {
    "objectID": "docstrings/medyan.tag2place-68ab43363a4c1760.html",
    "href": "docstrings/medyan.tag2place-68ab43363a4c1760.html",
    "title": "MEDYAN.tag2place",
    "section": "",
    "text": "tag2place(c::Context, t::Tag)::Place\nReturn the place of the tag. Throw an error if !tag_exists(t)."
  },
  {
    "objectID": "docstrings/medyan.tag2place-68ab43363a4c1760.html#union-tuple-p---tuple-medyan.context--medyan.tag-p----where-p-f3255fd0d268d21a",
    "href": "docstrings/medyan.tag2place-68ab43363a4c1760.html#union-tuple-p---tuple-medyan.context--medyan.tag-p----where-p-f3255fd0d268d21a",
    "title": "MEDYAN.tag2place",
    "section": "",
    "text": "tag2place(c::Context, t::Tag)::Place\nReturn the place of the tag. Throw an error if !tag_exists(t)."
  },
  {
    "objectID": "docstrings/medyan.link_typeid-a14290ff2f9378f7.html",
    "href": "docstrings/medyan.link_typeid-a14290ff2f9378f7.html",
    "title": "MEDYAN.link_typeid",
    "section": "",
    "text": "link_typeid(c::Context, link::Link)::Int\nlink_typeid(c::Context; type::Union{Symbol, Integer})::Int\nReturn the typeid of the link’s type, or the typeid associated with type"
  },
  {
    "objectID": "docstrings/medyan.link_typeid-a14290ff2f9378f7.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.link_typeid-a14290ff2f9378f7.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.link_typeid",
    "section": "",
    "text": "link_typeid(c::Context, link::Link)::Int\nlink_typeid(c::Context; type::Union{Symbol, Integer})::Int\nReturn the typeid of the link’s type, or the typeid associated with type"
  },
  {
    "objectID": "docstrings/medyan.polymerize_fila--ef96193868627e48.html",
    "href": "docstrings/medyan.polymerize_fila--ef96193868627e48.html",
    "title": "MEDYAN.polymerize_fila!",
    "section": "",
    "text": "polymerize_fila!(c::Context, fila_tip_idx::FilaTipIdx, newstate::Union{Symbol,MonomerState})\nAdd a monomer with state newstate to the end of the filament.\nThis doesn’t affect the other monomer states, positions, or change any of the monomer ids. New monomers are not linkable until after minimization."
  },
  {
    "objectID": "docstrings/medyan.polymerize_fila--ef96193868627e48.html#tuple-medyan.context--medyan.filatipidx--union-uint8--symbol---0e9280d25a5258b3",
    "href": "docstrings/medyan.polymerize_fila--ef96193868627e48.html#tuple-medyan.context--medyan.filatipidx--union-uint8--symbol---0e9280d25a5258b3",
    "title": "MEDYAN.polymerize_fila!",
    "section": "",
    "text": "polymerize_fila!(c::Context, fila_tip_idx::FilaTipIdx, newstate::Union{Symbol,MonomerState})\nAdd a monomer with state newstate to the end of the filament.\nThis doesn’t affect the other monomer states, positions, or change any of the monomer ids. New monomers are not linkable until after minimization."
  },
  {
    "objectID": "docstrings/medyan.get_chem_boundary_tsdf_max_distance-f1ce8ced1faa2c40.html",
    "href": "docstrings/medyan.get_chem_boundary_tsdf_max_distance-f1ce8ced1faa2c40.html",
    "title": "MEDYAN.get_chem_boundary_tsdf_max_distance",
    "section": "",
    "text": "get_chem_boundary_tsdf_max_distance(\n    c::MEDYAN.Context\n) -&gt; Float64\nGet the user-specified maximum distance for TSDF truncation (nm). The actual max distance used is max(this, 2.5*grid_spacing)."
  },
  {
    "objectID": "docstrings/medyan.get_chem_boundary_tsdf_max_distance-f1ce8ced1faa2c40.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.get_chem_boundary_tsdf_max_distance-f1ce8ced1faa2c40.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.get_chem_boundary_tsdf_max_distance",
    "section": "",
    "text": "get_chem_boundary_tsdf_max_distance(\n    c::MEDYAN.Context\n) -&gt; Float64\nGet the user-specified maximum distance for TSDF truncation (nm). The actual max distance used is max(this, 2.5*grid_spacing)."
  },
  {
    "objectID": "docstrings/medyan.fila_tip_tags-f05dfa7a845b20ea.html",
    "href": "docstrings/medyan.fila_tip_tags-f05dfa7a845b20ea.html",
    "title": "MEDYAN.fila_tip_tags",
    "section": "",
    "text": "fila_tip_tags(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Pair{MEDYAN.Tag{MEDYAN.FilaTipIdx}, MEDYAN.Tag{MEDYAN.FilaTipIdx}}\nReturn the pair of minus end, plus end filament tip tags."
  },
  {
    "objectID": "docstrings/medyan.fila_tip_tags-f05dfa7a845b20ea.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "href": "docstrings/medyan.fila_tip_tags-f05dfa7a845b20ea.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "title": "MEDYAN.fila_tip_tags",
    "section": "",
    "text": "fila_tip_tags(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Pair{MEDYAN.Tag{MEDYAN.FilaTipIdx}, MEDYAN.Tag{MEDYAN.FilaTipIdx}}\nReturn the pair of minus end, plus end filament tip tags."
  },
  {
    "objectID": "docstrings/medyan.def_link_type--339fe050fe131631.html",
    "href": "docstrings/medyan.def_link_type--339fe050fe131631.html",
    "title": "MEDYAN.def_link_type!",
    "section": "",
    "text": "def_link_type!(s::SysDef; name, description, places, bonds, reactions, param, state)::SysDef\nAdd a new link type to the system definition. Links represent connections between simulation elements (filament monomers, filament tips, anchors, membrane vertices) that can have associated mechanical bonds and chemical reactions.\n\n\n\nname::Symbol: Unique identifier for this link type.\ndescription::String=\"\": Human-readable description of the link’s purpose.\nplaces::Vector{&lt;:Place}: The places this link connects. Each place can be:\n\nFilaMonoIdx(): A filament monomer\nFilaTipIdx(): A filament tip (plus or minus end)\nAnchor(): A free-floating anchor point (e.g., membrane-bound protein)\nBallIdx(): A ball (spherical object)\nMembVertIdx(): A membrane vertex\n\nbonds::Vector: Mechanical bonds between places. Each bond is a NamedTuple with:\n\nbond: Bond type (e.g., DistanceRestraint(), custom Bond subtype)\ninput::Tuple{Int...}: Which places the bond connects\nparam::NamedTuple: Fixed parameters (e.g., spring constant k)\nstate::NamedTuple: Mutable state (e.g., rest length L0)\nenabled::Bool=true: Whether bond is active by default\n\nreactions::Vector{Vector}: Reactions for each place. reactions[i] is a Vector of reactions for places[i]. Trailing places with no reactions can be omitted (i.e. length(reactions) ≤ length(places)). Each reaction is a NamedTuple with:\n\nRequired fields:\n\nname::Symbol: Unique identifier for this reaction within the place.\naffect!: Callback that executes the reaction. Signature: (c::Context; link::Link, chem_voxel::Int, reaction_id, place_idx, kwargs...) -&gt; Int. link is a handle identifying the specific link instance — pass it to get_state, update_link!, link2tags, etc. Return a status code for debugging purposes. For fila_cutoff reactions, also receives place::FilaMonoIdx (a randomly chosen nearby filament monomer within the cutoff distance).\n\nOptional fields:\n\nrate = Returns(1.0): Function (c::Context; link::Link, link_data, place_idx, link_state::NamedTuple, kwargs...) -&gt; Float64 returning the state-dependent rate factor. link_state is the current mutable state of this link instance (as defined by the state keyword). For multi-site binding, return the number of available sites (e.g., MAX_ARP23 - link_state.num_arp23). link_data is an internal object — pass it through to link2tags or get_link_mechanics for a small performance gain over the 1-argument forms. See “When rates are reevaluated” below for important constraints on what this function should depend on.\nbase_rate::Float64 = 1.0: Rate constant multiplier. Units depend on invvolumepower: 1/s for unimolecular (invvolumepower=0), nm³/s for bimolecular (invvolumepower=1). For example, a diffusion-limited on-rate k_D = 4πDR ≈ 1.57×10⁹ nm³/s for D=25 μm²/s, R=5 nm. Separating large rate constants from small integer multipliers in rate avoids overflow.\ninvvolumepower::Int64 = 0: Volume scaling. Set to 1 for bimolecular (nm³/s), 0 for unimolecular (1/s).\nreactants_extra::String = \"\": Additional reactant species whose counts multiply the propensity (e.g., \"diffusing.ARP23\"). Uses the same \"+\"-separated format as def_reaction! (e.g., \"diffusing.A + diffusing.B\").\nfila_cutoff::Tuple{Symbol, Float64} = nothing: If set, e.g., (:actin, 50.0), the propensity is multiplied by the number of nearby filament monomers of that type within the cutoff distance (nm). When the reaction fires, affect! receives one such monomer as place::FilaMonoIdx. Some monomers are invisible to this search until after a mechanics cycle — see “Monomer count caching and mechanics” below.\nenabled::Bool = true: Whether reaction is active by default.\n\n\nparam::NamedTuple=(;): Fixed parameters for the link type.\nstate::NamedTuple=(;): Initial mutable state (e.g., (num_bound=Int32(0),)).\n\n\n\n\nAlthough the rate callback receives the full Context and could in principle read any simulation state, the cached rate value is only incrementally recalculated for a specific link when one of the following events occurs during a chemistry step:\n\nupdate_link! is called on this link — any change to state, places, bond_states, bond_enabled, or reaction_enabled triggers a rate recalculation for all reactions on this link.\nThe chemical state (get_chem_state) of an attached place changes — specifically:\n\nA filament monomer state changes (e.g., via polymerization, depolymerization, severing, or update_fila_mono_state!): rates are recalculated for links attached to the changed monomer and its ±1 neighbors (and attached tips).\nAn anchor is moved via update_anchor!.\nA ball is modified via update_ball!.\n\n\nThe entire cache is fully rebuilt at the start of each chemistry phase after mechanics — so all rates are recomputed from scratch using the current Context state after mechanics.\nThis means: within a chemistry step, if the rate function reads something from the Context other than link_state or the chem state of its own places (see get_chem_state), that dependency will not be tracked and the cached rate will become stale until the next full cache rebuild. For example:\n\n✅ Safe: Reading link_state fields (e.g., link_state.num_arp23). Updated immediately when update_link! changes state.\n✅ Safe: Reading get_chem_state of attached places, or calling get_link_mechanics / is_minimized on the same link (these change only after mechanics, which triggers a full cache rebuild before the next chemistry step).\n⚠️ Stale within a chemistry step: Reading diffusing species counts, other links’ states, or the chem state of places that this link is not attached to. These values may change during chemistry without triggering a rate update for this link.\n\nWorkaround — rejection sampling: If a reaction rate genuinely depends on state that rate cannot track (e.g., the state of a nearby monomer not attached to this link), have rate return an upper bound of the true rate. Then in affect!, read the current state and accept the reaction with probability true_rate / upper_bound (rejecting by returning 0 otherwise). This preserves correct stochastic kinetics despite the stale cache.\n\n\n\nWhen a reaction has fila_cutoff set, its total propensity is base_rate × rate(...) × nearby_monomer_count × .... The nearby monomer count is cached alongside the rate factor and has its own important update semantics:\nUnminimized monomers are invisible to the neighbor search. The map_nearby_monomers function skips monomers within fila_num_unmin_ends of each filament end. Several operations mark monomers as “not minimized”, making them invisible until after the next mechanics cycle (which zeros fila_num_unmin_ends):\n\nmake_fila! / make_fila_rand!: All monomers on a newly created filament start unminimized.\npolymerize_fila!: The newly added monomer at the polymerized end is unminimized.\ndepolymerize_fila!: Decrements the unminimized count on the depolymerized end (saturating at 0).\nsever_fila!: All monomers on both daughter filaments are marked unminimized.\n\n\n\n\nconst NPF_MAX_ARP23 = Int32(3)  # maximum ARP2/3 that can bind per NPF\n\nMEDYAN.def_link_type!(s;\n    name=:npf_anchor,\n    description=\"Nucleation promoting factor anchored to membrane\",\n    places=[Anchor()],\n    state=(;\n        num_arp23 = Int32(0),  # bound ARP2/3 count\n        num_actin = Int32(0),  # bound actin count\n    ),\n    reactions=[\n        [  # reactions for places[1] (the Anchor)\n            # Bimolecular binding: NPF + diffusing ARP2/3 → NPF·ARP2/3\n            (;\n                name = :arp23_bind,\n                affect! = (c; link, chem_voxel, kwargs...) -&gt; let\n                    link_state = get_state(c, link)\n                    update_link!(c, link; state=(num_arp23=link_state.num_arp23 + Int32(1),))\n                    add_diffusing_count!(c; species=:ARP23, chem_voxel, amount=-1)\n                    1  # success\n                end,\n                rate = (c; link_state, kwargs...) -&gt; NPF_MAX_ARP23 - link_state.num_arp23,\n                base_rate = 5E7,  # nm³/s (bimolecular on-rate)\n                reactants_extra = \"diffusing.ARP23\",\n                invvolumepower = 1,\n            ),\n            # Unimolecular unbinding: NPF·ARP2/3 → NPF + ARP2/3\n            (;\n                name = :arp23_unbind,\n                affect! = (c; link, chem_voxel, kwargs...) -&gt; let\n                    link_state = get_state(c, link)\n                    update_link!(c, link; state=(num_arp23=link_state.num_arp23 - Int32(1),))\n                    add_diffusing_count!(c; species=:ARP23, chem_voxel, amount=+1)\n                    1  # success\n                end,\n                rate = (c; link_state, kwargs...) -&gt; link_state.num_arp23,\n                base_rate = 0.01,  # 1/s per bound ARP2/3\n            ),\n        ],\n    ],\n)"
  },
  {
    "objectID": "docstrings/medyan.def_link_type--339fe050fe131631.html#tuple-medyan.sysdef--efaa49a98644904f",
    "href": "docstrings/medyan.def_link_type--339fe050fe131631.html#tuple-medyan.sysdef--efaa49a98644904f",
    "title": "MEDYAN.def_link_type!",
    "section": "",
    "text": "def_link_type!(s::SysDef; name, description, places, bonds, reactions, param, state)::SysDef\nAdd a new link type to the system definition. Links represent connections between simulation elements (filament monomers, filament tips, anchors, membrane vertices) that can have associated mechanical bonds and chemical reactions.\n\n\n\nname::Symbol: Unique identifier for this link type.\ndescription::String=\"\": Human-readable description of the link’s purpose.\nplaces::Vector{&lt;:Place}: The places this link connects. Each place can be:\n\nFilaMonoIdx(): A filament monomer\nFilaTipIdx(): A filament tip (plus or minus end)\nAnchor(): A free-floating anchor point (e.g., membrane-bound protein)\nBallIdx(): A ball (spherical object)\nMembVertIdx(): A membrane vertex\n\nbonds::Vector: Mechanical bonds between places. Each bond is a NamedTuple with:\n\nbond: Bond type (e.g., DistanceRestraint(), custom Bond subtype)\ninput::Tuple{Int...}: Which places the bond connects\nparam::NamedTuple: Fixed parameters (e.g., spring constant k)\nstate::NamedTuple: Mutable state (e.g., rest length L0)\nenabled::Bool=true: Whether bond is active by default\n\nreactions::Vector{Vector}: Reactions for each place. reactions[i] is a Vector of reactions for places[i]. Trailing places with no reactions can be omitted (i.e. length(reactions) ≤ length(places)). Each reaction is a NamedTuple with:\n\nRequired fields:\n\nname::Symbol: Unique identifier for this reaction within the place.\naffect!: Callback that executes the reaction. Signature: (c::Context; link::Link, chem_voxel::Int, reaction_id, place_idx, kwargs...) -&gt; Int. link is a handle identifying the specific link instance — pass it to get_state, update_link!, link2tags, etc. Return a status code for debugging purposes. For fila_cutoff reactions, also receives place::FilaMonoIdx (a randomly chosen nearby filament monomer within the cutoff distance).\n\nOptional fields:\n\nrate = Returns(1.0): Function (c::Context; link::Link, link_data, place_idx, link_state::NamedTuple, kwargs...) -&gt; Float64 returning the state-dependent rate factor. link_state is the current mutable state of this link instance (as defined by the state keyword). For multi-site binding, return the number of available sites (e.g., MAX_ARP23 - link_state.num_arp23). link_data is an internal object — pass it through to link2tags or get_link_mechanics for a small performance gain over the 1-argument forms. See “When rates are reevaluated” below for important constraints on what this function should depend on.\nbase_rate::Float64 = 1.0: Rate constant multiplier. Units depend on invvolumepower: 1/s for unimolecular (invvolumepower=0), nm³/s for bimolecular (invvolumepower=1). For example, a diffusion-limited on-rate k_D = 4πDR ≈ 1.57×10⁹ nm³/s for D=25 μm²/s, R=5 nm. Separating large rate constants from small integer multipliers in rate avoids overflow.\ninvvolumepower::Int64 = 0: Volume scaling. Set to 1 for bimolecular (nm³/s), 0 for unimolecular (1/s).\nreactants_extra::String = \"\": Additional reactant species whose counts multiply the propensity (e.g., \"diffusing.ARP23\"). Uses the same \"+\"-separated format as def_reaction! (e.g., \"diffusing.A + diffusing.B\").\nfila_cutoff::Tuple{Symbol, Float64} = nothing: If set, e.g., (:actin, 50.0), the propensity is multiplied by the number of nearby filament monomers of that type within the cutoff distance (nm). When the reaction fires, affect! receives one such monomer as place::FilaMonoIdx. Some monomers are invisible to this search until after a mechanics cycle — see “Monomer count caching and mechanics” below.\nenabled::Bool = true: Whether reaction is active by default.\n\n\nparam::NamedTuple=(;): Fixed parameters for the link type.\nstate::NamedTuple=(;): Initial mutable state (e.g., (num_bound=Int32(0),)).\n\n\n\n\nAlthough the rate callback receives the full Context and could in principle read any simulation state, the cached rate value is only incrementally recalculated for a specific link when one of the following events occurs during a chemistry step:\n\nupdate_link! is called on this link — any change to state, places, bond_states, bond_enabled, or reaction_enabled triggers a rate recalculation for all reactions on this link.\nThe chemical state (get_chem_state) of an attached place changes — specifically:\n\nA filament monomer state changes (e.g., via polymerization, depolymerization, severing, or update_fila_mono_state!): rates are recalculated for links attached to the changed monomer and its ±1 neighbors (and attached tips).\nAn anchor is moved via update_anchor!.\nA ball is modified via update_ball!.\n\n\nThe entire cache is fully rebuilt at the start of each chemistry phase after mechanics — so all rates are recomputed from scratch using the current Context state after mechanics.\nThis means: within a chemistry step, if the rate function reads something from the Context other than link_state or the chem state of its own places (see get_chem_state), that dependency will not be tracked and the cached rate will become stale until the next full cache rebuild. For example:\n\n✅ Safe: Reading link_state fields (e.g., link_state.num_arp23). Updated immediately when update_link! changes state.\n✅ Safe: Reading get_chem_state of attached places, or calling get_link_mechanics / is_minimized on the same link (these change only after mechanics, which triggers a full cache rebuild before the next chemistry step).\n⚠️ Stale within a chemistry step: Reading diffusing species counts, other links’ states, or the chem state of places that this link is not attached to. These values may change during chemistry without triggering a rate update for this link.\n\nWorkaround — rejection sampling: If a reaction rate genuinely depends on state that rate cannot track (e.g., the state of a nearby monomer not attached to this link), have rate return an upper bound of the true rate. Then in affect!, read the current state and accept the reaction with probability true_rate / upper_bound (rejecting by returning 0 otherwise). This preserves correct stochastic kinetics despite the stale cache.\n\n\n\nWhen a reaction has fila_cutoff set, its total propensity is base_rate × rate(...) × nearby_monomer_count × .... The nearby monomer count is cached alongside the rate factor and has its own important update semantics:\nUnminimized monomers are invisible to the neighbor search. The map_nearby_monomers function skips monomers within fila_num_unmin_ends of each filament end. Several operations mark monomers as “not minimized”, making them invisible until after the next mechanics cycle (which zeros fila_num_unmin_ends):\n\nmake_fila! / make_fila_rand!: All monomers on a newly created filament start unminimized.\npolymerize_fila!: The newly added monomer at the polymerized end is unminimized.\ndepolymerize_fila!: Decrements the unminimized count on the depolymerized end (saturating at 0).\nsever_fila!: All monomers on both daughter filaments are marked unminimized.\n\n\n\n\nconst NPF_MAX_ARP23 = Int32(3)  # maximum ARP2/3 that can bind per NPF\n\nMEDYAN.def_link_type!(s;\n    name=:npf_anchor,\n    description=\"Nucleation promoting factor anchored to membrane\",\n    places=[Anchor()],\n    state=(;\n        num_arp23 = Int32(0),  # bound ARP2/3 count\n        num_actin = Int32(0),  # bound actin count\n    ),\n    reactions=[\n        [  # reactions for places[1] (the Anchor)\n            # Bimolecular binding: NPF + diffusing ARP2/3 → NPF·ARP2/3\n            (;\n                name = :arp23_bind,\n                affect! = (c; link, chem_voxel, kwargs...) -&gt; let\n                    link_state = get_state(c, link)\n                    update_link!(c, link; state=(num_arp23=link_state.num_arp23 + Int32(1),))\n                    add_diffusing_count!(c; species=:ARP23, chem_voxel, amount=-1)\n                    1  # success\n                end,\n                rate = (c; link_state, kwargs...) -&gt; NPF_MAX_ARP23 - link_state.num_arp23,\n                base_rate = 5E7,  # nm³/s (bimolecular on-rate)\n                reactants_extra = \"diffusing.ARP23\",\n                invvolumepower = 1,\n            ),\n            # Unimolecular unbinding: NPF·ARP2/3 → NPF + ARP2/3\n            (;\n                name = :arp23_unbind,\n                affect! = (c; link, chem_voxel, kwargs...) -&gt; let\n                    link_state = get_state(c, link)\n                    update_link!(c, link; state=(num_arp23=link_state.num_arp23 - Int32(1),))\n                    add_diffusing_count!(c; species=:ARP23, chem_voxel, amount=+1)\n                    1  # success\n                end,\n                rate = (c; link_state, kwargs...) -&gt; link_state.num_arp23,\n                base_rate = 0.01,  # 1/s per bound ARP2/3\n            ),\n        ],\n    ],\n)"
  },
  {
    "objectID": "docstrings/medyan.get_bond_states-b314ae6ee2a2b3cf.html",
    "href": "docstrings/medyan.get_bond_states-b314ae6ee2a2b3cf.html",
    "title": "MEDYAN.get_bond_states",
    "section": "",
    "text": "get_bond_states(c::Context, link::Link, [d::LinkData])\nReturn the bond_states of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.get_bond_states-b314ae6ee2a2b3cf.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--any---03b671600f22589f",
    "href": "docstrings/medyan.get_bond_states-b314ae6ee2a2b3cf.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--any---03b671600f22589f",
    "title": "MEDYAN.get_bond_states",
    "section": "",
    "text": "get_bond_states(c::Context, link::Link, [d::LinkData])\nReturn the bond_states of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.remove_link--01531e04ef5077e7.html",
    "href": "docstrings/medyan.remove_link--01531e04ef5077e7.html",
    "title": "MEDYAN.remove_link!",
    "section": "",
    "text": "remove_link!(c::Context, link::Link)::Nothing\nRemove the link."
  },
  {
    "objectID": "docstrings/medyan.remove_link--01531e04ef5077e7.html#tuple-medyan.context--medyan.link--d37b229d2ebf6962",
    "href": "docstrings/medyan.remove_link--01531e04ef5077e7.html#tuple-medyan.context--medyan.link--d37b229d2ebf6962",
    "title": "MEDYAN.remove_link!",
    "section": "",
    "text": "remove_link!(c::Context, link::Link)::Nothing\nRemove the link."
  },
  {
    "objectID": "docstrings/medyan.centerof-e902b9bb7b2a6caf.html",
    "href": "docstrings/medyan.centerof-e902b9bb7b2a6caf.html",
    "title": "MEDYAN.centerof",
    "section": "",
    "text": "centerof(grid::CubicGrid, cid)\nReturn the location of the center of a grid id The origin is in the center.\n\n\n\n\n\n\n\n\n\n\n\n\ncenterof(grid::CubicGrid)\nReturn the location of the center the grid The origin is in the center."
  },
  {
    "objectID": "docstrings/medyan.centerof-e902b9bb7b2a6caf.html#tuple-medyan.cubicgrid--any--1be3c03f7960c1a3",
    "href": "docstrings/medyan.centerof-e902b9bb7b2a6caf.html#tuple-medyan.cubicgrid--any--1be3c03f7960c1a3",
    "title": "MEDYAN.centerof",
    "section": "",
    "text": "centerof(grid::CubicGrid, cid)\nReturn the location of the center of a grid id The origin is in the center."
  },
  {
    "objectID": "docstrings/medyan.centerof-e902b9bb7b2a6caf.html#tuple-medyan.cubicgrid--0971be2da0774049",
    "href": "docstrings/medyan.centerof-e902b9bb7b2a6caf.html#tuple-medyan.cubicgrid--0971be2da0774049",
    "title": "MEDYAN.centerof",
    "section": "",
    "text": "centerof(grid::CubicGrid)\nReturn the location of the center the grid The origin is in the center."
  },
  {
    "objectID": "docstrings/medyan.filamentsitegeneral-0d87ce44fed17b2c.html",
    "href": "docstrings/medyan.filamentsitegeneral-0d87ce44fed17b2c.html",
    "title": "MEDYAN.FilamentSiteGeneral",
    "section": "",
    "text": "General filament site just matches monomer states\n\ncenter::Int64: index of center monomer in states\nstates::Vector{UInt8}: monomer states to match"
  },
  {
    "objectID": "docstrings/medyan.filamentsitegeneral-0d87ce44fed17b2c.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.filamentsitegeneral-0d87ce44fed17b2c.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.FilamentSiteGeneral",
    "section": "",
    "text": "General filament site just matches monomer states\n\ncenter::Int64: index of center monomer in states\nstates::Vector{UInt8}: monomer states to match"
  },
  {
    "objectID": "docstrings/medyan.filaidx-89c89b8bbef4dbda.html",
    "href": "docstrings/medyan.filaidx-89c89b8bbef4dbda.html",
    "title": "MEDYAN.FilaIdx",
    "section": "",
    "text": "FilaIdx\nAn index identifying a specific filament in the simulation. This is a lightweight reference that becomes invalid after filament mutations (removal or reordering).\nUnlike the Place subtypes, FilaIdx is not taggable — filaments do not have a stable identity because of operations like severing. To maintain a long-term reference to a filament, store a Tag{FilaTipIdx} or Tag{FilaMonoIdx} instead, and resolve back to a FilaIdx when needed.\n\n\n\nFilaIdx(typeid::Integer, idx::Integer): Direct constructor with filament type ID and filament index\nFilaIdx(c::Context, f::FilaIdx): Re-resolve a filament index\nFilaIdx(c::Context, ft::FilaTipIdx): Extract the filament index from a filament tip index\nFilaIdx(c::Context, t::Tag): Construct from a context and a filament-related tag (e.g., Tag{FilaTipIdx} or Tag{FilaMonoIdx})\nFilaIdx(c::Context, fm::FilaMonoIdx): Extract the filament index from a filament monomer index\n\n\n\n\n\ntypeid::UInt32: The filament type ID (use fila_typeid(c; type=:actin) to get this)\nidx::UInt32: The index of the filament within its type (1-based)\n\n\n\n\n# Iterate over all filaments of a given type\nftid = fila_typeid(c; type=:actin)\nfor i in 1:num_fila(c; type=:actin)\n    fidx = FilaIdx(ftid, i)\n    states = fila_mono_states(c, fidx)\n    positions = fila_node_positions(c, fidx)\nend\n\n\n\nSee num_fila, fila_typeid, fila_mono_ids, fila_mono_states, fila_node_positions, fila_tip_tags."
  },
  {
    "objectID": "docstrings/medyan.filaidx-89c89b8bbef4dbda.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.filaidx-89c89b8bbef4dbda.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.FilaIdx",
    "section": "",
    "text": "FilaIdx\nAn index identifying a specific filament in the simulation. This is a lightweight reference that becomes invalid after filament mutations (removal or reordering).\nUnlike the Place subtypes, FilaIdx is not taggable — filaments do not have a stable identity because of operations like severing. To maintain a long-term reference to a filament, store a Tag{FilaTipIdx} or Tag{FilaMonoIdx} instead, and resolve back to a FilaIdx when needed.\n\n\n\nFilaIdx(typeid::Integer, idx::Integer): Direct constructor with filament type ID and filament index\nFilaIdx(c::Context, f::FilaIdx): Re-resolve a filament index\nFilaIdx(c::Context, ft::FilaTipIdx): Extract the filament index from a filament tip index\nFilaIdx(c::Context, t::Tag): Construct from a context and a filament-related tag (e.g., Tag{FilaTipIdx} or Tag{FilaMonoIdx})\nFilaIdx(c::Context, fm::FilaMonoIdx): Extract the filament index from a filament monomer index\n\n\n\n\n\ntypeid::UInt32: The filament type ID (use fila_typeid(c; type=:actin) to get this)\nidx::UInt32: The index of the filament within its type (1-based)\n\n\n\n\n# Iterate over all filaments of a given type\nftid = fila_typeid(c; type=:actin)\nfor i in 1:num_fila(c; type=:actin)\n    fidx = FilaIdx(ftid, i)\n    states = fila_mono_states(c, fidx)\n    positions = fila_node_positions(c, fidx)\nend\n\n\n\nSee num_fila, fila_typeid, fila_mono_ids, fila_mono_states, fila_node_positions, fila_tip_tags."
  },
  {
    "objectID": "docstrings/base.---a21e771ed8ea7d6f.html",
    "href": "docstrings/base.---a21e771ed8ea7d6f.html",
    "title": "Base.:*",
    "section": "",
    "text": "scale the volume and area\n\n\n\n\n\n\n\n\n\n\n\n\nscale the volume and area by different amounts in each direction"
  },
  {
    "objectID": "docstrings/base.---a21e771ed8ea7d6f.html#tuple-medyan.planecuboidslicingresult--real--351897cd93ec653f",
    "href": "docstrings/base.---a21e771ed8ea7d6f.html#tuple-medyan.planecuboidslicingresult--real--351897cd93ec653f",
    "title": "Base.:*",
    "section": "",
    "text": "scale the volume and area"
  },
  {
    "objectID": "docstrings/base.---a21e771ed8ea7d6f.html#tuple-medyan.planecuboidslicingresult--abstractvector--a044ea7870b5bb9c",
    "href": "docstrings/base.---a21e771ed8ea7d6f.html#tuple-medyan.planecuboidslicingresult--abstractvector--a044ea7870b5bb9c",
    "title": "Base.:*",
    "section": "",
    "text": "scale the volume and area by different amounts in each direction"
  },
  {
    "objectID": "docstrings/medyan.remove_ball--57fbfd7855882ccd.html",
    "href": "docstrings/medyan.remove_ball--57fbfd7855882ccd.html",
    "title": "MEDYAN.remove_ball!",
    "section": "",
    "text": "remove_ball!(c::Context, ball::Union{BallIdx, Tag{BallIdx}})\nRemove a ball from the simulation and unlink all connected links.\nSee also: make_ball!, update_ball!, get_position, is_minimized"
  },
  {
    "objectID": "docstrings/medyan.remove_ball--57fbfd7855882ccd.html#tuple-medyan.context--medyan.ballidx--277715bc057ae4e8",
    "href": "docstrings/medyan.remove_ball--57fbfd7855882ccd.html#tuple-medyan.context--medyan.ballidx--277715bc057ae4e8",
    "title": "MEDYAN.remove_ball!",
    "section": "",
    "text": "remove_ball!(c::Context, ball::Union{BallIdx, Tag{BallIdx}})\nRemove a ball from the simulation and unlink all connected links.\nSee also: make_ball!, update_ball!, get_position, is_minimized"
  },
  {
    "objectID": "docstrings/base.setindex--725f722fff4cfa6d.html",
    "href": "docstrings/base.setindex--725f722fff4cfa6d.html",
    "title": "Base.setindex!",
    "section": "",
    "text": "Map ID to a new index. The ID must be in use."
  },
  {
    "objectID": "docstrings/base.setindex--725f722fff4cfa6d.html#tuple-medyan.stableindex--integer--integer--808485796eb5543d",
    "href": "docstrings/base.setindex--725f722fff4cfa6d.html#tuple-medyan.stableindex--integer--integer--808485796eb5543d",
    "title": "Base.setindex!",
    "section": "",
    "text": "Map ID to a new index. The ID must be in use."
  },
  {
    "objectID": "docstrings/medyan.get_link_mechanics-57ba2f1a141d0156.html",
    "href": "docstrings/medyan.get_link_mechanics-57ba2f1a141d0156.html",
    "title": "MEDYAN.get_link_mechanics",
    "section": "",
    "text": "get_link_mechanics(c::Context, link::Link, [d::LinkData])\nReturn a NamedTuple of (;energy, inputs, forces, torques) of the link. Throw an error if link doesn’t exist. Parts of inputs that do not exist will be set to NaN."
  },
  {
    "objectID": "docstrings/medyan.get_link_mechanics-57ba2f1a141d0156.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--medyan.linkdata---c8d94eda9cfd0bb4",
    "href": "docstrings/medyan.get_link_mechanics-57ba2f1a141d0156.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--medyan.linkdata---c8d94eda9cfd0bb4",
    "title": "MEDYAN.get_link_mechanics",
    "section": "",
    "text": "get_link_mechanics(c::Context, link::Link, [d::LinkData])\nReturn a NamedTuple of (;energy, inputs, forces, torques) of the link. Throw an error if link doesn’t exist. Parts of inputs that do not exist will be set to NaN."
  },
  {
    "objectID": "docstrings/medyan.ballidx-5a4aba766d557d6a.html",
    "href": "docstrings/medyan.ballidx-5a4aba766d557d6a.html",
    "title": "MEDYAN.BallIdx",
    "section": "",
    "text": "BallIdx &lt;: Place\nAn index referring to a ball (spherical particle) in the simulation. Balls are stored in the balls vector of the Context and represent spherical objects with position, radius, and stiffness that can participate in mechanical interactions and chemical reactions.\nThis index may be invalidated by ball removal or reordering. Use a Tag{BallIdx} for a long-term reference that remains valid across mutations.\n\n\n\nBallIdx(): Creates a null ball index with idx 0\nBallIdx(idx::Int64): Creates a ball index pointing to the ball at position idx in the context’s balls vector\nBallIdx(c::Context, idx::Integer): Construct from context with index\nBallIdx(c::Context, b::BallIdx): Re-resolve a ball index\nBallIdx(c::Context, t::Tag{BallIdx}): Construct from a tag\n\n\n\n\n\nidx::Int64: Index of the ball in the context’s balls vector\n\n\n\n\nSee make_ball!, remove_ball!, and update_ball! for creating, removing, and modifying balls."
  },
  {
    "objectID": "docstrings/medyan.ballidx-5a4aba766d557d6a.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.ballidx-5a4aba766d557d6a.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.BallIdx",
    "section": "",
    "text": "BallIdx &lt;: Place\nAn index referring to a ball (spherical particle) in the simulation. Balls are stored in the balls vector of the Context and represent spherical objects with position, radius, and stiffness that can participate in mechanical interactions and chemical reactions.\nThis index may be invalidated by ball removal or reordering. Use a Tag{BallIdx} for a long-term reference that remains valid across mutations.\n\n\n\nBallIdx(): Creates a null ball index with idx 0\nBallIdx(idx::Int64): Creates a ball index pointing to the ball at position idx in the context’s balls vector\nBallIdx(c::Context, idx::Integer): Construct from context with index\nBallIdx(c::Context, b::BallIdx): Re-resolve a ball index\nBallIdx(c::Context, t::Tag{BallIdx}): Construct from a tag\n\n\n\n\n\nidx::Int64: Index of the ball in the context’s balls vector\n\n\n\n\nSee make_ball!, remove_ball!, and update_ball! for creating, removing, and modifying balls."
  },
  {
    "objectID": "docstrings/medyan.membranespeciesparams-548fecb643fc2599.html",
    "href": "docstrings/medyan.membranespeciesparams-548fecb643fc2599.html",
    "title": "MEDYAN.MembraneSpeciesParams",
    "section": "",
    "text": "Membrane protein physical parameters.\n\ndiffusion_coeff::Float64: Membrane diffusion coefficients (nm^2/s).\narea::Float64: Protein area projected onto the surface (nm^2).\nkbend::Float64: Bending rigidity (pN nm).\neqcurv::Float64: The protein’s own spontaneous mean curvature (/nm). Can be used in bending energy computations with curvatures."
  },
  {
    "objectID": "docstrings/medyan.membranespeciesparams-548fecb643fc2599.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.membranespeciesparams-548fecb643fc2599.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.MembraneSpeciesParams",
    "section": "",
    "text": "Membrane protein physical parameters.\n\ndiffusion_coeff::Float64: Membrane diffusion coefficients (nm^2/s).\narea::Float64: Protein area projected onto the surface (nm^2).\nkbend::Float64: Bending rigidity (pN nm).\neqcurv::Float64: The protein’s own spontaneous mean curvature (/nm). Can be used in bending energy computations with curvatures."
  },
  {
    "objectID": "docstrings/medyan.addpossiblecadherinsite--ae8586daa0b5454a.html",
    "href": "docstrings/medyan.addpossiblecadherinsite--ae8586daa0b5454a.html",
    "title": "MEDYAN.addpossiblecadherinsite!",
    "section": "",
    "text": "addpossiblecadherinsite!(s::SysDef,possiblecadherinsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.addpossiblecadherinsite--ae8586daa0b5454a.html#tuple-medyan.sysdef--symbol--any--444c61f2a1ac78e1",
    "href": "docstrings/medyan.addpossiblecadherinsite--ae8586daa0b5454a.html#tuple-medyan.sysdef--symbol--any--444c61f2a1ac78e1",
    "title": "MEDYAN.addpossiblecadherinsite!",
    "section": "",
    "text": "addpossiblecadherinsite!(s::SysDef,possiblecadherinsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "reference/sitesinfo.html",
    "href": "reference/sitesinfo.html",
    "title": "Sites",
    "section": "",
    "text": "Abstractly, sites are an interface that allow more complex structures like filaments to interact with diffusing species and chemistry voxel reaction propensities.\nEach site type has an associated fixed species. During chemistry that fixed species count will always be greater than or equal to the total counts of the site in the chemistry voxel.\nChemistry callbacks can try and pick a random site in a chemistry voxel to get specific information about exactly where in a chemistry voxel some event should happen.\nThese are the groups of sites currently in MEDYAN.jl:\n\n\nFilament sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament site.\n\n\nHow many monomer states in the plus direction this site looks at.\n\n\n\nHow many monomer states in the minus direction this site looks at.\n\n\n\nReturn site count at a monomer given states, A vector of MonomerState with length length(states) == getminusrange(filamentsite) + 1 + getplusrange(filamentsite)\nThe site count gets put in the chemistry voxel of the center monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pick_rand_fila_mono_site function\nMEDYAN.Context#filamentsites field\n\n\n\nMEDYAN.SysDef#filamentsite field\nMEDYAN.addfilamentsite! function\nMEDYAN.def_fila_reaction! function\n\n\n\n\n\nFilament end sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament end site.\n\n\nHow many monomer states this site looks at.\n\n\n\nTrue if the filament end site is on the minus end, false if on the plus end.\n\n\n\nReturn spacing needed for the filament end site reaction to happen, units of nm.\n\n\n\nReturn number of monomers that need to be added for the filament end site reaction to happen. Each filament has a limited number of monomers that can be added per end between minimizations given by FilamentMechParams.max_num_unmin_end. If this function returns zero, this limit is ignored for site. Also, see fila_num_unmin_ends If this function returns a number greater than zero, the site count will be zero if the current number of unminimized monomers on the end plus the added_monomers result will go over FilamentMechParams.max_num_unmin_end.\n\n\n\nReturn the filament end site count at the end of a filament with monomer states vector states The rate of filament end reaction will be modified by the brownian ratchet model:\nexp(-β*F*L) where F is the compression force on the filament end, and L is spacing(site).\nlength(states) == getrange(filamentendsite)\nThe site count gets put in the chemistry voxel of the end monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pick_rand_fila_tip_site\n\n\n\nMEDYAN.SysDef#filamentendsite field\nMEDYAN.addfilamentendsite!\nMEDYAN.def_fila_tip_reaction!\n\n\n\n\n\nDecimated_2mon sites represent a potential link between two monomers, potentially on two different filaments. The site count is added to the chemistry voxel of the potential monomer that could attach to the minus end of the link.\n\n\nA type T must implement the following functions to be a decimated_2mon site.\n\n\nReturn the maximum distance in nm of a decimated_2mon site.\n\n\n\nReturn the maximum decimated_2mon_sitecount will return given a pair of monomers in_linking_range.\n\n\n\nReturn if two monomers are in range to possibly link in the forward direction, and if they are in range to possibly link in the reverse direction.\n\n\n\nReturn the filament types of the minus and plus monomers.\n\n\n\nReturn the monomer step size starting with mid 0 in the search for potential decimated_2mon sites on the minus and plus ends respectively.\n1 searches every monomer. 2 searches every monomer with even mid …\nIf the plus and minus filament types are the same, then getmidsteps(site)[1] == getmidsteps(site)[2]\n\n\n\nReturn the site count of two monomers getting linked given their states, their positions, and their plus vectors. The monomers can be assumed to be in_linking_range, from the correct filament types, and at the correct step.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandom_decimated_2mon_site\nMEDYAN.Context#decimated_2mon_sites field\n\n\n\nMEDYAN.SysDef#decimated_2mon_site field\nMEDYAN.add_decimated_2mon_site!",
    "crumbs": [
      "Reference",
      "Sites"
    ]
  },
  {
    "objectID": "reference/sitesinfo.html#filament-sites",
    "href": "reference/sitesinfo.html#filament-sites",
    "title": "Sites",
    "section": "",
    "text": "Filament sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament site.\n\n\nHow many monomer states in the plus direction this site looks at.\n\n\n\nHow many monomer states in the minus direction this site looks at.\n\n\n\nReturn site count at a monomer given states, A vector of MonomerState with length length(states) == getminusrange(filamentsite) + 1 + getplusrange(filamentsite)\nThe site count gets put in the chemistry voxel of the center monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pick_rand_fila_mono_site function\nMEDYAN.Context#filamentsites field\n\n\n\nMEDYAN.SysDef#filamentsite field\nMEDYAN.addfilamentsite! function\nMEDYAN.def_fila_reaction! function",
    "crumbs": [
      "Reference",
      "Sites"
    ]
  },
  {
    "objectID": "reference/sitesinfo.html#filament-end-sites",
    "href": "reference/sitesinfo.html#filament-end-sites",
    "title": "Sites",
    "section": "",
    "text": "Filament end sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament end site.\n\n\nHow many monomer states this site looks at.\n\n\n\nTrue if the filament end site is on the minus end, false if on the plus end.\n\n\n\nReturn spacing needed for the filament end site reaction to happen, units of nm.\n\n\n\nReturn number of monomers that need to be added for the filament end site reaction to happen. Each filament has a limited number of monomers that can be added per end between minimizations given by FilamentMechParams.max_num_unmin_end. If this function returns zero, this limit is ignored for site. Also, see fila_num_unmin_ends If this function returns a number greater than zero, the site count will be zero if the current number of unminimized monomers on the end plus the added_monomers result will go over FilamentMechParams.max_num_unmin_end.\n\n\n\nReturn the filament end site count at the end of a filament with monomer states vector states The rate of filament end reaction will be modified by the brownian ratchet model:\nexp(-β*F*L) where F is the compression force on the filament end, and L is spacing(site).\nlength(states) == getrange(filamentendsite)\nThe site count gets put in the chemistry voxel of the end monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pick_rand_fila_tip_site\n\n\n\nMEDYAN.SysDef#filamentendsite field\nMEDYAN.addfilamentendsite!\nMEDYAN.def_fila_tip_reaction!",
    "crumbs": [
      "Reference",
      "Sites"
    ]
  },
  {
    "objectID": "reference/sitesinfo.html#decimated_2mon-sites",
    "href": "reference/sitesinfo.html#decimated_2mon-sites",
    "title": "Sites",
    "section": "",
    "text": "Decimated_2mon sites represent a potential link between two monomers, potentially on two different filaments. The site count is added to the chemistry voxel of the potential monomer that could attach to the minus end of the link.\n\n\nA type T must implement the following functions to be a decimated_2mon site.\n\n\nReturn the maximum distance in nm of a decimated_2mon site.\n\n\n\nReturn the maximum decimated_2mon_sitecount will return given a pair of monomers in_linking_range.\n\n\n\nReturn if two monomers are in range to possibly link in the forward direction, and if they are in range to possibly link in the reverse direction.\n\n\n\nReturn the filament types of the minus and plus monomers.\n\n\n\nReturn the monomer step size starting with mid 0 in the search for potential decimated_2mon sites on the minus and plus ends respectively.\n1 searches every monomer. 2 searches every monomer with even mid …\nIf the plus and minus filament types are the same, then getmidsteps(site)[1] == getmidsteps(site)[2]\n\n\n\nReturn the site count of two monomers getting linked given their states, their positions, and their plus vectors. The monomers can be assumed to be in_linking_range, from the correct filament types, and at the correct step.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandom_decimated_2mon_site\nMEDYAN.Context#decimated_2mon_sites field\n\n\n\nMEDYAN.SysDef#decimated_2mon_site field\nMEDYAN.add_decimated_2mon_site!",
    "crumbs": [
      "Reference",
      "Sites"
    ]
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Table of Contents",
    "section": "",
    "text": "src/sysdefs.jl\n\nMEDYAN.SysDef\ndef_diffusing_species!\ndef_fixed_species!\ndef_reaction!\ndef_fila_type!\ndef_fila_reaction!\ndef_fila_tip_reaction!\ndef_link_type!\n\n\n\n\n\nMEDYAN.Context\nCubicGrid\ndeepcopy, note: rng is shared\n\n\n\n\n\nBase.empty!\nload_snapshot!\nchem_adddiffusingcount!\nchem_addfixedcount!\nadddiffusingcount_rand!\nset_time!\nset_enable_collision!\nset_chem_boundary!\nset_mechboundary!\n\n\n\n\n\nmake_ball!\nremove_ball!\nupdate_ball!\n\n\n\n\n\nmake_fila!\nmake_fila_rand!\nremove_fila!\nupdate_fila_mono_state!\npolymerize_fila!\ndepolymerize_fila!\nsever_fila!\nnum_fila_types\nfila_type_name\nfila_typeid\nnum_fila\nfila_mono_ids\nfila_mono_states\nfila_num_nodes\nfila_node_mids\nfila_node_positions\nfila_tip_tags\nfila_num_unmin_ends\npick_rand_fila_mono_site\npick_rand_fila_tip_site\n\n\n\n\n\nmake_memb!\nmake_memb_sphere!\nmake_memb_rectangle!\n\n\n\n\n\nPlace\nFilaIdx\nFilaTipIdx\nFilaMonoIdx\nMembVertIdx\nAnchor\nBallIdx\nTag\ntag!\nmake_link!\nremove_link!\nupdate_link!\nmake_anchor!\nremove_anchor!\nupdate_anchor!\nnum_link_types\nlink_type_name\nlink_typeid\nget_all_links\nget_all_tags\ntag2links\nplace2links\ntag_exists\nplace_exists\nlink_exists\nlink2tags\ntag2place\nplace2tag\nhas_tag\nget_position\nnum_directions\nget_directions\nget_material_frame\nget_chem_state\nget_state\nget_bond_states\nget_bond_enabled\nget_reaction_enabled\nis_minimized\nget_link_mechanics\n\n\n\n\n\napply_chem_boundary!\nrun_chemistry!\nminimize_energy!\n\n\n\n\n\n\n\n\n\n\nCubicGrid\nMEDYAN.grididat\nMEDYAN.filter_grididat\nMEDYAN.centerof",
    "crumbs": [
      "Reference",
      "Table of Contents"
    ]
  },
  {
    "objectID": "reference/index.html#functions",
    "href": "reference/index.html#functions",
    "title": "Table of Contents",
    "section": "",
    "text": "src/sysdefs.jl\n\nMEDYAN.SysDef\ndef_diffusing_species!\ndef_fixed_species!\ndef_reaction!\ndef_fila_type!\ndef_fila_reaction!\ndef_fila_tip_reaction!\ndef_link_type!\n\n\n\n\n\nMEDYAN.Context\nCubicGrid\ndeepcopy, note: rng is shared\n\n\n\n\n\nBase.empty!\nload_snapshot!\nchem_adddiffusingcount!\nchem_addfixedcount!\nadddiffusingcount_rand!\nset_time!\nset_enable_collision!\nset_chem_boundary!\nset_mechboundary!\n\n\n\n\n\nmake_ball!\nremove_ball!\nupdate_ball!\n\n\n\n\n\nmake_fila!\nmake_fila_rand!\nremove_fila!\nupdate_fila_mono_state!\npolymerize_fila!\ndepolymerize_fila!\nsever_fila!\nnum_fila_types\nfila_type_name\nfila_typeid\nnum_fila\nfila_mono_ids\nfila_mono_states\nfila_num_nodes\nfila_node_mids\nfila_node_positions\nfila_tip_tags\nfila_num_unmin_ends\npick_rand_fila_mono_site\npick_rand_fila_tip_site\n\n\n\n\n\nmake_memb!\nmake_memb_sphere!\nmake_memb_rectangle!\n\n\n\n\n\nPlace\nFilaIdx\nFilaTipIdx\nFilaMonoIdx\nMembVertIdx\nAnchor\nBallIdx\nTag\ntag!\nmake_link!\nremove_link!\nupdate_link!\nmake_anchor!\nremove_anchor!\nupdate_anchor!\nnum_link_types\nlink_type_name\nlink_typeid\nget_all_links\nget_all_tags\ntag2links\nplace2links\ntag_exists\nplace_exists\nlink_exists\nlink2tags\ntag2place\nplace2tag\nhas_tag\nget_position\nnum_directions\nget_directions\nget_material_frame\nget_chem_state\nget_state\nget_bond_states\nget_bond_enabled\nget_reaction_enabled\nis_minimized\nget_link_mechanics\n\n\n\n\n\napply_chem_boundary!\nrun_chemistry!\nminimize_energy!",
    "crumbs": [
      "Reference",
      "Table of Contents"
    ]
  },
  {
    "objectID": "reference/index.html#utilities",
    "href": "reference/index.html#utilities",
    "title": "Table of Contents",
    "section": "",
    "text": "CubicGrid\nMEDYAN.grididat\nMEDYAN.filter_grididat\nMEDYAN.centerof",
    "crumbs": [
      "Reference",
      "Table of Contents"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Documentation for MEDYAN."
  },
  {
    "objectID": "index.html#warning-the-api-is-very-unstable-and-this-package-is-not-released-yet.",
    "href": "index.html#warning-the-api-is-very-unstable-and-this-package-is-not-released-yet.",
    "title": "MEDYAN.jl",
    "section": "Warning, the API is very unstable, and this package is not released yet.",
    "text": "Warning, the API is very unstable, and this package is not released yet.\nWelcome to Papoian Lab’s Mechanochemical Dynamics of Active Networks Julia package.\nThis is based on the C++ medyan command line tool also developed by the Papoian Lab.\nCopyright 2022, Papoian lab at the University of Maryland.\nThis code is distributed under the license found in this directory, license.txt."
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "MEDYAN.jl",
    "section": "Usage",
    "text": "Usage\nFirst install and run Julia https://julialang.org/downloads/\nNext download or clone this repository.\nFinally, to use MEDYAN.jl, in Julia run:\nusing Pkg; pkg\"dev &lt;path to repo&gt;/MEDYAN\"\nWhere &lt;path to repo&gt; should be replaced with a local or absolute path to the repo.\n\nTutorials\nReference"
  },
  {
    "objectID": "index.html#authors",
    "href": "index.html#authors",
    "title": "MEDYAN.jl",
    "section": "Authors",
    "text": "Authors\nActive developers:\n\n\n\nName\nEmail\n\n\n\n\nNathan Zimmerberg\nnzimmerb@umd.edu\n\n\nMengxin Gu\nmxgu1234@umd.edu\n\n\nPatrick Kelly\nptfk1677@umd.edu\n\n\n\nAll developers including developers of C++ medyan:\nGaregin Papoian (gpapoian@umd.edu), Konstantin Popov, James Komianos, Aravind Chandrasekaran, Qin Ni, Carlos Floyd, Haoran Ni, Nathan Zimmerberg, Joshua Lucker, Mengxin Gu, Patrick Kelly\nAll general correspondence about the code and its applications should be directed to Garegin Papoian. All developer and more specific code, installation, and usage correspondence should be directed to Active developers via email or the issue tracker."
  },
  {
    "objectID": "index.html#running-tests",
    "href": "index.html#running-tests",
    "title": "MEDYAN.jl",
    "section": "Running tests",
    "text": "Running tests\nIn shell:\njulia --project -e 'using Pkg; Pkg.instantiate(workspace=true)'\njulia --project=MEDYAN/test MEDYAN/test/runtests.jl\nYou can also include individual test files to run just those tests."
  },
  {
    "objectID": "index.html#sub-packages",
    "href": "index.html#sub-packages",
    "title": "MEDYAN.jl",
    "section": "Sub Packages",
    "text": "Sub Packages\nThere are a number of sub packages found in the root directory.\nFor example “MEDYAN2Vtk”, can be tested using the following shell commands:\njulia --project -e 'using Pkg; Pkg.instantiate(workspace=true)'\njulia --project=MEDYAN2Vtk/test MEDYAN2Vtk/test/runtests.jl\nTo use “MEDYAN2Vtk” package in a new environment in Julia run:\nusing Pkg; pkg\"dev &lt;path to repo&gt;/MEDYAN2Vtk\"\nIf the sub package depends on other sub packages or depends on MEDYAN, you may have to dev multiple paths."
  },
  {
    "objectID": "index.html#running-notebooks",
    "href": "index.html#running-notebooks",
    "title": "MEDYAN.jl",
    "section": "Running notebooks",
    "text": "Running notebooks\nTo run interactively in a Pluto Notebook, run the following shell commands:\njulia --project -e 'using Pkg; Pkg.instantiate(workspace=true)'\njulia --project=notebooks -e 'import Pluto; Pluto.run()'\nTo generate static html files, run the following shell commands:\njulia --project -e 'using Pkg; Pkg.instantiate(workspace=true)'\njulia --project=notebooks notebooks/runnotebooks.jl"
  },
  {
    "objectID": "index.html#editing-documentation",
    "href": "index.html#editing-documentation",
    "title": "MEDYAN.jl",
    "section": "Editing Documentation",
    "text": "Editing Documentation\nPreviewing docs requires Linux.\nRun the following to set up the environment and create a preview. Any changes to files in docs should auto update.\njulia --project -e 'using Pkg; Pkg.instantiate(workspace=true)'\n./docs/make.jl\nor\njulia --project -e 'using Pkg; Pkg.instantiate(workspace=true)'\njulia --project=docs docs/make.jl\nRun the following to refresh the docstrings for the site.\njulia --project -e 'using Pkg; Pkg.instantiate(workspace=true)'\njulia --project=docs docs/make-docstrings.jl"
  },
  {
    "objectID": "index.html#how-to-cite",
    "href": "index.html#how-to-cite",
    "title": "MEDYAN.jl",
    "section": "How to Cite",
    "text": "How to Cite\nIf you use MEDYAN.jl in your research, please cite the relevant papers. See CITATION.bib for BibTeX entries."
  },
  {
    "objectID": "docstrings.html",
    "href": "docstrings.html",
    "title": "Docstrings",
    "section": "",
    "text": "Order By\n      Default\n      \n        Title\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\n\n\n\n\n\n\nBase.:*\n\n\n\n\n\n\nBase.delete!\n\n\n\n\n\n\nBase.empty!\n\n\n\n\n\n\nBase.getindex\n\n\n\n\n\n\nBase.haskey\n\n\n\n\n\n\nBase.iterate\n\n\n\n\n\n\nBase.length\n\n\n\n\n\n\nBase.push!\n\n\n\n\n\n\nBase.setindex!\n\n\n\n\n\n\nMEDYAN.AgentNames\n\n\n\n\n\n\nMEDYAN.Anchor\n\n\n\n\n\n\nMEDYAN.AnyState\n\n\n\n\n\n\nMEDYAN.BallIdx\n\n\n\n\n\n\nMEDYAN.Boundary\n\n\n\n\n\n\nMEDYAN.Context\n\n\n\n\n\n\nMEDYAN.CubicGrid\n\n\n\n\n\n\nMEDYAN.FilaIdx\n\n\n\n\n\n\nMEDYAN.FilaMonoIdx\n\n\n\n\n\n\nMEDYAN.FilaTipIdx\n\n\n\n\n\n\nMEDYAN.FilamentEndSiteGeneral\n\n\n\n\n\n\nMEDYAN.FilamentMechParams\n\n\n\n\n\n\nMEDYAN.FilamentSiteGeneral\n\n\n\n\n\n\nMEDYAN.MembVertIdx\n\n\n\n\n\n\nMEDYAN.MembraneSiteDiffusing\n\n\n\n\n\n\nMEDYAN.MembraneSpeciesParams\n\n\n\n\n\n\nMEDYAN.SysDef\n\n\n\n\n\n\nMEDYAN.VertexName\n\n\n\n\n\n\nMEDYAN.adapt_membranes!\n\n\n\n\n\n\nMEDYAN.add_decimated_2mon_site!\n\n\n\n\n\n\nMEDYAN.add_diffusing_count!\n\n\n\n\n\n\nMEDYAN.add_diffusion_coeff!\n\n\n\n\n\n\nMEDYAN.add_filament_params!\n\n\n\n\n\n\nMEDYAN.add_membranesitereaction!\n\n\n\n\n\n\nMEDYAN.adddiffusingcount_rand!\n\n\n\n\n\n\nMEDYAN.addfilamentendsite!\n\n\n\n\n\n\nMEDYAN.addfilamentsite!\n\n\n\n\n\n\nMEDYAN.addmembranediffusingcount_rand!\n\n\n\n\n\n\nMEDYAN.addmembranesite!\n\n\n\n\n\n\nMEDYAN.addpossiblecadherinsite!\n\n\n\n\n\n\nMEDYAN.addreaction!\n\n\n\n\n\n\nMEDYAN.addreactioncallback!\n\n\n\n\n\n\nMEDYAN.anystate\n\n\n\n\n\n\nMEDYAN.apply_chem_boundary!\n\n\n\n\n\n\nMEDYAN.boundary_box\n\n\n\n\n\n\nMEDYAN.boundary_capsule\n\n\n\n\n\n\nMEDYAN.boundary_cylinder\n\n\n\n\n\n\nMEDYAN.boundary_plane\n\n\n\n\n\n\nMEDYAN.centerof\n\n\n\n\n\n\nMEDYAN.chem_adddiffusingcount!\n\n\n\n\n\n\nMEDYAN.chem_addfixedcount!\n\n\n\n\n\n\nMEDYAN.compute_all_membrane_geometry!_system\n\n\n\n\n\n\nMEDYAN.def_diffusing_species!\n\n\n\n\n\n\nMEDYAN.def_fila_reaction!\n\n\n\n\n\n\nMEDYAN.def_fila_tip_reaction!\n\n\n\n\n\n\nMEDYAN.def_fila_type!\n\n\n\n\n\n\nMEDYAN.def_fixed_species!\n\n\n\n\n\n\nMEDYAN.def_link_type!\n\n\n\n\n\n\nMEDYAN.def_reaction!\n\n\n\n\n\n\nMEDYAN.defer_chem_caching!\n\n\n\n\n\n\nMEDYAN.depolymerize_fila!\n\n\n\n\n\n\nMEDYAN.fila_mono_ids\n\n\n\n\n\n\nMEDYAN.fila_mono_states\n\n\n\n\n\n\nMEDYAN.fila_node_mids\n\n\n\n\n\n\nMEDYAN.fila_node_positions\n\n\n\n\n\n\nMEDYAN.fila_num_nodes\n\n\n\n\n\n\nMEDYAN.fila_num_unmin_ends\n\n\n\n\n\n\nMEDYAN.fila_tip_tags\n\n\n\n\n\n\nMEDYAN.fila_type_name\n\n\n\n\n\n\nMEDYAN.fila_typeid\n\n\n\n\n\n\nMEDYAN.filter_grididat\n\n\n\n\n\n\nMEDYAN.get_all_links\n\n\n\n\n\n\nMEDYAN.get_all_tags\n\n\n\n\n\n\nMEDYAN.get_bond_enabled\n\n\n\n\n\n\nMEDYAN.get_bond_states\n\n\n\n\n\n\nMEDYAN.get_chem_boundary_grid_spacing\n\n\n\n\n\n\nMEDYAN.get_chem_boundary_oversampling_factor\n\n\n\n\n\n\nMEDYAN.get_chem_boundary_tsdf!\n\n\n\n\n\n\nMEDYAN.get_chem_boundary_tsdf_actual_max_distance\n\n\n\n\n\n\nMEDYAN.get_chem_boundary_tsdf_max_distance\n\n\n\n\n\n\nMEDYAN.get_chem_state\n\n\n\n\n\n\nMEDYAN.get_directions\n\n\n\n\n\n\nMEDYAN.get_link_mechanics\n\n\n\n\n\n\nMEDYAN.get_material_frame\n\n\n\n\n\n\nMEDYAN.get_position\n\n\n\n\n\n\nMEDYAN.get_reaction_enabled\n\n\n\n\n\n\nMEDYAN.get_state\n\n\n\n\n\n\nMEDYAN.get_time\n\n\n\n\n\n\nMEDYAN.grididat\n\n\n\n\n\n\nMEDYAN.has_tag\n\n\n\n\n\n\nMEDYAN.is_chem_boundary_tsdf_cache_valid\n\n\n\n\n\n\nMEDYAN.is_chem_cache_valid\n\n\n\n\n\n\nMEDYAN.is_inside_chem_boundary!\n\n\n\n\n\n\nMEDYAN.is_minimized\n\n\n\n\n\n\nMEDYAN.link2tags\n\n\n\n\n\n\nMEDYAN.link_exists\n\n\n\n\n\n\nMEDYAN.link_type_name\n\n\n\n\n\n\nMEDYAN.link_typeid\n\n\n\n\n\n\nMEDYAN.load_snapshot!\n\n\n\n\n\n\nMEDYAN.make_anchor!\n\n\n\n\n\n\nMEDYAN.make_ball!\n\n\n\n\n\n\nMEDYAN.make_fila!\n\n\n\n\n\n\nMEDYAN.make_fila_rand!\n\n\n\n\n\n\nMEDYAN.make_link!\n\n\n\n\n\n\nMEDYAN.make_memb!\n\n\n\n\n\n\nMEDYAN.make_memb_rectangle!\n\n\n\n\n\n\nMEDYAN.make_memb_sphere!\n\n\n\n\n\n\nMEDYAN.minimize_energy!\n\n\n\n\n\n\nMEDYAN.num_directions\n\n\n\n\n\n\nMEDYAN.num_fila\n\n\n\n\n\n\nMEDYAN.num_fila_types\n\n\n\n\n\n\nMEDYAN.num_link_types\n\n\n\n\n\n\nMEDYAN.num_vertexwithstate\n\n\n\n\n\n\nMEDYAN.pick_rand_fila_mono_site\n\n\n\n\n\n\nMEDYAN.pick_rand_fila_tip_site\n\n\n\n\n\n\nMEDYAN.place2links\n\n\n\n\n\n\nMEDYAN.place2tag\n\n\n\n\n\n\nMEDYAN.place_exists\n\n\n\n\n\n\nMEDYAN.polymerize_fila!\n\n\n\n\n\n\nMEDYAN.randompoint\n\n\n\n\n\n\nMEDYAN.refresh_chem_cache!\n\n\n\n\n\n\nMEDYAN.remove_anchor!\n\n\n\n\n\n\nMEDYAN.remove_ball!\n\n\n\n\n\n\nMEDYAN.remove_fila!\n\n\n\n\n\n\nMEDYAN.remove_link!\n\n\n\n\n\n\nMEDYAN.resolve_all_filament_mesh_crossing!\n\n\n\n\n\n\nMEDYAN.run_chemistry!\n\n\n\n\n\n\nMEDYAN.set_chem_boundary!\n\n\n\n\n\n\nMEDYAN.set_chem_boundary_oversampling_factor!\n\n\n\n\n\n\nMEDYAN.set_chem_boundary_tsdf_max_distance!\n\n\n\n\n\n\nMEDYAN.set_enable_collision!\n\n\n\n\n\n\nMEDYAN.set_mechboundary!\n\n\n\n\n\n\nMEDYAN.set_time!\n\n\n\n\n\n\nMEDYAN.sever_fila!\n\n\n\n\n\n\nMEDYAN.tag!\n\n\n\n\n\n\nMEDYAN.tag2links\n\n\n\n\n\n\nMEDYAN.tag2place\n\n\n\n\n\n\nMEDYAN.tag_exists\n\n\n\n\n\n\nMEDYAN.update_anchor!\n\n\n\n\n\n\nMEDYAN.update_ball!\n\n\n\n\n\n\nMEDYAN.update_fila_mono_state!\n\n\n\n\n\n\nMEDYAN.update_link!\n\n\n\n\n\n\nsrc/auxprocs.jl\n\n\n\n\n\n\nsrc/boundary.jl\n\n\n\n\n\n\nsrc/context.jl\n\n\n\n\n\n\nsrc/filament/depolymerize_fila.jl\n\n\n\n\n\n\nsrc/filament/endsites.jl\n\n\n\n\n\n\nsrc/filament/functions.jl\n\n\n\n\n\n\nsrc/filament/make_fila.jl\n\n\n\n\n\n\nsrc/filament/make_fila_rand.jl\n\n\n\n\n\n\nsrc/filament/polymerize_fila.jl\n\n\n\n\n\n\nsrc/filament/remove_fila.jl\n\n\n\n\n\n\nsrc/filament/sever_fila.jl\n\n\n\n\n\n\nsrc/filament/sites.jl\n\n\n\n\n\n\nsrc/filament/structs.jl\n\n\n\n\n\n\nsrc/filament/update_fila_mono_state.jl\n\n\n\n\n\n\nsrc/grids.jl\n\n\n\n\n\n\nsrc/links/anchors.jl\n\n\n\n\n\n\nsrc/links/balls.jl\n\n\n\n\n\n\nsrc/links/link-chemistry.jl\n\n\n\n\n\n\nsrc/links/link-manager.jl\n\n\n\n\n\n\nsrc/links/place-types.jl\n\n\n\n\n\n\nsrc/links/places.jl\n\n\n\n\n\n\nsrc/membrane/make_memb.jl\n\n\n\n\n\n\nsrc/membrane/make_memb_rectangle.jl\n\n\n\n\n\n\nsrc/membrane/make_memb_sphere.jl\n\n\n\n\n\n\nsrc/membrane/membranesites.jl\n\n\n\n\n\n\nsrc/membrane/meshadapt.jl\n\n\n\n\n\n\nsrc/minimize_energy.jl\n\n\n\n\n\n\nsrc/sys_def-types.jl\n\n\n\n\n\n\nsrc/sys_def.jl\n\n\n\n\n\n\nsrc/trajectory-io/snapshot.jl\n\n\n\n\n\n\nsrc/util/math/cuboidslicing.jl\n\n\n\n\n\n\nsrc/util/stableindex.jl\n\n\n\n\n\n\nNo matching items",
    "crumbs": [
      "Reference",
      "Docstrings"
    ]
  },
  {
    "objectID": "tutorials/2rdme.html",
    "href": "tutorials/2rdme.html",
    "title": "2. Rock Paper Scissors Stochastic Reaction Diffusion",
    "section": "",
    "text": "Inspired by:\nhttps://www.youtube.com/watch?v=TORwMc2AaRE&t=0s\n\n\nOpen a julia REPL or jupyter notebook using the medyan-tutorial environment you created in tutorial 1.\nLoad MEDYAN with MEDYANVis for visualization\n\nusing MEDYAN\nusing MEDYANVis\nusing CairoMakie\nusing Random\nusing SmallZarrGroups\nRandom.seed!(1234);\n\n\n\n\nThe first step is to create a system definition (MEDYAN.SysDef).\nThis system will contain three diffusing species: Rock, Paper, and Scissors.\nWe create the species using def_diffusing_species!, which takes the species name and diffusion coefficient.\nAll units are based on nm, s, pN.\n\ns = MEDYAN.SysDef()\nD = 1E6 # nm²/s\ndef_diffusing_species!(s, :R; coeff=D) # Rock\ndef_diffusing_species!(s, :P; coeff=D) # Paper\ndef_diffusing_species!(s, :S; coeff=D) # Scissors\n\nMEDYAN.SysDef\n Diffusing species:\n  :R: 1.0e6 nm²/s\n  :P: 1.0e6 nm²/s\n  :S: 1.0e6 nm²/s\n\n\n\n\n\nPaper “beats” rock, scissors “beats” paper, rock “beats” scissors. In this simulation “beats” means convert to self type.\nIn this case because the reaction is between two diffusing species, it has units of nm³/s. You can think of this as the volume where if exactly one of each reactant existed the rate would be 1 per second.\ndef_reaction!\n\nrate = 50.0*(500.0^3) # nm³/s\ndef_reaction!(s, \"diffusing.P + diffusing.R --&gt; 2diffusing.P\";\n    base_rate=rate,\n    invvolumepower=1,\n)\ndef_reaction!(s, \"diffusing.S + diffusing.P --&gt; 2diffusing.S\";\n    base_rate=rate,\n    invvolumepower=1,\n)\ndef_reaction!(s, \"diffusing.R + diffusing.S --&gt; 2diffusing.R\";\n    base_rate=rate,\n    invvolumepower=1,\n)\n\nMEDYAN.SysDef\n Diffusing species:\n  :R: 1.0e6 nm²/s\n  :P: 1.0e6 nm²/s\n  :S: 1.0e6 nm²/s\n Chem voxel reactions without callbacks:\n  \"diffusing.P + diffusing.R --&gt; 2diffusing.P\" 6.25e9 nm³/s\n  \"diffusing.S + diffusing.P --&gt; 2diffusing.S\" 6.25e9 nm³/s\n  \"diffusing.R + diffusing.S --&gt; 2diffusing.R\" 6.25e9 nm³/s\n\n\n\n\n\nAll simulations run in a grid.\nThis is a box that contains the simulation.\nThe grid is composed of chemistry voxels, small cubes that can have different counts of the various diffusing species.\nCreate a 50 by 50 by 1 grid of 500 nm side length voxels.\n\nL = 50\ngrid = CubicGrid((L,L,1),500.0)\n\nCubicGrid([50, 50, 1], 500.0)\n\n\n\n\n\nThe Context is the object the handles the state of a running simulation.\nCreate a Context using s and grid\n\nc = MEDYAN.Context(s, grid)\n\nMEDYAN.Context at time 0.0s in MEDYAN.CubicGrid([50, 50, 1], 500.0)\n\n\n\n\n\nThe context starts empty.\nDistribute 2000 of each species randomly to the chem voxels by mutating the context.\nadddiffusingcount_rand!\n\nadddiffusingcount_rand!(c, s.diffusing.R, 2000)\nadddiffusingcount_rand!(c, s.diffusing.P, 2000)\nadddiffusingcount_rand!(c, s.diffusing.S, 2000)\n\n\n\n\nRun chemistry for 1.0s and visualize the results.\n\nvis = Visualizer()\nsetvisible!(vis[\"/Grid\"], false)\nsetvisible!(vis[\"/Axes\"], false)\nsetvisible!(vis[\"/Background\"], false)\n\nIf you open the visualizer in a browser with open(vis) and run the following you should get an animated version of below.\n\nfor i in 1:100\n    run_chemistry!(c, 0.01)\n    MEDYANVis.drawdiffusing!(vis[\"diffusing\"], c.grid, c.chemistryengine, s; size = 0.8)\n    sleep(0.02)\nend\n\n\n\n    \n    \n    \n    \n\n\n\n\n\nNext we will see how to plot quantities from the simulation.\nIf you want to analyze a trajectory in detail, or load a system state, one method is to use snapshots. For details see snapshot group reference\nMEDYAN.load_snapshot! can be used to reload snapshots, this is very useful for restarting simulations, or changing the simulation state in a different programming language, but not needed in this tutorial.\nSmallZarrGroups.jl can be used to save/load snapshot groups to/from disk, in zip files, or in directories.\nRun chemistry for another 1.0s and store a snapshot every 0.01s in a vector.\n\nusing SmallZarrGroups\nsnapshots = ZGroup[]\nfor i in 1:100\n    run_chemistry!(c, 0.01)\n    push!(snapshots, MEDYAN.snapshot(c))\nend\n\nNow that the simulation is done the results can be analyzed. For longer simulations, these snapshots should be saved to disk with for example:\nSmallZarrGroups.save_dir(\"snapshot$i.zarr.zip\",MEDYAN.snapshot(c))\nto avoid needed to rerun the simulation and to avoid using too much RAM.\n\ntotal_rocks = Int[]\ntotal_papers = Int[]\ntotal_scissors = Int[]\ntimes = Float64[]\nfor group in snapshots\n    totals = sum(collect(group[\"chem/dc\"]);dims=(2,3,4))\n    push!(times, attrs(group)[\"time (s)\"])\n    push!(total_rocks, totals[s.diffusing.R])\n    push!(total_papers, totals[s.diffusing.P])\n    push!(total_scissors, totals[s.diffusing.S])\nend\n\n\nfigure, axis, lineplot = lines(times, total_rocks; label=\"rock\")\nlines!(times, total_papers; label=\"paper\")\nlines!(times, total_scissors; label=\"scissors\")\nlines!(\n    times,\n    total_scissors.+total_papers.+total_rocks;\n    label=\"combined\")\naxislegend()\ncurrent_figure()\n\n\n\n\nIf you are using VSCode or Jupyter the figure will be displayed.\nIf you are using the REPL, save the figure as a PDF to view it.\nsave(\"tutorial2-plot.pdf\", current_figure())",
    "crumbs": [
      "Tutorials",
      "2. Rock Paper Scissors Stochastic Reaction Diffusion"
    ]
  },
  {
    "objectID": "tutorials/2rdme.html#setup",
    "href": "tutorials/2rdme.html#setup",
    "title": "2. Rock Paper Scissors Stochastic Reaction Diffusion",
    "section": "",
    "text": "Open a julia REPL or jupyter notebook using the medyan-tutorial environment you created in tutorial 1.\nLoad MEDYAN with MEDYANVis for visualization\n\nusing MEDYAN\nusing MEDYANVis\nusing CairoMakie\nusing Random\nusing SmallZarrGroups\nRandom.seed!(1234);",
    "crumbs": [
      "Tutorials",
      "2. Rock Paper Scissors Stochastic Reaction Diffusion"
    ]
  },
  {
    "objectID": "tutorials/2rdme.html#defining-system",
    "href": "tutorials/2rdme.html#defining-system",
    "title": "2. Rock Paper Scissors Stochastic Reaction Diffusion",
    "section": "",
    "text": "The first step is to create a system definition (MEDYAN.SysDef).\nThis system will contain three diffusing species: Rock, Paper, and Scissors.\nWe create the species using def_diffusing_species!, which takes the species name and diffusion coefficient.\nAll units are based on nm, s, pN.\n\ns = MEDYAN.SysDef()\nD = 1E6 # nm²/s\ndef_diffusing_species!(s, :R; coeff=D) # Rock\ndef_diffusing_species!(s, :P; coeff=D) # Paper\ndef_diffusing_species!(s, :S; coeff=D) # Scissors\n\nMEDYAN.SysDef\n Diffusing species:\n  :R: 1.0e6 nm²/s\n  :P: 1.0e6 nm²/s\n  :S: 1.0e6 nm²/s",
    "crumbs": [
      "Tutorials",
      "2. Rock Paper Scissors Stochastic Reaction Diffusion"
    ]
  },
  {
    "objectID": "tutorials/2rdme.html#adding-reactions",
    "href": "tutorials/2rdme.html#adding-reactions",
    "title": "2. Rock Paper Scissors Stochastic Reaction Diffusion",
    "section": "",
    "text": "Paper “beats” rock, scissors “beats” paper, rock “beats” scissors. In this simulation “beats” means convert to self type.\nIn this case because the reaction is between two diffusing species, it has units of nm³/s. You can think of this as the volume where if exactly one of each reactant existed the rate would be 1 per second.\ndef_reaction!\n\nrate = 50.0*(500.0^3) # nm³/s\ndef_reaction!(s, \"diffusing.P + diffusing.R --&gt; 2diffusing.P\";\n    base_rate=rate,\n    invvolumepower=1,\n)\ndef_reaction!(s, \"diffusing.S + diffusing.P --&gt; 2diffusing.S\";\n    base_rate=rate,\n    invvolumepower=1,\n)\ndef_reaction!(s, \"diffusing.R + diffusing.S --&gt; 2diffusing.R\";\n    base_rate=rate,\n    invvolumepower=1,\n)\n\nMEDYAN.SysDef\n Diffusing species:\n  :R: 1.0e6 nm²/s\n  :P: 1.0e6 nm²/s\n  :S: 1.0e6 nm²/s\n Chem voxel reactions without callbacks:\n  \"diffusing.P + diffusing.R --&gt; 2diffusing.P\" 6.25e9 nm³/s\n  \"diffusing.S + diffusing.P --&gt; 2diffusing.S\" 6.25e9 nm³/s\n  \"diffusing.R + diffusing.S --&gt; 2diffusing.R\" 6.25e9 nm³/s",
    "crumbs": [
      "Tutorials",
      "2. Rock Paper Scissors Stochastic Reaction Diffusion"
    ]
  },
  {
    "objectID": "tutorials/2rdme.html#creating-a-grid",
    "href": "tutorials/2rdme.html#creating-a-grid",
    "title": "2. Rock Paper Scissors Stochastic Reaction Diffusion",
    "section": "",
    "text": "All simulations run in a grid.\nThis is a box that contains the simulation.\nThe grid is composed of chemistry voxels, small cubes that can have different counts of the various diffusing species.\nCreate a 50 by 50 by 1 grid of 500 nm side length voxels.\n\nL = 50\ngrid = CubicGrid((L,L,1),500.0)\n\nCubicGrid([50, 50, 1], 500.0)",
    "crumbs": [
      "Tutorials",
      "2. Rock Paper Scissors Stochastic Reaction Diffusion"
    ]
  },
  {
    "objectID": "tutorials/2rdme.html#creating-a-context",
    "href": "tutorials/2rdme.html#creating-a-context",
    "title": "2. Rock Paper Scissors Stochastic Reaction Diffusion",
    "section": "",
    "text": "The Context is the object the handles the state of a running simulation.\nCreate a Context using s and grid\n\nc = MEDYAN.Context(s, grid)\n\nMEDYAN.Context at time 0.0s in MEDYAN.CubicGrid([50, 50, 1], 500.0)",
    "crumbs": [
      "Tutorials",
      "2. Rock Paper Scissors Stochastic Reaction Diffusion"
    ]
  },
  {
    "objectID": "tutorials/2rdme.html#add-agents-to-the-context",
    "href": "tutorials/2rdme.html#add-agents-to-the-context",
    "title": "2. Rock Paper Scissors Stochastic Reaction Diffusion",
    "section": "",
    "text": "The context starts empty.\nDistribute 2000 of each species randomly to the chem voxels by mutating the context.\nadddiffusingcount_rand!\n\nadddiffusingcount_rand!(c, s.diffusing.R, 2000)\nadddiffusingcount_rand!(c, s.diffusing.P, 2000)\nadddiffusingcount_rand!(c, s.diffusing.S, 2000)",
    "crumbs": [
      "Tutorials",
      "2. Rock Paper Scissors Stochastic Reaction Diffusion"
    ]
  },
  {
    "objectID": "tutorials/2rdme.html#run-chemistry",
    "href": "tutorials/2rdme.html#run-chemistry",
    "title": "2. Rock Paper Scissors Stochastic Reaction Diffusion",
    "section": "",
    "text": "Run chemistry for 1.0s and visualize the results.\n\nvis = Visualizer()\nsetvisible!(vis[\"/Grid\"], false)\nsetvisible!(vis[\"/Axes\"], false)\nsetvisible!(vis[\"/Background\"], false)\n\nIf you open the visualizer in a browser with open(vis) and run the following you should get an animated version of below.\n\nfor i in 1:100\n    run_chemistry!(c, 0.01)\n    MEDYANVis.drawdiffusing!(vis[\"diffusing\"], c.grid, c.chemistryengine, s; size = 0.8)\n    sleep(0.02)\nend",
    "crumbs": [
      "Tutorials",
      "2. Rock Paper Scissors Stochastic Reaction Diffusion"
    ]
  },
  {
    "objectID": "tutorials/2rdme.html#snapshots-and-plotting",
    "href": "tutorials/2rdme.html#snapshots-and-plotting",
    "title": "2. Rock Paper Scissors Stochastic Reaction Diffusion",
    "section": "",
    "text": "Next we will see how to plot quantities from the simulation.\nIf you want to analyze a trajectory in detail, or load a system state, one method is to use snapshots. For details see snapshot group reference\nMEDYAN.load_snapshot! can be used to reload snapshots, this is very useful for restarting simulations, or changing the simulation state in a different programming language, but not needed in this tutorial.\nSmallZarrGroups.jl can be used to save/load snapshot groups to/from disk, in zip files, or in directories.\nRun chemistry for another 1.0s and store a snapshot every 0.01s in a vector.\n\nusing SmallZarrGroups\nsnapshots = ZGroup[]\nfor i in 1:100\n    run_chemistry!(c, 0.01)\n    push!(snapshots, MEDYAN.snapshot(c))\nend\n\nNow that the simulation is done the results can be analyzed. For longer simulations, these snapshots should be saved to disk with for example:\nSmallZarrGroups.save_dir(\"snapshot$i.zarr.zip\",MEDYAN.snapshot(c))\nto avoid needed to rerun the simulation and to avoid using too much RAM.\n\ntotal_rocks = Int[]\ntotal_papers = Int[]\ntotal_scissors = Int[]\ntimes = Float64[]\nfor group in snapshots\n    totals = sum(collect(group[\"chem/dc\"]);dims=(2,3,4))\n    push!(times, attrs(group)[\"time (s)\"])\n    push!(total_rocks, totals[s.diffusing.R])\n    push!(total_papers, totals[s.diffusing.P])\n    push!(total_scissors, totals[s.diffusing.S])\nend\n\n\nfigure, axis, lineplot = lines(times, total_rocks; label=\"rock\")\nlines!(times, total_papers; label=\"paper\")\nlines!(times, total_scissors; label=\"scissors\")\nlines!(\n    times,\n    total_scissors.+total_papers.+total_rocks;\n    label=\"combined\")\naxislegend()\ncurrent_figure()\n\n\n\n\nIf you are using VSCode or Jupyter the figure will be displayed.\nIf you are using the REPL, save the figure as a PDF to view it.\nsave(\"tutorial2-plot.pdf\", current_figure())",
    "crumbs": [
      "Tutorials",
      "2. Rock Paper Scissors Stochastic Reaction Diffusion"
    ]
  },
  {
    "objectID": "tutorials/1install.html",
    "href": "tutorials/1install.html",
    "title": "1. Installing MEDYAN.jl",
    "section": "",
    "text": "MEDYAN.jl is a julia package so first install the julia programming language.\nThis tutorial was generated using:\n\n\nJulia Version 1.12.5\nCommit 5fe89b8ddc1 (2026-02-09 16:05 UTC)\nBuild Info:\n  Official https://julialang.org release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 16 × Intel(R) Core(TM) i7-10700KF CPU @ 3.80GHz\n  WORD_SIZE: 64\n  LLVM: libLLVM-18.1.7 (ORCJIT, skylake)\n  GC: Built with stock GC\nThreads: 1 default, 1 interactive, 1 GC (on 16 virtual cores)\nEnvironment:\n  LD_LIBRARY_PATH = /home/gh-actions1/actions-runner2/_work/_tool/julia/1.12.5/x64/bin/../lib/julia:/home/gh-actions1/actions-runner2/_work/_tool/julia/1.12.5/x64/bin/../lib\n  JULIA_PROJECT = @.\n  JULIA_LOAD_PATH = @:@stdlib\n\n\nThe tutorials should work on newer versions of julia, and on MacOS and Windows, please create an issue if you have a problem or question.\nJulia can be installed with juliaup.\nYou can also download julia here.\nDo not install julia using apt install julia or module load julia, as these don’t have a recent version of julia.\nAfter installing julia, open the REPL with the julia command in terminal.\n\n\n\nDownload the exact julia environment used to generate the tutorials.\nClick to Download\nNext extract this zip file and cd into the extracted directory.\nNext add a copy of MEDYAN to the directory.\nNow run:\njulia --project -e 'import Pkg; Pkg.instantiate()'\nTo start the julia REPL in the correct environment to run the tutorials, use:\njulia --project\nFrom inside the medyan-tutorial directory.\nYou can also save julia files in this directory and use the VSCode julia extension to set the environment, and run code blocks, if you prefer that over the REPL.\nhttps://code.visualstudio.com/docs/languages/julia\n\n\n\nThese tests may take a few minutes to run.\njulia lib/MEDYAN/test/install-deps.jl\njulia --project=lib/MEDYAN/test lib/MEDYAN/test/runtests.jl\nIf you have any errors or failing tests create an issue",
    "crumbs": [
      "Tutorials",
      "1. Installing MEDYAN.jl"
    ]
  },
  {
    "objectID": "tutorials/1install.html#install-julia",
    "href": "tutorials/1install.html#install-julia",
    "title": "1. Installing MEDYAN.jl",
    "section": "",
    "text": "MEDYAN.jl is a julia package so first install the julia programming language.\nThis tutorial was generated using:\n\n\nJulia Version 1.12.5\nCommit 5fe89b8ddc1 (2026-02-09 16:05 UTC)\nBuild Info:\n  Official https://julialang.org release\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 16 × Intel(R) Core(TM) i7-10700KF CPU @ 3.80GHz\n  WORD_SIZE: 64\n  LLVM: libLLVM-18.1.7 (ORCJIT, skylake)\n  GC: Built with stock GC\nThreads: 1 default, 1 interactive, 1 GC (on 16 virtual cores)\nEnvironment:\n  LD_LIBRARY_PATH = /home/gh-actions1/actions-runner2/_work/_tool/julia/1.12.5/x64/bin/../lib/julia:/home/gh-actions1/actions-runner2/_work/_tool/julia/1.12.5/x64/bin/../lib\n  JULIA_PROJECT = @.\n  JULIA_LOAD_PATH = @:@stdlib\n\n\nThe tutorials should work on newer versions of julia, and on MacOS and Windows, please create an issue if you have a problem or question.\nJulia can be installed with juliaup.\nYou can also download julia here.\nDo not install julia using apt install julia or module load julia, as these don’t have a recent version of julia.\nAfter installing julia, open the REPL with the julia command in terminal.",
    "crumbs": [
      "Tutorials",
      "1. Installing MEDYAN.jl"
    ]
  },
  {
    "objectID": "tutorials/1install.html#install-packages-needed-for-tutorials",
    "href": "tutorials/1install.html#install-packages-needed-for-tutorials",
    "title": "1. Installing MEDYAN.jl",
    "section": "",
    "text": "Download the exact julia environment used to generate the tutorials.\nClick to Download\nNext extract this zip file and cd into the extracted directory.\nNext add a copy of MEDYAN to the directory.\nNow run:\njulia --project -e 'import Pkg; Pkg.instantiate()'\nTo start the julia REPL in the correct environment to run the tutorials, use:\njulia --project\nFrom inside the medyan-tutorial directory.\nYou can also save julia files in this directory and use the VSCode julia extension to set the environment, and run code blocks, if you prefer that over the REPL.\nhttps://code.visualstudio.com/docs/languages/julia",
    "crumbs": [
      "Tutorials",
      "1. Installing MEDYAN.jl"
    ]
  },
  {
    "objectID": "tutorials/1install.html#running-tests",
    "href": "tutorials/1install.html#running-tests",
    "title": "1. Installing MEDYAN.jl",
    "section": "",
    "text": "These tests may take a few minutes to run.\njulia lib/MEDYAN/test/install-deps.jl\njulia --project=lib/MEDYAN/test lib/MEDYAN/test/runtests.jl\nIf you have any errors or failing tests create an issue",
    "crumbs": [
      "Tutorials",
      "1. Installing MEDYAN.jl"
    ]
  },
  {
    "objectID": "tutorials/3treadmill.html",
    "href": "tutorials/3treadmill.html",
    "title": "3. Actin Treadmilling",
    "section": "",
    "text": "Using reactions and rates from\nDitlev JA, Vacanti NM, Novak IL, Loew LM. An open model of actin dendritic nucleation. Biophys J. 2009;96(9):3529-3542. doi:10.1016/j.bpj.2009.01.037\nThis example doesn’t have any of the actin binding proteins, or filament severing or annealing.\n\n\nOpen a julia REPL or jupyter notebook using the medyan-tutorial environment you created in tutorial 1.\nLoad MEDYAN with MeshCat for visualization\n\nusing MEDYAN\nusing MEDYANVis\nusing CairoMakie\nusing Random\nusing SmallZarrGroups\nusing StaticArrays\nusing LinearAlgebra\nRandom.seed!(1234);\n\n\n\n\nThe first step is constructing a MEDYAN.SysDef object, then mutating it to add species, filament types, reactions, and callbacks.\n\ns = MEDYAN.SysDef()\n\nMEDYAN.SysDef\n\n\nAdd diffusing species with their diffusion coefficients. All units are based on nm, s, pN.\ndef_diffusing_species!\n\nDGActin = 5E6 # nm²/s\ndef_diffusing_species!(s, :GA; coeff=DGActin)    # G-Actin with no bound nucleotide\ndef_diffusing_species!(s, :GAD; coeff=DGActin)   # G-Actin in the ADP form\ndef_diffusing_species!(s, :GADPi; coeff=DGActin) # G-Actin in the ADP Pi form\ndef_diffusing_species!(s, :GAT; coeff=DGActin)   # G-Actin in the ATP form\n\nMEDYAN.SysDef\n Diffusing species:\n  :GA: 5.0e6 nm²/s\n  :GAD: 5.0e6 nm²/s\n  :GADPi: 5.0e6 nm²/s\n  :GAT: 5.0e6 nm²/s\n\n\nAdd the actin filament type with its monomer states and mechanical parameters.\ndef_fila_type!\n\ndef_fila_type!(s; \n    name=:actin, \n    mono_states=[\n        # Monomer states\n        :FAD,       # F-Actin in the ADP form\n        :FADPi,     # F-Actin in the ADP Pi form\n        :FAT,       # F-Actin in the ATP form\n        :BarbedD,   # Barbed end in the ADP form\n        :BarbedDPi, # Barbed end in the ADP Pi form\n        :BarbedT,   # Barbed end in the ATP form\n        :PointedD,  # Pointed end in the ADP form\n        :PointedDPi, # Pointed end in the ADP Pi form\n        :PointedT,  # Pointed end in the ATP form\n    ],\n    param=MEDYAN.ACTIN_FIL_PARAMS\n)\n\nMEDYAN.SysDef\n Diffusing species:\n  :GA: 5.0e6 nm²/s\n  :GAD: 5.0e6 nm²/s\n  :GADPi: 5.0e6 nm²/s\n  :GAT: 5.0e6 nm²/s\n Filaments:\n  :actin:\n   monomer states: [:FAD, :FADPi, :FAT, :BarbedD, :BarbedDPi, :BarbedT, :PointedD, :PointedDPi, :PointedT]\n   params: MEDYAN.FilamentMechParams(3.0, 2.7, 4000.0, 26880.0, NaN, NaN, 40, 1666.6666666666667, 1)\n\n\nAdd reactions between diffusing species. These represent G-Actin interacting with ATP ADP and Pi.\ndef_reaction!\n\n# Assume ATP, Pi, and ADP concentrations are fixed\nATP = 10000.0 * MEDYAN.μM⁻¹_per_nm³\nPi = 2000.0 * MEDYAN.μM⁻¹_per_nm³\nADP = 2000.0 * MEDYAN.μM⁻¹_per_nm³\nKfGATPoint  = 1.3/MEDYAN.μM⁻¹_per_nm³\nKrGATPoint  = 0.8\nKfGADPoint  = 0.16/MEDYAN.μM⁻¹_per_nm³\nKrGADPoint  = 0.3\nKfGATBarb   = 10.0/MEDYAN.μM⁻¹_per_nm³\nKrGATBarb   = 1.0\nKfGADBarb   = 2.5/MEDYAN.μM⁻¹_per_nm³\nKrGADBarb   = 4.25\nKfPiRelease = 0.0026\nKrPiRelease = 5.20E-6/MEDYAN.μM⁻¹_per_nm³\n\n# 100\ndef_reaction!(s, \"diffusing.GADPi --&gt; diffusing.GAD\";\n    base_rate=0.0312,\n)\ndef_reaction!(s, \"diffusing.GAD --&gt; diffusing.GADPi\";\n    base_rate=KrPiRelease*Pi,\n)\n\n# 104\ndef_reaction!(s, \"diffusing.GA --&gt; diffusing.GAT\";\n    base_rate=1.7/MEDYAN.μM⁻¹_per_nm³*ATP,\n)\ndef_reaction!(s, \"diffusing.GAT --&gt; diffusing.GA\";\n    base_rate=0.011,\n)\n\n# 109\ndef_reaction!(s, \"diffusing.GA --&gt; diffusing.GAD\";\n    base_rate=0.9/MEDYAN.μM⁻¹_per_nm³*ADP,\n)\ndef_reaction!(s, \"diffusing.GAD --&gt; diffusing.GA\";\n    base_rate=0.071,\n)\n\nMEDYAN.SysDef\n Diffusing species:\n  :GA: 5.0e6 nm²/s\n  :GAD: 5.0e6 nm²/s\n  :GADPi: 5.0e6 nm²/s\n  :GAT: 5.0e6 nm²/s\n Filaments:\n  :actin:\n   monomer states: [:FAD, :FADPi, :FAT, :BarbedD, :BarbedDPi, :BarbedT, :PointedD, :PointedDPi, :PointedT]\n   params: MEDYAN.FilamentMechParams(3.0, 2.7, 4000.0, 26880.0, NaN, NaN, 40, 1666.6666666666667, 1)\n Chem voxel reactions without callbacks:\n  \"diffusing.GADPi --&gt; diffusing.GAD\" 0.0312 1/s\n  \"diffusing.GAD --&gt; diffusing.GADPi\" 0.0104 1/s\n  \"diffusing.GA --&gt; diffusing.GAT\" 17000.0 1/s\n  \"diffusing.GAT --&gt; diffusing.GA\" 0.011 1/s\n  \"diffusing.GA --&gt; diffusing.GAD\" 1799.9999999999998 1/s\n  \"diffusing.GAD --&gt; diffusing.GA\" 0.071 1/s\n\n\nNext add filament reactions.\nThe barbed end is the plus end and the pointed end is the minus end.\n\nmonomerspacing=2.7 # nm\n\n\nnucleotide_states = (\"T\", \"DPi\", \"D\")\n\n# Barbed end polymerization and depolymerization\nbarbed_rates = [\n    (\"T\", KfGATBarb, KrGATBarb),\n    (\"DPi\", KfGATBarb, KrGATBarb),\n    (\"D\", KfGADBarb, KrGADBarb),\n]\nfor (new_nuc, forward_rate, reverse_rate) in barbed_rates\n    for base_nuc in nucleotide_states\n        def_fila_tip_reaction!(s;\n            fila_type = :actin,\n            name = Symbol(\"f\", \"GA\", new_nuc, \"_to_Barbed\", base_nuc),\n            is_minus_end = false,\n            match = [Symbol(\"Barbed\", base_nuc)],\n            new = [Symbol(\"FA\", base_nuc), Symbol(\"Barbed\", new_nuc)],\n            spacing = monomerspacing,\n            net_stoich = [Symbol(\"GA\", new_nuc) =&gt; -1],\n            base_rate = forward_rate,\n            invvolumepower = 1,\n            reactants_extra = \"diffusing.GA\"*new_nuc,\n        )\n        def_fila_tip_reaction!(s;\n            fila_type = :actin,\n            name = Symbol(\"r\", \"GA\", new_nuc, \"_to_Barbed\", base_nuc),\n            is_minus_end = false,\n            match = [Symbol(\"FA\", base_nuc), Symbol(\"Barbed\", new_nuc)],\n            new = [Symbol(\"Barbed\", base_nuc)],\n            spacing = 0.0,\n            net_stoich = [Symbol(\"GA\", new_nuc) =&gt; 1],\n            base_rate = reverse_rate,\n        )\n    end\nend\n\n# Pointed end polymerization and depolymerization\npointed_rates = [\n    (\"T\", KfGATPoint, KrGATPoint),\n    (\"DPi\", KfGATPoint, KrGATPoint),\n    (\"D\", KfGADPoint, KrGADPoint),\n]\nfor (new_nuc, forward_rate, reverse_rate) in pointed_rates\n    for base_nuc in nucleotide_states\n        def_fila_tip_reaction!(s;\n            fila_type = :actin,\n            name = Symbol(\"f\", \"GA\", new_nuc, \"_to_Pointed\", base_nuc),\n            is_minus_end = true,\n            match = [Symbol(\"Pointed\", base_nuc)],\n            new = [Symbol(\"Pointed\", new_nuc), Symbol(\"FA\", base_nuc)],\n            spacing = monomerspacing,\n            net_stoich = [Symbol(\"GA\", new_nuc) =&gt; -1],\n            base_rate = forward_rate,\n            invvolumepower = 1,\n            reactants_extra = \"diffusing.GA\"*new_nuc,\n        )\n        def_fila_tip_reaction!(s;\n            fila_type = :actin,\n            name = Symbol(\"r\", \"GA\", new_nuc, \"_to_Pointed\", base_nuc),\n            is_minus_end = true,\n            match = [Symbol(\"Pointed\", new_nuc), Symbol(\"FA\", base_nuc)],\n            new = [Symbol(\"Pointed\", base_nuc)],\n            spacing = 0.0,\n            net_stoich = [Symbol(\"GA\", new_nuc) =&gt; 1],\n            base_rate = reverse_rate,\n        )\n    end\nend\n\n# Filament ATP hydrolysis and Pi Dissociation\nfor monomer_state in (\"FA\", \"Barbed\", \"Pointed\")\n    def_fila_reaction!(s;\n        fila_type = :actin,\n        name = Symbol(monomer_state, \"T_to_\", monomer_state, \"DPi\"),\n        match = [Symbol(monomer_state, \"T\")],\n        new = [Symbol(monomer_state, \"DPi\")],\n        base_rate = 0.3,\n    )\n    def_fila_reaction!(s;\n        fila_type = :actin,\n        name = Symbol(monomer_state, \"DPi_to_\", monomer_state, \"D\"),\n        match = [Symbol(monomer_state, \"DPi\")],\n        new = [Symbol(monomer_state, \"D\")],\n        base_rate = KfPiRelease,\n    )\n    def_fila_reaction!(s;\n        fila_type = :actin,\n        name = Symbol(monomer_state, \"D_to_\", monomer_state, \"DPi\"),\n        match = [Symbol(monomer_state, \"D\")],\n        new = [Symbol(monomer_state, \"DPi\")],\n        base_rate = KrPiRelease*Pi,\n    )\nend\ns\n\nMEDYAN.SysDef\n Diffusing species:\n  :GA: 5.0e6 nm²/s\n  :GAD: 5.0e6 nm²/s\n  :GADPi: 5.0e6 nm²/s\n  :GAT: 5.0e6 nm²/s\n Filaments:\n  :actin:\n   monomer states: [:FAD, :FADPi, :FAT, :BarbedD, :BarbedDPi, :BarbedT, :PointedD, :PointedDPi, :PointedT]\n   params: MEDYAN.FilamentMechParams(3.0, 2.7, 4000.0, 26880.0, NaN, NaN, 40, 1666.6666666666667, 1)\n   filament sites:\n    :FAT_to_FADPi: match=[:FAT]\n    :FADPi_to_FAD: match=[:FADPi]\n    :FAD_to_FADPi: match=[:FAD]\n    :BarbedT_to_BarbedDPi: match=[:BarbedT]\n    :BarbedDPi_to_BarbedD: match=[:BarbedDPi]\n    :BarbedD_to_BarbedDPi: match=[:BarbedD]\n    :PointedT_to_PointedDPi: match=[:PointedT]\n    :PointedDPi_to_PointedD: match=[:PointedDPi]\n    :PointedD_to_PointedDPi: match=[:PointedD]\n   filament end sites:\n    :fGAT_to_BarbedT: + end, match=[:BarbedT], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_BarbedT: + end, match=[:FAT, :BarbedT]\n    :fGAT_to_BarbedDPi: + end, match=[:BarbedDPi], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_BarbedDPi: + end, match=[:FADPi, :BarbedT]\n    :fGAT_to_BarbedD: + end, match=[:BarbedD], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_BarbedD: + end, match=[:FAD, :BarbedT]\n    :fGADPi_to_BarbedT: + end, match=[:BarbedT], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_BarbedT: + end, match=[:FAT, :BarbedDPi]\n    :fGADPi_to_BarbedDPi: + end, match=[:BarbedDPi], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_BarbedDPi: + end, match=[:FADPi, :BarbedDPi]\n    :fGADPi_to_BarbedD: + end, match=[:BarbedD], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_BarbedD: + end, match=[:FAD, :BarbedDPi]\n    :fGAD_to_BarbedT: + end, match=[:BarbedT], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_BarbedT: + end, match=[:FAT, :BarbedD]\n    :fGAD_to_BarbedDPi: + end, match=[:BarbedDPi], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_BarbedDPi: + end, match=[:FADPi, :BarbedD]\n    :fGAD_to_BarbedD: + end, match=[:BarbedD], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_BarbedD: + end, match=[:FAD, :BarbedD]\n    :fGAT_to_PointedT: - end, match=[:PointedT], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_PointedT: - end, match=[:PointedT, :FAT]\n    :fGAT_to_PointedDPi: - end, match=[:PointedDPi], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_PointedDPi: - end, match=[:PointedT, :FADPi]\n    :fGAT_to_PointedD: - end, match=[:PointedD], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_PointedD: - end, match=[:PointedT, :FAD]\n    :fGADPi_to_PointedT: - end, match=[:PointedT], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_PointedT: - end, match=[:PointedDPi, :FAT]\n    :fGADPi_to_PointedDPi: - end, match=[:PointedDPi], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_PointedDPi: - end, match=[:PointedDPi, :FADPi]\n    :fGADPi_to_PointedD: - end, match=[:PointedD], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_PointedD: - end, match=[:PointedDPi, :FAD]\n    :fGAD_to_PointedT: - end, match=[:PointedT], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_PointedT: - end, match=[:PointedD, :FAT]\n    :fGAD_to_PointedDPi: - end, match=[:PointedDPi], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_PointedDPi: - end, match=[:PointedD, :FADPi]\n    :fGAD_to_PointedD: - end, match=[:PointedD], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_PointedD: - end, match=[:PointedD, :FAD]\n Chem voxel reactions with callbacks:\n  1. \"filamentsite.actin.PointedD_to_PointedDPi --&gt; filamentsite.actin.PointedD_to_PointedDPi\" 0.0104 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:PointedD_to_PointedDPi, center=1, new_states=[:PointedDPi])\n  2. \"filamentsite.actin.PointedDPi_to_PointedD --&gt; filamentsite.actin.PointedDPi_to_PointedD\" 0.0026 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:PointedDPi_to_PointedD, center=1, new_states=[:PointedD])\n  3. \"filamentsite.actin.PointedT_to_PointedDPi --&gt; filamentsite.actin.PointedT_to_PointedDPi\" 0.3 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:PointedT_to_PointedDPi, center=1, new_states=[:PointedDPi])\n  4. \"filamentsite.actin.BarbedD_to_BarbedDPi --&gt; filamentsite.actin.BarbedD_to_BarbedDPi\" 0.0104 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:BarbedD_to_BarbedDPi, center=1, new_states=[:BarbedDPi])\n  5. \"filamentsite.actin.BarbedDPi_to_BarbedD --&gt; filamentsite.actin.BarbedDPi_to_BarbedD\" 0.0026 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:BarbedDPi_to_BarbedD, center=1, new_states=[:BarbedD])\n  6. \"filamentsite.actin.BarbedT_to_BarbedDPi --&gt; filamentsite.actin.BarbedT_to_BarbedDPi\" 0.3 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:BarbedT_to_BarbedDPi, center=1, new_states=[:BarbedDPi])\n  7. \"filamentsite.actin.FAD_to_FADPi --&gt; filamentsite.actin.FAD_to_FADPi\" 0.0104 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:FAD_to_FADPi, center=1, new_states=[:FADPi])\n  8. \"filamentsite.actin.FADPi_to_FAD --&gt; filamentsite.actin.FADPi_to_FAD\" 0.0026 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:FADPi_to_FAD, center=1, new_states=[:FAD])\n  9. \"filamentsite.actin.FAT_to_FADPi --&gt; filamentsite.actin.FAT_to_FADPi\" 0.3 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:FAT_to_FADPi, center=1, new_states=[:FADPi])\n  10. \"filamentendsite.actin.rGAD_to_PointedD --&gt; filamentendsite.actin.rGAD_to_PointedD\" 0.3 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_PointedD, depolymerize=1, new_states=[:PointedD], diffusing_net_stoich=[:GAD =&gt; 1])\n  11. \"diffusing.GAD + filamentendsite.actin.fGAD_to_PointedD --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_PointedD\" 265686.2507478155 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_PointedD, polymerize=1, new_states=[:PointedD, :FAD], diffusing_net_stoich=[:GAD =&gt; -1])\n  12. \"filamentendsite.actin.rGAD_to_PointedDPi --&gt; filamentendsite.actin.rGAD_to_PointedDPi\" 0.3 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_PointedDPi, depolymerize=1, new_states=[:PointedDPi], diffusing_net_stoich=[:GAD =&gt; 1])\n  13. \"diffusing.GAD + filamentendsite.actin.fGAD_to_PointedDPi --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_PointedDPi\" 265686.2507478155 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_PointedDPi, polymerize=1, new_states=[:PointedD, :FADPi], diffusing_net_stoich=[:GAD =&gt; -1])\n  14. \"filamentendsite.actin.rGAD_to_PointedT --&gt; filamentendsite.actin.rGAD_to_PointedT\" 0.3 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_PointedT, depolymerize=1, new_states=[:PointedT], diffusing_net_stoich=[:GAD =&gt; 1])\n  15. \"diffusing.GAD + filamentendsite.actin.fGAD_to_PointedT --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_PointedT\" 265686.2507478155 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_PointedT, polymerize=1, new_states=[:PointedD, :FAT], diffusing_net_stoich=[:GAD =&gt; -1])\n  16. \"filamentendsite.actin.rGADPi_to_PointedD --&gt; filamentendsite.actin.rGADPi_to_PointedD\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_PointedD, depolymerize=1, new_states=[:PointedD], diffusing_net_stoich=[:GADPi =&gt; 1])\n  17. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedD --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedD\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_PointedD, polymerize=1, new_states=[:PointedDPi, :FAD], diffusing_net_stoich=[:GADPi =&gt; -1])\n  18. \"filamentendsite.actin.rGADPi_to_PointedDPi --&gt; filamentendsite.actin.rGADPi_to_PointedDPi\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_PointedDPi, depolymerize=1, new_states=[:PointedDPi], diffusing_net_stoich=[:GADPi =&gt; 1])\n  19. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedDPi --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedDPi\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_PointedDPi, polymerize=1, new_states=[:PointedDPi, :FADPi], diffusing_net_stoich=[:GADPi =&gt; -1])\n  20. \"filamentendsite.actin.rGADPi_to_PointedT --&gt; filamentendsite.actin.rGADPi_to_PointedT\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_PointedT, depolymerize=1, new_states=[:PointedT], diffusing_net_stoich=[:GADPi =&gt; 1])\n  21. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedT --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedT\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_PointedT, polymerize=1, new_states=[:PointedDPi, :FAT], diffusing_net_stoich=[:GADPi =&gt; -1])\n  22. \"filamentendsite.actin.rGAT_to_PointedD --&gt; filamentendsite.actin.rGAT_to_PointedD\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_PointedD, depolymerize=1, new_states=[:PointedD], diffusing_net_stoich=[:GAT =&gt; 1])\n  23. \"diffusing.GAT + filamentendsite.actin.fGAT_to_PointedD --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_PointedD\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_PointedD, polymerize=1, new_states=[:PointedT, :FAD], diffusing_net_stoich=[:GAT =&gt; -1])\n  24. \"filamentendsite.actin.rGAT_to_PointedDPi --&gt; filamentendsite.actin.rGAT_to_PointedDPi\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_PointedDPi, depolymerize=1, new_states=[:PointedDPi], diffusing_net_stoich=[:GAT =&gt; 1])\n  25. \"diffusing.GAT + filamentendsite.actin.fGAT_to_PointedDPi --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_PointedDPi\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_PointedDPi, polymerize=1, new_states=[:PointedT, :FADPi], diffusing_net_stoich=[:GAT =&gt; -1])\n  26. \"filamentendsite.actin.rGAT_to_PointedT --&gt; filamentendsite.actin.rGAT_to_PointedT\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_PointedT, depolymerize=1, new_states=[:PointedT], diffusing_net_stoich=[:GAT =&gt; 1])\n  27. \"diffusing.GAT + filamentendsite.actin.fGAT_to_PointedT --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_PointedT\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_PointedT, polymerize=1, new_states=[:PointedT, :FAT], diffusing_net_stoich=[:GAT =&gt; -1])\n  28. \"filamentendsite.actin.rGAD_to_BarbedD --&gt; filamentendsite.actin.rGAD_to_BarbedD\" 4.25 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_BarbedD, depolymerize=1, new_states=[:BarbedD], diffusing_net_stoich=[:GAD =&gt; 1])\n  29. \"diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedD --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedD\" 4.151347667934617e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_BarbedD, polymerize=1, new_states=[:FAD, :BarbedD], diffusing_net_stoich=[:GAD =&gt; -1])\n  30. \"filamentendsite.actin.rGAD_to_BarbedDPi --&gt; filamentendsite.actin.rGAD_to_BarbedDPi\" 4.25 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_BarbedDPi, depolymerize=1, new_states=[:BarbedDPi], diffusing_net_stoich=[:GAD =&gt; 1])\n  31. \"diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedDPi --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedDPi\" 4.151347667934617e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_BarbedDPi, polymerize=1, new_states=[:FADPi, :BarbedD], diffusing_net_stoich=[:GAD =&gt; -1])\n  32. \"filamentendsite.actin.rGAD_to_BarbedT --&gt; filamentendsite.actin.rGAD_to_BarbedT\" 4.25 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_BarbedT, depolymerize=1, new_states=[:BarbedT], diffusing_net_stoich=[:GAD =&gt; 1])\n  33. \"diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedT --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedT\" 4.151347667934617e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_BarbedT, polymerize=1, new_states=[:FAT, :BarbedD], diffusing_net_stoich=[:GAD =&gt; -1])\n  34. \"filamentendsite.actin.rGADPi_to_BarbedD --&gt; filamentendsite.actin.rGADPi_to_BarbedD\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_BarbedD, depolymerize=1, new_states=[:BarbedD], diffusing_net_stoich=[:GADPi =&gt; 1])\n  35. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedD --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedD\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_BarbedD, polymerize=1, new_states=[:FAD, :BarbedDPi], diffusing_net_stoich=[:GADPi =&gt; -1])\n  36. \"filamentendsite.actin.rGADPi_to_BarbedDPi --&gt; filamentendsite.actin.rGADPi_to_BarbedDPi\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_BarbedDPi, depolymerize=1, new_states=[:BarbedDPi], diffusing_net_stoich=[:GADPi =&gt; 1])\n  37. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedDPi --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedDPi\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_BarbedDPi, polymerize=1, new_states=[:FADPi, :BarbedDPi], diffusing_net_stoich=[:GADPi =&gt; -1])\n  38. \"filamentendsite.actin.rGADPi_to_BarbedT --&gt; filamentendsite.actin.rGADPi_to_BarbedT\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_BarbedT, depolymerize=1, new_states=[:BarbedT], diffusing_net_stoich=[:GADPi =&gt; 1])\n  39. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedT --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedT\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_BarbedT, polymerize=1, new_states=[:FAT, :BarbedDPi], diffusing_net_stoich=[:GADPi =&gt; -1])\n  40. \"filamentendsite.actin.rGAT_to_BarbedD --&gt; filamentendsite.actin.rGAT_to_BarbedD\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_BarbedD, depolymerize=1, new_states=[:BarbedD], diffusing_net_stoich=[:GAT =&gt; 1])\n  41. \"diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedD --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedD\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_BarbedD, polymerize=1, new_states=[:FAD, :BarbedT], diffusing_net_stoich=[:GAT =&gt; -1])\n  42. \"filamentendsite.actin.rGAT_to_BarbedDPi --&gt; filamentendsite.actin.rGAT_to_BarbedDPi\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_BarbedDPi, depolymerize=1, new_states=[:BarbedDPi], diffusing_net_stoich=[:GAT =&gt; 1])\n  43. \"diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedDPi --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedDPi\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_BarbedDPi, polymerize=1, new_states=[:FADPi, :BarbedT], diffusing_net_stoich=[:GAT =&gt; -1])\n  44. \"filamentendsite.actin.rGAT_to_BarbedT --&gt; filamentendsite.actin.rGAT_to_BarbedT\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_BarbedT, depolymerize=1, new_states=[:BarbedT], diffusing_net_stoich=[:GAT =&gt; 1])\n  45. \"diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedT --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedT\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_BarbedT, polymerize=1, new_states=[:FAT, :BarbedT], diffusing_net_stoich=[:GAT =&gt; -1])\n Chem voxel reactions without callbacks:\n  \"diffusing.GADPi --&gt; diffusing.GAD\" 0.0312 1/s\n  \"diffusing.GAD --&gt; diffusing.GADPi\" 0.0104 1/s\n  \"diffusing.GA --&gt; diffusing.GAT\" 17000.0 1/s\n  \"diffusing.GAT --&gt; diffusing.GA\" 0.011 1/s\n  \"diffusing.GA --&gt; diffusing.GAD\" 1799.9999999999998 1/s\n  \"diffusing.GAD --&gt; diffusing.GA\" 0.071 1/s\n\n\n\n\n\nCreate a 1 by 1 by 3 grid of 500 nm side length voxels.\n\nL = 3\ngrid = CubicGrid((1,1,L),500.0)\n\nCubicGrid([1, 1, 3], 500.0)\n\n\n\n\n\nThe Context is the object the handles the state of a running simulation.\nCreate a Context using s and grid\n\nc = MEDYAN.Context(s, grid)\n\nMEDYAN.Context at time 0.0s in MEDYAN.CubicGrid([1, 1, 3], 500.0)\n\n\n\n\n\n\nset_mechboundary!(c, MEDYAN.boundary_box(grid; stiffness=100.0))\n\nMEDYAN.Boundary(SVector{4, Float64}[[-10.0, 0.0, 0.0, 2500.0], [10.0, 0.0, 0.0, 2500.0], [0.0, -10.0, 0.0, 2500.0], [0.0, 10.0, 0.0, 2500.0], [0.0, 0.0, -10.0, 7500.0], [0.0, 0.0, 10.0, 7500.0]], SVector{8, Float64}[])\n\n\n\n\n\nThe context starts empty.\nDistribute 700 of GAT randomly to the chem voxels by mutating the context.\nadddiffusingcount_rand!\n\nadddiffusingcount_rand!(c, s.diffusing.GAT, 700)\n\nAdd a single short filament by mutating the context.\n\nmono_states = [s.state.actin.PointedD, s.state.actin.FADPi, s.state.actin.FAT, s.state.actin.BarbedT]\nnode_positions = [\n    SA[0.0,0.0,0.0], \n    SA[0.0,0.0,monomerspacing*length(mono_states)]\n]\nmake_fila!(c; type=:actin, mono_states, node_positions, node_mids=[1,])\n\nMEDYAN.Tag{FilaTipIdx}(0x00000002, 0x00000001)\n\n\n\n\n\nRun chemistry for 1.0s and visualize the results.\n\nvis = Visualizer()\nsetvisible!(vis[\"/Grid\"], false)\nsetvisible!(vis[\"/Axes\"], false)\nsetvisible!(vis[\"/Background\"], false)\n\nIf you open the visualizer in a browser and run the following you should get an animated version of below.\n\nfor i in 1:100\n    run_chemistry!(c, 0.01)\n    minimize_energy!(c)\n    draw_context!(vis, c, s)\nend",
    "crumbs": [
      "Tutorials",
      "3. Actin Treadmilling"
    ]
  },
  {
    "objectID": "tutorials/3treadmill.html#setup",
    "href": "tutorials/3treadmill.html#setup",
    "title": "3. Actin Treadmilling",
    "section": "",
    "text": "Open a julia REPL or jupyter notebook using the medyan-tutorial environment you created in tutorial 1.\nLoad MEDYAN with MeshCat for visualization\n\nusing MEDYAN\nusing MEDYANVis\nusing CairoMakie\nusing Random\nusing SmallZarrGroups\nusing StaticArrays\nusing LinearAlgebra\nRandom.seed!(1234);",
    "crumbs": [
      "Tutorials",
      "3. Actin Treadmilling"
    ]
  },
  {
    "objectID": "tutorials/3treadmill.html#defining-the-system",
    "href": "tutorials/3treadmill.html#defining-the-system",
    "title": "3. Actin Treadmilling",
    "section": "",
    "text": "The first step is constructing a MEDYAN.SysDef object, then mutating it to add species, filament types, reactions, and callbacks.\n\ns = MEDYAN.SysDef()\n\nMEDYAN.SysDef\n\n\nAdd diffusing species with their diffusion coefficients. All units are based on nm, s, pN.\ndef_diffusing_species!\n\nDGActin = 5E6 # nm²/s\ndef_diffusing_species!(s, :GA; coeff=DGActin)    # G-Actin with no bound nucleotide\ndef_diffusing_species!(s, :GAD; coeff=DGActin)   # G-Actin in the ADP form\ndef_diffusing_species!(s, :GADPi; coeff=DGActin) # G-Actin in the ADP Pi form\ndef_diffusing_species!(s, :GAT; coeff=DGActin)   # G-Actin in the ATP form\n\nMEDYAN.SysDef\n Diffusing species:\n  :GA: 5.0e6 nm²/s\n  :GAD: 5.0e6 nm²/s\n  :GADPi: 5.0e6 nm²/s\n  :GAT: 5.0e6 nm²/s\n\n\nAdd the actin filament type with its monomer states and mechanical parameters.\ndef_fila_type!\n\ndef_fila_type!(s; \n    name=:actin, \n    mono_states=[\n        # Monomer states\n        :FAD,       # F-Actin in the ADP form\n        :FADPi,     # F-Actin in the ADP Pi form\n        :FAT,       # F-Actin in the ATP form\n        :BarbedD,   # Barbed end in the ADP form\n        :BarbedDPi, # Barbed end in the ADP Pi form\n        :BarbedT,   # Barbed end in the ATP form\n        :PointedD,  # Pointed end in the ADP form\n        :PointedDPi, # Pointed end in the ADP Pi form\n        :PointedT,  # Pointed end in the ATP form\n    ],\n    param=MEDYAN.ACTIN_FIL_PARAMS\n)\n\nMEDYAN.SysDef\n Diffusing species:\n  :GA: 5.0e6 nm²/s\n  :GAD: 5.0e6 nm²/s\n  :GADPi: 5.0e6 nm²/s\n  :GAT: 5.0e6 nm²/s\n Filaments:\n  :actin:\n   monomer states: [:FAD, :FADPi, :FAT, :BarbedD, :BarbedDPi, :BarbedT, :PointedD, :PointedDPi, :PointedT]\n   params: MEDYAN.FilamentMechParams(3.0, 2.7, 4000.0, 26880.0, NaN, NaN, 40, 1666.6666666666667, 1)\n\n\nAdd reactions between diffusing species. These represent G-Actin interacting with ATP ADP and Pi.\ndef_reaction!\n\n# Assume ATP, Pi, and ADP concentrations are fixed\nATP = 10000.0 * MEDYAN.μM⁻¹_per_nm³\nPi = 2000.0 * MEDYAN.μM⁻¹_per_nm³\nADP = 2000.0 * MEDYAN.μM⁻¹_per_nm³\nKfGATPoint  = 1.3/MEDYAN.μM⁻¹_per_nm³\nKrGATPoint  = 0.8\nKfGADPoint  = 0.16/MEDYAN.μM⁻¹_per_nm³\nKrGADPoint  = 0.3\nKfGATBarb   = 10.0/MEDYAN.μM⁻¹_per_nm³\nKrGATBarb   = 1.0\nKfGADBarb   = 2.5/MEDYAN.μM⁻¹_per_nm³\nKrGADBarb   = 4.25\nKfPiRelease = 0.0026\nKrPiRelease = 5.20E-6/MEDYAN.μM⁻¹_per_nm³\n\n# 100\ndef_reaction!(s, \"diffusing.GADPi --&gt; diffusing.GAD\";\n    base_rate=0.0312,\n)\ndef_reaction!(s, \"diffusing.GAD --&gt; diffusing.GADPi\";\n    base_rate=KrPiRelease*Pi,\n)\n\n# 104\ndef_reaction!(s, \"diffusing.GA --&gt; diffusing.GAT\";\n    base_rate=1.7/MEDYAN.μM⁻¹_per_nm³*ATP,\n)\ndef_reaction!(s, \"diffusing.GAT --&gt; diffusing.GA\";\n    base_rate=0.011,\n)\n\n# 109\ndef_reaction!(s, \"diffusing.GA --&gt; diffusing.GAD\";\n    base_rate=0.9/MEDYAN.μM⁻¹_per_nm³*ADP,\n)\ndef_reaction!(s, \"diffusing.GAD --&gt; diffusing.GA\";\n    base_rate=0.071,\n)\n\nMEDYAN.SysDef\n Diffusing species:\n  :GA: 5.0e6 nm²/s\n  :GAD: 5.0e6 nm²/s\n  :GADPi: 5.0e6 nm²/s\n  :GAT: 5.0e6 nm²/s\n Filaments:\n  :actin:\n   monomer states: [:FAD, :FADPi, :FAT, :BarbedD, :BarbedDPi, :BarbedT, :PointedD, :PointedDPi, :PointedT]\n   params: MEDYAN.FilamentMechParams(3.0, 2.7, 4000.0, 26880.0, NaN, NaN, 40, 1666.6666666666667, 1)\n Chem voxel reactions without callbacks:\n  \"diffusing.GADPi --&gt; diffusing.GAD\" 0.0312 1/s\n  \"diffusing.GAD --&gt; diffusing.GADPi\" 0.0104 1/s\n  \"diffusing.GA --&gt; diffusing.GAT\" 17000.0 1/s\n  \"diffusing.GAT --&gt; diffusing.GA\" 0.011 1/s\n  \"diffusing.GA --&gt; diffusing.GAD\" 1799.9999999999998 1/s\n  \"diffusing.GAD --&gt; diffusing.GA\" 0.071 1/s\n\n\nNext add filament reactions.\nThe barbed end is the plus end and the pointed end is the minus end.\n\nmonomerspacing=2.7 # nm\n\n\nnucleotide_states = (\"T\", \"DPi\", \"D\")\n\n# Barbed end polymerization and depolymerization\nbarbed_rates = [\n    (\"T\", KfGATBarb, KrGATBarb),\n    (\"DPi\", KfGATBarb, KrGATBarb),\n    (\"D\", KfGADBarb, KrGADBarb),\n]\nfor (new_nuc, forward_rate, reverse_rate) in barbed_rates\n    for base_nuc in nucleotide_states\n        def_fila_tip_reaction!(s;\n            fila_type = :actin,\n            name = Symbol(\"f\", \"GA\", new_nuc, \"_to_Barbed\", base_nuc),\n            is_minus_end = false,\n            match = [Symbol(\"Barbed\", base_nuc)],\n            new = [Symbol(\"FA\", base_nuc), Symbol(\"Barbed\", new_nuc)],\n            spacing = monomerspacing,\n            net_stoich = [Symbol(\"GA\", new_nuc) =&gt; -1],\n            base_rate = forward_rate,\n            invvolumepower = 1,\n            reactants_extra = \"diffusing.GA\"*new_nuc,\n        )\n        def_fila_tip_reaction!(s;\n            fila_type = :actin,\n            name = Symbol(\"r\", \"GA\", new_nuc, \"_to_Barbed\", base_nuc),\n            is_minus_end = false,\n            match = [Symbol(\"FA\", base_nuc), Symbol(\"Barbed\", new_nuc)],\n            new = [Symbol(\"Barbed\", base_nuc)],\n            spacing = 0.0,\n            net_stoich = [Symbol(\"GA\", new_nuc) =&gt; 1],\n            base_rate = reverse_rate,\n        )\n    end\nend\n\n# Pointed end polymerization and depolymerization\npointed_rates = [\n    (\"T\", KfGATPoint, KrGATPoint),\n    (\"DPi\", KfGATPoint, KrGATPoint),\n    (\"D\", KfGADPoint, KrGADPoint),\n]\nfor (new_nuc, forward_rate, reverse_rate) in pointed_rates\n    for base_nuc in nucleotide_states\n        def_fila_tip_reaction!(s;\n            fila_type = :actin,\n            name = Symbol(\"f\", \"GA\", new_nuc, \"_to_Pointed\", base_nuc),\n            is_minus_end = true,\n            match = [Symbol(\"Pointed\", base_nuc)],\n            new = [Symbol(\"Pointed\", new_nuc), Symbol(\"FA\", base_nuc)],\n            spacing = monomerspacing,\n            net_stoich = [Symbol(\"GA\", new_nuc) =&gt; -1],\n            base_rate = forward_rate,\n            invvolumepower = 1,\n            reactants_extra = \"diffusing.GA\"*new_nuc,\n        )\n        def_fila_tip_reaction!(s;\n            fila_type = :actin,\n            name = Symbol(\"r\", \"GA\", new_nuc, \"_to_Pointed\", base_nuc),\n            is_minus_end = true,\n            match = [Symbol(\"Pointed\", new_nuc), Symbol(\"FA\", base_nuc)],\n            new = [Symbol(\"Pointed\", base_nuc)],\n            spacing = 0.0,\n            net_stoich = [Symbol(\"GA\", new_nuc) =&gt; 1],\n            base_rate = reverse_rate,\n        )\n    end\nend\n\n# Filament ATP hydrolysis and Pi Dissociation\nfor monomer_state in (\"FA\", \"Barbed\", \"Pointed\")\n    def_fila_reaction!(s;\n        fila_type = :actin,\n        name = Symbol(monomer_state, \"T_to_\", monomer_state, \"DPi\"),\n        match = [Symbol(monomer_state, \"T\")],\n        new = [Symbol(monomer_state, \"DPi\")],\n        base_rate = 0.3,\n    )\n    def_fila_reaction!(s;\n        fila_type = :actin,\n        name = Symbol(monomer_state, \"DPi_to_\", monomer_state, \"D\"),\n        match = [Symbol(monomer_state, \"DPi\")],\n        new = [Symbol(monomer_state, \"D\")],\n        base_rate = KfPiRelease,\n    )\n    def_fila_reaction!(s;\n        fila_type = :actin,\n        name = Symbol(monomer_state, \"D_to_\", monomer_state, \"DPi\"),\n        match = [Symbol(monomer_state, \"D\")],\n        new = [Symbol(monomer_state, \"DPi\")],\n        base_rate = KrPiRelease*Pi,\n    )\nend\ns\n\nMEDYAN.SysDef\n Diffusing species:\n  :GA: 5.0e6 nm²/s\n  :GAD: 5.0e6 nm²/s\n  :GADPi: 5.0e6 nm²/s\n  :GAT: 5.0e6 nm²/s\n Filaments:\n  :actin:\n   monomer states: [:FAD, :FADPi, :FAT, :BarbedD, :BarbedDPi, :BarbedT, :PointedD, :PointedDPi, :PointedT]\n   params: MEDYAN.FilamentMechParams(3.0, 2.7, 4000.0, 26880.0, NaN, NaN, 40, 1666.6666666666667, 1)\n   filament sites:\n    :FAT_to_FADPi: match=[:FAT]\n    :FADPi_to_FAD: match=[:FADPi]\n    :FAD_to_FADPi: match=[:FAD]\n    :BarbedT_to_BarbedDPi: match=[:BarbedT]\n    :BarbedDPi_to_BarbedD: match=[:BarbedDPi]\n    :BarbedD_to_BarbedDPi: match=[:BarbedD]\n    :PointedT_to_PointedDPi: match=[:PointedT]\n    :PointedDPi_to_PointedD: match=[:PointedDPi]\n    :PointedD_to_PointedDPi: match=[:PointedD]\n   filament end sites:\n    :fGAT_to_BarbedT: + end, match=[:BarbedT], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_BarbedT: + end, match=[:FAT, :BarbedT]\n    :fGAT_to_BarbedDPi: + end, match=[:BarbedDPi], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_BarbedDPi: + end, match=[:FADPi, :BarbedT]\n    :fGAT_to_BarbedD: + end, match=[:BarbedD], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_BarbedD: + end, match=[:FAD, :BarbedT]\n    :fGADPi_to_BarbedT: + end, match=[:BarbedT], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_BarbedT: + end, match=[:FAT, :BarbedDPi]\n    :fGADPi_to_BarbedDPi: + end, match=[:BarbedDPi], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_BarbedDPi: + end, match=[:FADPi, :BarbedDPi]\n    :fGADPi_to_BarbedD: + end, match=[:BarbedD], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_BarbedD: + end, match=[:FAD, :BarbedDPi]\n    :fGAD_to_BarbedT: + end, match=[:BarbedT], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_BarbedT: + end, match=[:FAT, :BarbedD]\n    :fGAD_to_BarbedDPi: + end, match=[:BarbedDPi], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_BarbedDPi: + end, match=[:FADPi, :BarbedD]\n    :fGAD_to_BarbedD: + end, match=[:BarbedD], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_BarbedD: + end, match=[:FAD, :BarbedD]\n    :fGAT_to_PointedT: - end, match=[:PointedT], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_PointedT: - end, match=[:PointedT, :FAT]\n    :fGAT_to_PointedDPi: - end, match=[:PointedDPi], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_PointedDPi: - end, match=[:PointedT, :FADPi]\n    :fGAT_to_PointedD: - end, match=[:PointedD], spacing=2.7 nm, added_monomers=1\n    :rGAT_to_PointedD: - end, match=[:PointedT, :FAD]\n    :fGADPi_to_PointedT: - end, match=[:PointedT], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_PointedT: - end, match=[:PointedDPi, :FAT]\n    :fGADPi_to_PointedDPi: - end, match=[:PointedDPi], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_PointedDPi: - end, match=[:PointedDPi, :FADPi]\n    :fGADPi_to_PointedD: - end, match=[:PointedD], spacing=2.7 nm, added_monomers=1\n    :rGADPi_to_PointedD: - end, match=[:PointedDPi, :FAD]\n    :fGAD_to_PointedT: - end, match=[:PointedT], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_PointedT: - end, match=[:PointedD, :FAT]\n    :fGAD_to_PointedDPi: - end, match=[:PointedDPi], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_PointedDPi: - end, match=[:PointedD, :FADPi]\n    :fGAD_to_PointedD: - end, match=[:PointedD], spacing=2.7 nm, added_monomers=1\n    :rGAD_to_PointedD: - end, match=[:PointedD, :FAD]\n Chem voxel reactions with callbacks:\n  1. \"filamentsite.actin.PointedD_to_PointedDPi --&gt; filamentsite.actin.PointedD_to_PointedDPi\" 0.0104 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:PointedD_to_PointedDPi, center=1, new_states=[:PointedDPi])\n  2. \"filamentsite.actin.PointedDPi_to_PointedD --&gt; filamentsite.actin.PointedDPi_to_PointedD\" 0.0026 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:PointedDPi_to_PointedD, center=1, new_states=[:PointedD])\n  3. \"filamentsite.actin.PointedT_to_PointedDPi --&gt; filamentsite.actin.PointedT_to_PointedDPi\" 0.3 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:PointedT_to_PointedDPi, center=1, new_states=[:PointedDPi])\n  4. \"filamentsite.actin.BarbedD_to_BarbedDPi --&gt; filamentsite.actin.BarbedD_to_BarbedDPi\" 0.0104 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:BarbedD_to_BarbedDPi, center=1, new_states=[:BarbedDPi])\n  5. \"filamentsite.actin.BarbedDPi_to_BarbedD --&gt; filamentsite.actin.BarbedDPi_to_BarbedD\" 0.0026 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:BarbedDPi_to_BarbedD, center=1, new_states=[:BarbedD])\n  6. \"filamentsite.actin.BarbedT_to_BarbedDPi --&gt; filamentsite.actin.BarbedT_to_BarbedDPi\" 0.3 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:BarbedT_to_BarbedDPi, center=1, new_states=[:BarbedDPi])\n  7. \"filamentsite.actin.FAD_to_FADPi --&gt; filamentsite.actin.FAD_to_FADPi\" 0.0104 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:FAD_to_FADPi, center=1, new_states=[:FADPi])\n  8. \"filamentsite.actin.FADPi_to_FAD --&gt; filamentsite.actin.FADPi_to_FAD\" 0.0026 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:FADPi_to_FAD, center=1, new_states=[:FAD])\n  9. \"filamentsite.actin.FAT_to_FADPi --&gt; filamentsite.actin.FAT_to_FADPi\" 0.3 1/s\n       GeneralFilamentSiteCallback(fila=:actin, site=:FAT_to_FADPi, center=1, new_states=[:FADPi])\n  10. \"filamentendsite.actin.rGAD_to_PointedD --&gt; filamentendsite.actin.rGAD_to_PointedD\" 0.3 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_PointedD, depolymerize=1, new_states=[:PointedD], diffusing_net_stoich=[:GAD =&gt; 1])\n  11. \"diffusing.GAD + filamentendsite.actin.fGAD_to_PointedD --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_PointedD\" 265686.2507478155 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_PointedD, polymerize=1, new_states=[:PointedD, :FAD], diffusing_net_stoich=[:GAD =&gt; -1])\n  12. \"filamentendsite.actin.rGAD_to_PointedDPi --&gt; filamentendsite.actin.rGAD_to_PointedDPi\" 0.3 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_PointedDPi, depolymerize=1, new_states=[:PointedDPi], diffusing_net_stoich=[:GAD =&gt; 1])\n  13. \"diffusing.GAD + filamentendsite.actin.fGAD_to_PointedDPi --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_PointedDPi\" 265686.2507478155 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_PointedDPi, polymerize=1, new_states=[:PointedD, :FADPi], diffusing_net_stoich=[:GAD =&gt; -1])\n  14. \"filamentendsite.actin.rGAD_to_PointedT --&gt; filamentendsite.actin.rGAD_to_PointedT\" 0.3 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_PointedT, depolymerize=1, new_states=[:PointedT], diffusing_net_stoich=[:GAD =&gt; 1])\n  15. \"diffusing.GAD + filamentendsite.actin.fGAD_to_PointedT --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_PointedT\" 265686.2507478155 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_PointedT, polymerize=1, new_states=[:PointedD, :FAT], diffusing_net_stoich=[:GAD =&gt; -1])\n  16. \"filamentendsite.actin.rGADPi_to_PointedD --&gt; filamentendsite.actin.rGADPi_to_PointedD\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_PointedD, depolymerize=1, new_states=[:PointedD], diffusing_net_stoich=[:GADPi =&gt; 1])\n  17. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedD --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedD\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_PointedD, polymerize=1, new_states=[:PointedDPi, :FAD], diffusing_net_stoich=[:GADPi =&gt; -1])\n  18. \"filamentendsite.actin.rGADPi_to_PointedDPi --&gt; filamentendsite.actin.rGADPi_to_PointedDPi\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_PointedDPi, depolymerize=1, new_states=[:PointedDPi], diffusing_net_stoich=[:GADPi =&gt; 1])\n  19. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedDPi --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedDPi\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_PointedDPi, polymerize=1, new_states=[:PointedDPi, :FADPi], diffusing_net_stoich=[:GADPi =&gt; -1])\n  20. \"filamentendsite.actin.rGADPi_to_PointedT --&gt; filamentendsite.actin.rGADPi_to_PointedT\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_PointedT, depolymerize=1, new_states=[:PointedT], diffusing_net_stoich=[:GADPi =&gt; 1])\n  21. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedT --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_PointedT\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_PointedT, polymerize=1, new_states=[:PointedDPi, :FAT], diffusing_net_stoich=[:GADPi =&gt; -1])\n  22. \"filamentendsite.actin.rGAT_to_PointedD --&gt; filamentendsite.actin.rGAT_to_PointedD\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_PointedD, depolymerize=1, new_states=[:PointedD], diffusing_net_stoich=[:GAT =&gt; 1])\n  23. \"diffusing.GAT + filamentendsite.actin.fGAT_to_PointedD --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_PointedD\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_PointedD, polymerize=1, new_states=[:PointedT, :FAD], diffusing_net_stoich=[:GAT =&gt; -1])\n  24. \"filamentendsite.actin.rGAT_to_PointedDPi --&gt; filamentendsite.actin.rGAT_to_PointedDPi\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_PointedDPi, depolymerize=1, new_states=[:PointedDPi], diffusing_net_stoich=[:GAT =&gt; 1])\n  25. \"diffusing.GAT + filamentendsite.actin.fGAT_to_PointedDPi --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_PointedDPi\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_PointedDPi, polymerize=1, new_states=[:PointedT, :FADPi], diffusing_net_stoich=[:GAT =&gt; -1])\n  26. \"filamentendsite.actin.rGAT_to_PointedT --&gt; filamentendsite.actin.rGAT_to_PointedT\" 0.8 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_PointedT, depolymerize=1, new_states=[:PointedT], diffusing_net_stoich=[:GAT =&gt; 1])\n  27. \"diffusing.GAT + filamentendsite.actin.fGAT_to_PointedT --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_PointedT\" 2.158700787326001e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_PointedT, polymerize=1, new_states=[:PointedT, :FAT], diffusing_net_stoich=[:GAT =&gt; -1])\n  28. \"filamentendsite.actin.rGAD_to_BarbedD --&gt; filamentendsite.actin.rGAD_to_BarbedD\" 4.25 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_BarbedD, depolymerize=1, new_states=[:BarbedD], diffusing_net_stoich=[:GAD =&gt; 1])\n  29. \"diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedD --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedD\" 4.151347667934617e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_BarbedD, polymerize=1, new_states=[:FAD, :BarbedD], diffusing_net_stoich=[:GAD =&gt; -1])\n  30. \"filamentendsite.actin.rGAD_to_BarbedDPi --&gt; filamentendsite.actin.rGAD_to_BarbedDPi\" 4.25 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_BarbedDPi, depolymerize=1, new_states=[:BarbedDPi], diffusing_net_stoich=[:GAD =&gt; 1])\n  31. \"diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedDPi --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedDPi\" 4.151347667934617e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_BarbedDPi, polymerize=1, new_states=[:FADPi, :BarbedD], diffusing_net_stoich=[:GAD =&gt; -1])\n  32. \"filamentendsite.actin.rGAD_to_BarbedT --&gt; filamentendsite.actin.rGAD_to_BarbedT\" 4.25 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAD_to_BarbedT, depolymerize=1, new_states=[:BarbedT], diffusing_net_stoich=[:GAD =&gt; 1])\n  33. \"diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedT --&gt; diffusing.GAD + filamentendsite.actin.fGAD_to_BarbedT\" 4.151347667934617e6 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAD_to_BarbedT, polymerize=1, new_states=[:FAT, :BarbedD], diffusing_net_stoich=[:GAD =&gt; -1])\n  34. \"filamentendsite.actin.rGADPi_to_BarbedD --&gt; filamentendsite.actin.rGADPi_to_BarbedD\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_BarbedD, depolymerize=1, new_states=[:BarbedD], diffusing_net_stoich=[:GADPi =&gt; 1])\n  35. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedD --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedD\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_BarbedD, polymerize=1, new_states=[:FAD, :BarbedDPi], diffusing_net_stoich=[:GADPi =&gt; -1])\n  36. \"filamentendsite.actin.rGADPi_to_BarbedDPi --&gt; filamentendsite.actin.rGADPi_to_BarbedDPi\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_BarbedDPi, depolymerize=1, new_states=[:BarbedDPi], diffusing_net_stoich=[:GADPi =&gt; 1])\n  37. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedDPi --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedDPi\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_BarbedDPi, polymerize=1, new_states=[:FADPi, :BarbedDPi], diffusing_net_stoich=[:GADPi =&gt; -1])\n  38. \"filamentendsite.actin.rGADPi_to_BarbedT --&gt; filamentendsite.actin.rGADPi_to_BarbedT\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGADPi_to_BarbedT, depolymerize=1, new_states=[:BarbedT], diffusing_net_stoich=[:GADPi =&gt; 1])\n  39. \"diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedT --&gt; diffusing.GADPi + filamentendsite.actin.fGADPi_to_BarbedT\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGADPi_to_BarbedT, polymerize=1, new_states=[:FAT, :BarbedDPi], diffusing_net_stoich=[:GADPi =&gt; -1])\n  40. \"filamentendsite.actin.rGAT_to_BarbedD --&gt; filamentendsite.actin.rGAT_to_BarbedD\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_BarbedD, depolymerize=1, new_states=[:BarbedD], diffusing_net_stoich=[:GAT =&gt; 1])\n  41. \"diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedD --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedD\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_BarbedD, polymerize=1, new_states=[:FAD, :BarbedT], diffusing_net_stoich=[:GAT =&gt; -1])\n  42. \"filamentendsite.actin.rGAT_to_BarbedDPi --&gt; filamentendsite.actin.rGAT_to_BarbedDPi\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_BarbedDPi, depolymerize=1, new_states=[:BarbedDPi], diffusing_net_stoich=[:GAT =&gt; 1])\n  43. \"diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedDPi --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedDPi\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_BarbedDPi, polymerize=1, new_states=[:FADPi, :BarbedT], diffusing_net_stoich=[:GAT =&gt; -1])\n  44. \"filamentendsite.actin.rGAT_to_BarbedT --&gt; filamentendsite.actin.rGAT_to_BarbedT\" 1.0 1/s\n        GeneralFilamentEndCallback(fila=:actin, site=:rGAT_to_BarbedT, depolymerize=1, new_states=[:BarbedT], diffusing_net_stoich=[:GAT =&gt; 1])\n  45. \"diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedT --&gt; diffusing.GAT + filamentendsite.actin.fGAT_to_BarbedT\" 1.6605390671738468e7 nm³/s\n        GeneralFilamentEndCallback(fila=:actin, site=:fGAT_to_BarbedT, polymerize=1, new_states=[:FAT, :BarbedT], diffusing_net_stoich=[:GAT =&gt; -1])\n Chem voxel reactions without callbacks:\n  \"diffusing.GADPi --&gt; diffusing.GAD\" 0.0312 1/s\n  \"diffusing.GAD --&gt; diffusing.GADPi\" 0.0104 1/s\n  \"diffusing.GA --&gt; diffusing.GAT\" 17000.0 1/s\n  \"diffusing.GAT --&gt; diffusing.GA\" 0.011 1/s\n  \"diffusing.GA --&gt; diffusing.GAD\" 1799.9999999999998 1/s\n  \"diffusing.GAD --&gt; diffusing.GA\" 0.071 1/s",
    "crumbs": [
      "Tutorials",
      "3. Actin Treadmilling"
    ]
  },
  {
    "objectID": "tutorials/3treadmill.html#creating-a-grid",
    "href": "tutorials/3treadmill.html#creating-a-grid",
    "title": "3. Actin Treadmilling",
    "section": "",
    "text": "Create a 1 by 1 by 3 grid of 500 nm side length voxels.\n\nL = 3\ngrid = CubicGrid((1,1,L),500.0)\n\nCubicGrid([1, 1, 3], 500.0)",
    "crumbs": [
      "Tutorials",
      "3. Actin Treadmilling"
    ]
  },
  {
    "objectID": "tutorials/3treadmill.html#creating-a-context",
    "href": "tutorials/3treadmill.html#creating-a-context",
    "title": "3. Actin Treadmilling",
    "section": "",
    "text": "The Context is the object the handles the state of a running simulation.\nCreate a Context using s and grid\n\nc = MEDYAN.Context(s, grid)\n\nMEDYAN.Context at time 0.0s in MEDYAN.CubicGrid([1, 1, 3], 500.0)",
    "crumbs": [
      "Tutorials",
      "3. Actin Treadmilling"
    ]
  },
  {
    "objectID": "tutorials/3treadmill.html#add-mechanical-boundary",
    "href": "tutorials/3treadmill.html#add-mechanical-boundary",
    "title": "3. Actin Treadmilling",
    "section": "",
    "text": "set_mechboundary!(c, MEDYAN.boundary_box(grid; stiffness=100.0))\n\nMEDYAN.Boundary(SVector{4, Float64}[[-10.0, 0.0, 0.0, 2500.0], [10.0, 0.0, 0.0, 2500.0], [0.0, -10.0, 0.0, 2500.0], [0.0, 10.0, 0.0, 2500.0], [0.0, 0.0, -10.0, 7500.0], [0.0, 0.0, 10.0, 7500.0]], SVector{8, Float64}[])",
    "crumbs": [
      "Tutorials",
      "3. Actin Treadmilling"
    ]
  },
  {
    "objectID": "tutorials/3treadmill.html#add-agents-to-the-context",
    "href": "tutorials/3treadmill.html#add-agents-to-the-context",
    "title": "3. Actin Treadmilling",
    "section": "",
    "text": "The context starts empty.\nDistribute 700 of GAT randomly to the chem voxels by mutating the context.\nadddiffusingcount_rand!\n\nadddiffusingcount_rand!(c, s.diffusing.GAT, 700)\n\nAdd a single short filament by mutating the context.\n\nmono_states = [s.state.actin.PointedD, s.state.actin.FADPi, s.state.actin.FAT, s.state.actin.BarbedT]\nnode_positions = [\n    SA[0.0,0.0,0.0], \n    SA[0.0,0.0,monomerspacing*length(mono_states)]\n]\nmake_fila!(c; type=:actin, mono_states, node_positions, node_mids=[1,])\n\nMEDYAN.Tag{FilaTipIdx}(0x00000002, 0x00000001)",
    "crumbs": [
      "Tutorials",
      "3. Actin Treadmilling"
    ]
  },
  {
    "objectID": "tutorials/3treadmill.html#run-chemistry",
    "href": "tutorials/3treadmill.html#run-chemistry",
    "title": "3. Actin Treadmilling",
    "section": "",
    "text": "Run chemistry for 1.0s and visualize the results.\n\nvis = Visualizer()\nsetvisible!(vis[\"/Grid\"], false)\nsetvisible!(vis[\"/Axes\"], false)\nsetvisible!(vis[\"/Background\"], false)\n\nIf you open the visualizer in a browser and run the following you should get an animated version of below.\n\nfor i in 1:100\n    run_chemistry!(c, 0.01)\n    minimize_energy!(c)\n    draw_context!(vis, c, s)\nend",
    "crumbs": [
      "Tutorials",
      "3. Actin Treadmilling"
    ]
  },
  {
    "objectID": "explanation/chem-boundary.html",
    "href": "explanation/chem-boundary.html",
    "title": "Chem Boundary",
    "section": "",
    "text": "Cross section of a simulation of actin diffusion with triangle mesh boundaries\n\n\n\n\nThis is background to understand the requirements of the chem boundary systems.\nMEDYAN models stochastic reaction diffusion dynamics using the approach described in (see Isaacson and Peskin 2006)\nThis is a Eulerian method on a cartesian mesh of cubes with an embedded boundary.\nIsaacson and Peskin (2006) calls these cubes cells, and they were called compartments in the C++ code base. However, both cells and compartments are biological terms, so to avoid confusion the term chem voxels is used.\nEach chem voxel stores a count of each of the diffusing species.\nChem voxels typically have a side length of 500 nm. This means for a 16 micrometer cell there may be about 30,000.\nInside a chem voxel, diffusing species can react with each other. Diffusing species can move between neighboring chem voxels with first order diffusion reactions.\nReactions between diffusing species can result in the creation of an object with a continuous position, such as a filament being nucleated.\nIn addition, objects with continuous positions can react with diffusing species.\n\n\n\nThe chem boundary defines a region of space. In MEDYAN, the chem boundary is constructed as the intersection of domains defined by geometric primitives and meshes.\nDuring a simulation the chem boundary can change, but in many cases it will be fixed.\n\n\nPrimitives define simple geometric domains with analytical signed distance functions:\n\nPlanes: Define a half-space. One side of the plane is inside the domain, the other is outside.\nCapsules: A cylinder capped with hemispheres at each end. The domain can be either the interior or the exterior of the capsule.\n\n\n\n\nTriangular meshes represent membranes or other complex surfaces. The domain can be either the interior or the exterior of the mesh.\n\n\n\nThe final chem boundary is the intersection of all specified domains (both primitives and meshes). A point in space is inside the chem boundary only if it is inside every domain.\nThis approach allows flexible construction of complex geometries. For example:\n\nA cell cortex can be modeled as the interior of a membrane mesh.\nA region between two membranes can be modeled by intersecting the exterior of an inner mesh with the interior of an outer mesh.\nFlat boundaries (e.g., a substrate or coverslip) can be added using planes.\n\nBecause only intersection is used, unlike a general-purpose constructive solid geometry system which would support union and other set operations, arbitrary boundaries cannot be created using primitives alone. Instead, meshes must be used to create arbitrarily shaped domains. The code assumes there are a small number of primitives, as is the case in simple simulations where the boundary is a sphere, box, cylinder, or capsule.\nEach context has only one chem boundary, and thus one domain where chemistry takes place. This means that to simulate chemistry in multiple cells, or in separate cytoplasmic and nuclear domains, one context must be created per domain.\n\n\n\n\nThe chem boundary system must support several operations:\n\n\nDiffusion rates between neighboring voxels depend on the shared surface area, and volume-dependent reaction rates (e.g., bimolecular reactions) require accurate voxel volumes. For voxels entirely inside or outside the boundary, this is straightforward. However, voxels cut by the boundary require computing the partial volume and the areas of faces inside the domain.\nSpecifically, the diffusion hopping rate between two neighboring voxels is (Isaacson and Peskin 2006):\n\\[k = \\frac{D \\cdot A}{V \\cdot L}\\]\nwhere \\(D\\) is the diffusion coefficient, \\(A\\) is the shared face area, \\(V\\) is the source voxel volume, and \\(L\\) is the voxel spacing. For voxels cut by the boundary, \\(A\\) and \\(V\\) will be reduced from their full values of \\(L^2\\) and \\(L^3\\).\n\n\n\nWhen continuously positioned objects (such as filaments) react with diffusing species, the system must determine which chem voxel contains the object’s position.\n\n\n\nWhen a nucleation reaction creates a new positioned object, a position must be sampled within the voxel where the reaction occurred. The sampled position must be conservatively inside the boundary — if the boundary is defined by a mesh, positions too close to the surface can cause numerical issues during force calculations.\n\n\n\nWhen the chem boundary moves, some voxels may transition from inside to outside. These voxels must be deactivated, and their diffusing species must be moved to nearby active voxels.\nAdditionally, voxels with volumes below a threshold must be deactivated even if they are partially inside the boundary. This is necessary because volume-dependent reaction propensities can numerically explode when the volume is very small.\n\n\n\n\nBecause the boundary can be quite complex, we make use of a truncated signed distance field (TSDF) to accelerate the various boundary computations. By using a grid based acceleration method, the assumption is that simulations are dense. Tree based methods such as a BVH would use much less memory and could be faster in very large sparse system.\n\n\nA signed distance field (SDF) stores, at each point in space, the signed distance to the nearest boundary surface. By convention, negative values indicate points inside the domain, and positive values indicate points outside. The zero level set of the SDF defines the boundary surface.\nA truncated signed distance field (TSDF) clamps the signed distance to ±max_distance. This truncation makes TSDF generation from meshes efficient: only grid points near the surface need accurate distance computations, while distant points are simply assigned the clamped value.\n\n\n\nThe TSDF is stored on a Cartesian grid that is aligned with the chem voxel grid but with finer spacing. Typically, the TSDF grid oversamples the chem voxels by a factor of 4 in each dimension.\nThe TSDF values are defined at the corners of the TSDF grid cells. Importantly, the corners of the chem voxels coincide with a subset of the TSDF grid points.\n\n\n\nRelationship between chem voxels and TSDF grid. Thick lines show chem voxel boundaries, thin lines show the finer TSDF grid. TSDF values are stored at grid intersections. Red dots mark chem voxel corners, which align with TSDF grid points. With 4× oversampling, each chem voxel edge spans 4 TSDF cells.\n\n\nThis alignment ensures that TSDF values at chem voxel corners are directly available without interpolation, while the finer grid provides the resolution needed for accurate cut voxel geometry calculations.\n\n\n\n\n\n\nThe TSDF is computed differently for primitives and meshes, then combined by intersection (taking the maximum signed distance at each grid point).\nPrimitives (planes and capsules): For each grid point, the signed distance to each primitive is computed analytically:\n\nFor planes, this is simply the dot product of the position with the plane normal minus the offset.\nFor capsules, the distance is computed to the closest point on the capsule’s central axis, minus the capsule radius. The distance sign is flipped if the exterior of the capsule is part of the domain instead of the interior.\n\nThe maximum distance across all primitives gives the signed distance to the primitive boundary. Values are clamped to ±max_distance.\nMeshes: Computing signed distances to a triangular mesh is more involved. The algorithm follows the method described by Bærentzen and Aanæs (2002), which handles sharp corners and edges correctly using pseudo-normals.\nThe key steps are:\n\nCompute pseudo-normals: For each vertex, the pseudo-normal is the angle-weighted average of the normals of incident triangles. For each edge, it is the sum of the two adjacent triangle normals. These pseudo-normals ensure correct sign determination near sharp features.\nCompute unsigned squared distances: For each triangle, the algorithm iterates over nearby grid points (within max_distance of the triangle’s bounding box). For each point, it determines whether the closest point on the triangle is on the face, an edge, or a vertex, and computes the squared distance accordingly.\nDetermine sign: The sign is determined by the dot product of the vector from the closest surface point to the query point with the appropriate pseudo-normal (triangle, edge, or vertex).\nPropagate signs: Grid points far from the mesh may not be visited. A sweep in all six axis directions propagates the sign from computed regions to fill in the rest of the grid.\nConvert to distance: Finally, squared distances are converted to actual distances and clamped to ±max_distance.\n\nCombining boundaries: When both primitives and meshes define the boundary, their TSDFs are combined by taking the element-wise maximum. This implements the intersection of domains — a point is inside only if it is inside all boundary components.\n\n\n\nTo compute the volume and face areas of a chem voxel cut by the boundary, the algorithm uses the fine TSDF grid within that voxel.\nFor each chem voxel:\n\nExtract the local TSDF: The portion of the TSDF corresponding to this voxel (a subgrid of size oversampling_factor+1 in each dimension) is extracted.\nCheck trivial cases: If all TSDF values are negative (fully inside), the volume is simply L³ and all face areas are L². If all are positive (fully outside), volume and areas are zero.\nIsosurface extraction: For cut voxels, the marching tetrahedra algorithm (see Doi and Koide (1991)) extracts the zero isosurface as a triangle mesh, with the boundary capped where it intersects the voxel faces.\nCompute volume: The signed volume is computed by summing the signed volumes of tetrahedra formed by each isosurface triangle with the origin.\nCompute face areas: For each of the six faces of the voxel, the algorithm identifies which triangles lie on that face and sums their areas. This gives the portion of each face that is inside the domain, which is needed for diffusion rate calculations.\n\n\n\nMEDYAN C++: For membrane boundaries, the computeSlicedVolumeArea() method fits a single plane to the triangles overlapping a compartment (area-weighted average position and normal), then uses an analytical plane-cube slicing formula (planeUnitCubeSlice). This is fast but assumes the membrane is locally planar within each compartment.\nAnalytical methods: When the boundary is a simple primitive (plane, sphere, cylinder), exact formulas exist for the intersection of that primitive with a cube. These are exact but require separate implementations for each primitive type and do not handle combinations of boundaries.\nThe TSDF approach used in MEDYAN.jl handles arbitrary boundary shapes consistently, including curved surfaces and multiple intersecting boundaries, at the cost of more computation. The resolution is configurable through the oversampling factor.\n\n\n\n\nTo check whether a position is conservatively inside the boundary by at least a minimum distance, the algorithm uses the cached TSDF.\nBounding the signed distance using the triangle inequality:\nThe signed distance function satisfies the triangle inequality: for any two points, their signed distances differ by at most the Euclidean distance between them. If a TSDF vertex has value \\(t_v\\) and is at distance \\(r\\) from the query point \\(p\\), then:\n\\[\\text{TSDF}(p) \\in [t_v - r, t_v + r]\\]\nThis provides upper and lower bounds on the truncated signed distance at \\(p\\) without computing it directly.\nThe algorithm:\n\nLocate the containing TSDF voxel: Convert the position to TSDF grid coordinates and find the eight vertices of the containing voxel.\nFor each vertex, compute the distance \\(r\\) to the query point and apply the bounds:\n\nIf \\(t_v - r &gt; -\\text{min\\_distance}\\): even in the best case, the point cannot be inside by the required margin → return false\nIf \\(t_v + r &lt; -\\text{min\\_distance}\\): even in the worst case, the point is definitely inside by enough margin → return true\nOtherwise: this vertex is inconclusive, continue to next vertex\n\nFallback: If all eight vertices are inconclusive, return false (conservative).\n\nRestriction on min_distance:\nThe maximum possible distance \\(r\\) from a query point to any vertex of its containing TSDF voxel is the voxel diagonal: \\(r_{\\max} = \\sqrt{3} \\cdot \\text{grid\\_spacing}\\).\nFor the algorithm to ever return true, we need the upper bound to satisfy: \\[t_v + r &lt; -\\text{min\\_distance}\\]\nBut TSDF values are clamped to \\(\\pm\\text{max\\_distance}\\). For a point deep inside the boundary, \\(t_v = -\\text{max\\_distance}\\). In this case: \\[-\\text{max\\_distance} + r_{\\max} &lt; -\\text{min\\_distance}\\]\nRearranging: \\[\\text{min\\_distance} &lt; \\text{max\\_distance} - \\sqrt{3} \\cdot \\text{grid\\_spacing}\\]\nIf this condition is not met, the truncation could prevent the algorithm from proving a point is inside by the requested margin. The function throws an error in this case, suggesting the user increase max_distance.\nA more sophisticated approach could interpolate or combine information from multiple vertices to make better use of the available data, but the current algorithm keeps the logic simple.\nThis conservative approach is important for nucleation sampling — we must never place a new object outside the boundary or too close to a mesh surface.\n\n\nAn alternative approach would store, for each chem voxel, a list of nearby triangles. To check whether a point is inside by a margin, the algorithm would:\n\nLook up the triangles associated with the containing chem voxel\nCompute the exact signed distance to each triangle\nReturn true if the minimum signed distance is less than -min_distance\n\nThis triangle list approach has some advantages:\n\nExact results: No conservative approximation; the algorithm can determine exactly whether a point is inside by the required margin.\n\nHowever, the TSDF approach used in MEDYAN has its own advantages:\n\nConstant-time queries: The triangle inequality check examines only 8 TSDF values regardless of mesh complexity. The triangle list approach scales with the number of nearby triangles.\nUnified handling of primitives and meshes: The TSDF combines all boundary components into a single representation. A triangle list would need separate handling for analytical primitives.\n\nA BVH (bounding volume hierarchy) over triangles is another option that would give exact results with O(log n) query time. This is attractive for very large or sparse domains but adds implementation complexity and may have higher constant factors for the small, dense systems typical in MEDYAN.\nThe TSDF approach strikes a balance: it provides fast, conservative inside checks suitable for nucleation sampling while reusing the same data structure needed for volume and area computations.\n\n\n\n\nWhen a nucleation reaction fires in a chem voxel, a position must be sampled for the new object. The position must be conservatively inside the boundary to avoid numerical issues during subsequent force calculations.\nThe algorithm uses rejection sampling:\n\nSample a uniform random point within the chem voxel\nCheck if the point is inside the boundary by the required margin using the is_inside algorithm\nIf not, reject and repeat from step 1\n\nIf the voxel is mostly inside the boundary, rejection sampling is efficient. For voxels that are largely cut by the boundary, many samples may be rejected.\n\n\n\n\nWhen apply_chem_boundary! is called, voxels may need to be deactivated. A voxel is deactivated if:\n\nIts volume (after boundary cutting) falls below min_chem_voxel_volume_ratio × L³, where L is the voxel side length\n\n\n\nWhen a continuously positioned object (such as a filament monomer) participates in a reaction with diffusing species, the system must determine which chem voxel contains the object’s position.\nFor positions clearly inside the domain, this is simple integer division: divide the position by the voxel spacing and convert to a voxel index.\nHowever, the position may be in a voxel that has been deactivated (volume below threshold or outside the boundary). In this case, the algorithm searches for the nearest active voxel:\n\nCheck the voxel containing the position — if active, return it\nCheck the six face-adjacent neighbors — return the nearest active one\nIf no neighbor is active, search all voxels in the grid\n\nThis fallback ensures that objects near the boundary can still interact with chemistry, even if their exact position falls in a deactivated voxel.\n\n\n\nWhen a voxel is deactivated, any diffusing species it contains must be moved elsewhere. For each molecule in the deactivated voxel:\n\nSample a random position within the voxel\nFind the nearest active voxel to that position (using the position-to-voxel lookup with fallback)\nMove the molecule to that voxel\n\nThis approach approximately preserves spatial distribution — molecules near the boundary of the deactivated region move to the closest active voxel rather than being uniformly redistributed.\nIn practice, if boundaries move slowly, diffusion will naturally move most species out of shrinking voxels before they are deactivated, so few molecules need to be forcibly redistributed, but there is a lot of room for speeding up the redistribution, for example by sampling a multinomial distribution for how many molecules should move to each neighbor.\n\n\n\n\nThe TSDF is computed when first needed and cached for reuse. The cache is invalidated when:\n\nThe chem boundary primitives change\nA membrane marked as a chem boundary moves (e.g., after energy minimization)\nThe oversampling factor or max distance settings change\n\nThe TSDF itself is not saved in snapshot files, as it can be regenerated from the boundary geometry. However, the configuration parameters (chem_boundary_oversampling_factor and chem_boundary_tsdf_max_distance) are saved so the TSDF can be regenerated consistently when loading.\nThe computed chem voxel volumes and areas are also saved in the snapshot, allowing chemistry to resume without recomputing them. The chem voxel volumes and areas must be explicitly recomputed with apply_chem_boundary!",
    "crumbs": [
      "Explanation",
      "Chem Boundary"
    ]
  },
  {
    "objectID": "explanation/chem-boundary.html#background-on-the-chemistry-model",
    "href": "explanation/chem-boundary.html#background-on-the-chemistry-model",
    "title": "Chem Boundary",
    "section": "",
    "text": "This is background to understand the requirements of the chem boundary systems.\nMEDYAN models stochastic reaction diffusion dynamics using the approach described in (see Isaacson and Peskin 2006)\nThis is a Eulerian method on a cartesian mesh of cubes with an embedded boundary.\nIsaacson and Peskin (2006) calls these cubes cells, and they were called compartments in the C++ code base. However, both cells and compartments are biological terms, so to avoid confusion the term chem voxels is used.\nEach chem voxel stores a count of each of the diffusing species.\nChem voxels typically have a side length of 500 nm. This means for a 16 micrometer cell there may be about 30,000.\nInside a chem voxel, diffusing species can react with each other. Diffusing species can move between neighboring chem voxels with first order diffusion reactions.\nReactions between diffusing species can result in the creation of an object with a continuous position, such as a filament being nucleated.\nIn addition, objects with continuous positions can react with diffusing species.",
    "crumbs": [
      "Explanation",
      "Chem Boundary"
    ]
  },
  {
    "objectID": "explanation/chem-boundary.html#boundary-definition",
    "href": "explanation/chem-boundary.html#boundary-definition",
    "title": "Chem Boundary",
    "section": "",
    "text": "The chem boundary defines a region of space. In MEDYAN, the chem boundary is constructed as the intersection of domains defined by geometric primitives and meshes.\nDuring a simulation the chem boundary can change, but in many cases it will be fixed.\n\n\nPrimitives define simple geometric domains with analytical signed distance functions:\n\nPlanes: Define a half-space. One side of the plane is inside the domain, the other is outside.\nCapsules: A cylinder capped with hemispheres at each end. The domain can be either the interior or the exterior of the capsule.\n\n\n\n\nTriangular meshes represent membranes or other complex surfaces. The domain can be either the interior or the exterior of the mesh.\n\n\n\nThe final chem boundary is the intersection of all specified domains (both primitives and meshes). A point in space is inside the chem boundary only if it is inside every domain.\nThis approach allows flexible construction of complex geometries. For example:\n\nA cell cortex can be modeled as the interior of a membrane mesh.\nA region between two membranes can be modeled by intersecting the exterior of an inner mesh with the interior of an outer mesh.\nFlat boundaries (e.g., a substrate or coverslip) can be added using planes.\n\nBecause only intersection is used, unlike a general-purpose constructive solid geometry system which would support union and other set operations, arbitrary boundaries cannot be created using primitives alone. Instead, meshes must be used to create arbitrarily shaped domains. The code assumes there are a small number of primitives, as is the case in simple simulations where the boundary is a sphere, box, cylinder, or capsule.\nEach context has only one chem boundary, and thus one domain where chemistry takes place. This means that to simulate chemistry in multiple cells, or in separate cytoplasmic and nuclear domains, one context must be created per domain.",
    "crumbs": [
      "Explanation",
      "Chem Boundary"
    ]
  },
  {
    "objectID": "explanation/chem-boundary.html#requirements",
    "href": "explanation/chem-boundary.html#requirements",
    "title": "Chem Boundary",
    "section": "",
    "text": "The chem boundary system must support several operations:\n\n\nDiffusion rates between neighboring voxels depend on the shared surface area, and volume-dependent reaction rates (e.g., bimolecular reactions) require accurate voxel volumes. For voxels entirely inside or outside the boundary, this is straightforward. However, voxels cut by the boundary require computing the partial volume and the areas of faces inside the domain.\nSpecifically, the diffusion hopping rate between two neighboring voxels is (Isaacson and Peskin 2006):\n\\[k = \\frac{D \\cdot A}{V \\cdot L}\\]\nwhere \\(D\\) is the diffusion coefficient, \\(A\\) is the shared face area, \\(V\\) is the source voxel volume, and \\(L\\) is the voxel spacing. For voxels cut by the boundary, \\(A\\) and \\(V\\) will be reduced from their full values of \\(L^2\\) and \\(L^3\\).\n\n\n\nWhen continuously positioned objects (such as filaments) react with diffusing species, the system must determine which chem voxel contains the object’s position.\n\n\n\nWhen a nucleation reaction creates a new positioned object, a position must be sampled within the voxel where the reaction occurred. The sampled position must be conservatively inside the boundary — if the boundary is defined by a mesh, positions too close to the surface can cause numerical issues during force calculations.\n\n\n\nWhen the chem boundary moves, some voxels may transition from inside to outside. These voxels must be deactivated, and their diffusing species must be moved to nearby active voxels.\nAdditionally, voxels with volumes below a threshold must be deactivated even if they are partially inside the boundary. This is necessary because volume-dependent reaction propensities can numerically explode when the volume is very small.",
    "crumbs": [
      "Explanation",
      "Chem Boundary"
    ]
  },
  {
    "objectID": "explanation/chem-boundary.html#truncated-signed-distance-fields",
    "href": "explanation/chem-boundary.html#truncated-signed-distance-fields",
    "title": "Chem Boundary",
    "section": "",
    "text": "Because the boundary can be quite complex, we make use of a truncated signed distance field (TSDF) to accelerate the various boundary computations. By using a grid based acceleration method, the assumption is that simulations are dense. Tree based methods such as a BVH would use much less memory and could be faster in very large sparse system.\n\n\nA signed distance field (SDF) stores, at each point in space, the signed distance to the nearest boundary surface. By convention, negative values indicate points inside the domain, and positive values indicate points outside. The zero level set of the SDF defines the boundary surface.\nA truncated signed distance field (TSDF) clamps the signed distance to ±max_distance. This truncation makes TSDF generation from meshes efficient: only grid points near the surface need accurate distance computations, while distant points are simply assigned the clamped value.\n\n\n\nThe TSDF is stored on a Cartesian grid that is aligned with the chem voxel grid but with finer spacing. Typically, the TSDF grid oversamples the chem voxels by a factor of 4 in each dimension.\nThe TSDF values are defined at the corners of the TSDF grid cells. Importantly, the corners of the chem voxels coincide with a subset of the TSDF grid points.\n\n\n\nRelationship between chem voxels and TSDF grid. Thick lines show chem voxel boundaries, thin lines show the finer TSDF grid. TSDF values are stored at grid intersections. Red dots mark chem voxel corners, which align with TSDF grid points. With 4× oversampling, each chem voxel edge spans 4 TSDF cells.\n\n\nThis alignment ensures that TSDF values at chem voxel corners are directly available without interpolation, while the finer grid provides the resolution needed for accurate cut voxel geometry calculations.",
    "crumbs": [
      "Explanation",
      "Chem Boundary"
    ]
  },
  {
    "objectID": "explanation/chem-boundary.html#tsdf-algorithms",
    "href": "explanation/chem-boundary.html#tsdf-algorithms",
    "title": "Chem Boundary",
    "section": "",
    "text": "The TSDF is computed differently for primitives and meshes, then combined by intersection (taking the maximum signed distance at each grid point).\nPrimitives (planes and capsules): For each grid point, the signed distance to each primitive is computed analytically:\n\nFor planes, this is simply the dot product of the position with the plane normal minus the offset.\nFor capsules, the distance is computed to the closest point on the capsule’s central axis, minus the capsule radius. The distance sign is flipped if the exterior of the capsule is part of the domain instead of the interior.\n\nThe maximum distance across all primitives gives the signed distance to the primitive boundary. Values are clamped to ±max_distance.\nMeshes: Computing signed distances to a triangular mesh is more involved. The algorithm follows the method described by Bærentzen and Aanæs (2002), which handles sharp corners and edges correctly using pseudo-normals.\nThe key steps are:\n\nCompute pseudo-normals: For each vertex, the pseudo-normal is the angle-weighted average of the normals of incident triangles. For each edge, it is the sum of the two adjacent triangle normals. These pseudo-normals ensure correct sign determination near sharp features.\nCompute unsigned squared distances: For each triangle, the algorithm iterates over nearby grid points (within max_distance of the triangle’s bounding box). For each point, it determines whether the closest point on the triangle is on the face, an edge, or a vertex, and computes the squared distance accordingly.\nDetermine sign: The sign is determined by the dot product of the vector from the closest surface point to the query point with the appropriate pseudo-normal (triangle, edge, or vertex).\nPropagate signs: Grid points far from the mesh may not be visited. A sweep in all six axis directions propagates the sign from computed regions to fill in the rest of the grid.\nConvert to distance: Finally, squared distances are converted to actual distances and clamped to ±max_distance.\n\nCombining boundaries: When both primitives and meshes define the boundary, their TSDFs are combined by taking the element-wise maximum. This implements the intersection of domains — a point is inside only if it is inside all boundary components.\n\n\n\nTo compute the volume and face areas of a chem voxel cut by the boundary, the algorithm uses the fine TSDF grid within that voxel.\nFor each chem voxel:\n\nExtract the local TSDF: The portion of the TSDF corresponding to this voxel (a subgrid of size oversampling_factor+1 in each dimension) is extracted.\nCheck trivial cases: If all TSDF values are negative (fully inside), the volume is simply L³ and all face areas are L². If all are positive (fully outside), volume and areas are zero.\nIsosurface extraction: For cut voxels, the marching tetrahedra algorithm (see Doi and Koide (1991)) extracts the zero isosurface as a triangle mesh, with the boundary capped where it intersects the voxel faces.\nCompute volume: The signed volume is computed by summing the signed volumes of tetrahedra formed by each isosurface triangle with the origin.\nCompute face areas: For each of the six faces of the voxel, the algorithm identifies which triangles lie on that face and sums their areas. This gives the portion of each face that is inside the domain, which is needed for diffusion rate calculations.\n\n\n\nMEDYAN C++: For membrane boundaries, the computeSlicedVolumeArea() method fits a single plane to the triangles overlapping a compartment (area-weighted average position and normal), then uses an analytical plane-cube slicing formula (planeUnitCubeSlice). This is fast but assumes the membrane is locally planar within each compartment.\nAnalytical methods: When the boundary is a simple primitive (plane, sphere, cylinder), exact formulas exist for the intersection of that primitive with a cube. These are exact but require separate implementations for each primitive type and do not handle combinations of boundaries.\nThe TSDF approach used in MEDYAN.jl handles arbitrary boundary shapes consistently, including curved surfaces and multiple intersecting boundaries, at the cost of more computation. The resolution is configurable through the oversampling factor.\n\n\n\n\nTo check whether a position is conservatively inside the boundary by at least a minimum distance, the algorithm uses the cached TSDF.\nBounding the signed distance using the triangle inequality:\nThe signed distance function satisfies the triangle inequality: for any two points, their signed distances differ by at most the Euclidean distance between them. If a TSDF vertex has value \\(t_v\\) and is at distance \\(r\\) from the query point \\(p\\), then:\n\\[\\text{TSDF}(p) \\in [t_v - r, t_v + r]\\]\nThis provides upper and lower bounds on the truncated signed distance at \\(p\\) without computing it directly.\nThe algorithm:\n\nLocate the containing TSDF voxel: Convert the position to TSDF grid coordinates and find the eight vertices of the containing voxel.\nFor each vertex, compute the distance \\(r\\) to the query point and apply the bounds:\n\nIf \\(t_v - r &gt; -\\text{min\\_distance}\\): even in the best case, the point cannot be inside by the required margin → return false\nIf \\(t_v + r &lt; -\\text{min\\_distance}\\): even in the worst case, the point is definitely inside by enough margin → return true\nOtherwise: this vertex is inconclusive, continue to next vertex\n\nFallback: If all eight vertices are inconclusive, return false (conservative).\n\nRestriction on min_distance:\nThe maximum possible distance \\(r\\) from a query point to any vertex of its containing TSDF voxel is the voxel diagonal: \\(r_{\\max} = \\sqrt{3} \\cdot \\text{grid\\_spacing}\\).\nFor the algorithm to ever return true, we need the upper bound to satisfy: \\[t_v + r &lt; -\\text{min\\_distance}\\]\nBut TSDF values are clamped to \\(\\pm\\text{max\\_distance}\\). For a point deep inside the boundary, \\(t_v = -\\text{max\\_distance}\\). In this case: \\[-\\text{max\\_distance} + r_{\\max} &lt; -\\text{min\\_distance}\\]\nRearranging: \\[\\text{min\\_distance} &lt; \\text{max\\_distance} - \\sqrt{3} \\cdot \\text{grid\\_spacing}\\]\nIf this condition is not met, the truncation could prevent the algorithm from proving a point is inside by the requested margin. The function throws an error in this case, suggesting the user increase max_distance.\nA more sophisticated approach could interpolate or combine information from multiple vertices to make better use of the available data, but the current algorithm keeps the logic simple.\nThis conservative approach is important for nucleation sampling — we must never place a new object outside the boundary or too close to a mesh surface.\n\n\nAn alternative approach would store, for each chem voxel, a list of nearby triangles. To check whether a point is inside by a margin, the algorithm would:\n\nLook up the triangles associated with the containing chem voxel\nCompute the exact signed distance to each triangle\nReturn true if the minimum signed distance is less than -min_distance\n\nThis triangle list approach has some advantages:\n\nExact results: No conservative approximation; the algorithm can determine exactly whether a point is inside by the required margin.\n\nHowever, the TSDF approach used in MEDYAN has its own advantages:\n\nConstant-time queries: The triangle inequality check examines only 8 TSDF values regardless of mesh complexity. The triangle list approach scales with the number of nearby triangles.\nUnified handling of primitives and meshes: The TSDF combines all boundary components into a single representation. A triangle list would need separate handling for analytical primitives.\n\nA BVH (bounding volume hierarchy) over triangles is another option that would give exact results with O(log n) query time. This is attractive for very large or sparse domains but adds implementation complexity and may have higher constant factors for the small, dense systems typical in MEDYAN.\nThe TSDF approach strikes a balance: it provides fast, conservative inside checks suitable for nucleation sampling while reusing the same data structure needed for volume and area computations.\n\n\n\n\nWhen a nucleation reaction fires in a chem voxel, a position must be sampled for the new object. The position must be conservatively inside the boundary to avoid numerical issues during subsequent force calculations.\nThe algorithm uses rejection sampling:\n\nSample a uniform random point within the chem voxel\nCheck if the point is inside the boundary by the required margin using the is_inside algorithm\nIf not, reject and repeat from step 1\n\nIf the voxel is mostly inside the boundary, rejection sampling is efficient. For voxels that are largely cut by the boundary, many samples may be rejected.",
    "crumbs": [
      "Explanation",
      "Chem Boundary"
    ]
  },
  {
    "objectID": "explanation/chem-boundary.html#voxel-deactivation-and-species-redistribution",
    "href": "explanation/chem-boundary.html#voxel-deactivation-and-species-redistribution",
    "title": "Chem Boundary",
    "section": "",
    "text": "When apply_chem_boundary! is called, voxels may need to be deactivated. A voxel is deactivated if:\n\nIts volume (after boundary cutting) falls below min_chem_voxel_volume_ratio × L³, where L is the voxel side length\n\n\n\nWhen a continuously positioned object (such as a filament monomer) participates in a reaction with diffusing species, the system must determine which chem voxel contains the object’s position.\nFor positions clearly inside the domain, this is simple integer division: divide the position by the voxel spacing and convert to a voxel index.\nHowever, the position may be in a voxel that has been deactivated (volume below threshold or outside the boundary). In this case, the algorithm searches for the nearest active voxel:\n\nCheck the voxel containing the position — if active, return it\nCheck the six face-adjacent neighbors — return the nearest active one\nIf no neighbor is active, search all voxels in the grid\n\nThis fallback ensures that objects near the boundary can still interact with chemistry, even if their exact position falls in a deactivated voxel.\n\n\n\nWhen a voxel is deactivated, any diffusing species it contains must be moved elsewhere. For each molecule in the deactivated voxel:\n\nSample a random position within the voxel\nFind the nearest active voxel to that position (using the position-to-voxel lookup with fallback)\nMove the molecule to that voxel\n\nThis approach approximately preserves spatial distribution — molecules near the boundary of the deactivated region move to the closest active voxel rather than being uniformly redistributed.\nIn practice, if boundaries move slowly, diffusion will naturally move most species out of shrinking voxels before they are deactivated, so few molecules need to be forcibly redistributed, but there is a lot of room for speeding up the redistribution, for example by sampling a multinomial distribution for how many molecules should move to each neighbor.",
    "crumbs": [
      "Explanation",
      "Chem Boundary"
    ]
  },
  {
    "objectID": "explanation/chem-boundary.html#caching-and-storage-in-the-snapshot-file",
    "href": "explanation/chem-boundary.html#caching-and-storage-in-the-snapshot-file",
    "title": "Chem Boundary",
    "section": "",
    "text": "The TSDF is computed when first needed and cached for reuse. The cache is invalidated when:\n\nThe chem boundary primitives change\nA membrane marked as a chem boundary moves (e.g., after energy minimization)\nThe oversampling factor or max distance settings change\n\nThe TSDF itself is not saved in snapshot files, as it can be regenerated from the boundary geometry. However, the configuration parameters (chem_boundary_oversampling_factor and chem_boundary_tsdf_max_distance) are saved so the TSDF can be regenerated consistently when loading.\nThe computed chem voxel volumes and areas are also saved in the snapshot, allowing chemistry to resume without recomputing them. The chem voxel volumes and areas must be explicitly recomputed with apply_chem_boundary!",
    "crumbs": [
      "Explanation",
      "Chem Boundary"
    ]
  },
  {
    "objectID": "reference/fileformats.html",
    "href": "reference/fileformats.html",
    "title": "File Formats",
    "section": "",
    "text": "MEDYAN.jl uses Zarr v2 zip store for saving snapshots.\n\n\n\n\n\n\nNoteOther Languages\n\n\n\nTo open the snapshots in python use zarr\n\n\n\n\nTrajectory outputs and logs are stored in a directory.\nThe output directory contains a traj sub directory with a header.json file, many $(most significant digits)/$(3 least significant digits).zip files, and finally a footer.json.\nThe initial state returned by setup is stored in traj/0/000.zip.\nInside the traj/$(i)/$(j).zip there is a snap/medyan group containing the snapshot of the MEDYAN.Context after the step. Other state may be stored in child groups of snap.\nThe header.json file also has a top level \"medyan\" key with a value describing the system being simulated.\nOther header information may be under other top level keys.\nSee https://github.com/medyan-dev/MEDYANSimRunner.jl for more details on the output directory structure.\n\n\n\nheader.json[\"medyan\"] contains static metadata about the simulation.\n\n\n\nusing MEDYAN\nimport JSON3\ncinit, s = MEDYAN.example_all_sites_context()\nJSON3.pretty(MEDYAN.header(cinit); allow_inf = true)\n\n{\n    \"version\": \"0.14.0\",\n    \"medyanInfo\": {\n        \"title\": \"MEDYAN.jl\",\n        \"version\": \"0.5.0-dev\",\n        \"sourceCodeUrl\": \"https://github.com/medyan-dev/MEDYAN.jl\"\n    },\n    \"size\": {\n        \"x(nm)\": 2000,\n        \"y(nm)\": 500,\n        \"z(nm)\": 500\n    },\n    \"chem_grid_size\": {\n        \"nx\": 4,\n        \"ny\": 1,\n        \"nz\": 1,\n        \"voxel_x(nm)\": 500,\n        \"voxel_y(nm)\": 500,\n        \"voxel_z(nm)\": 500\n    },\n    \"diffusing_species\": [\n        {\n            \"name\": \"b\"\n        },\n        {\n            \"name\": \"c\"\n        }\n    ],\n    \"membrane_diffusing_species\": [\n        {\n            \"name\": \"ma\"\n        },\n        {\n            \"name\": \"mb\"\n        },\n        {\n            \"name\": \"mc\"\n        }\n    ],\n    \"fixed_species\": [\n        {\n            \"name\": \"d\"\n        },\n        {\n            \"name\": \"a\"\n        }\n    ],\n    \"fila\": [\n        {\n            \"name\": \"a\",\n            \"radius(nm)\": 3,\n            \"monomerstates\": [\n                \"me\",\n                \"a\",\n                \"b\",\n                \"c\",\n                \"pe\"\n            ],\n            \"numpercylinder\": 40\n        },\n        {\n            \"name\": \"b\",\n            \"radius(nm)\": 3,\n            \"monomerstates\": [\n                \"me\",\n                \"a\",\n                \"b\",\n                \"c\",\n                \"pe\"\n            ],\n            \"numpercylinder\": 40,\n            \"twist_per_monomer\": -2.8999316802367323\n        }\n    ],\n    \"links\": [\n        {\n            \"name\": \"fila_tip_restraint\",\n            \"places\": [\n                \"fila_tip\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_restraint\",\n            \"places\": [\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_dummy\",\n            \"places\": [\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_2bonds\",\n            \"places\": [\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_distance_bond\",\n            \"places\": [\n                \"fila_mono\",\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"a\",\n            \"places\": [\n                \"fila_mono\",\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"b\",\n            \"places\": [\n                \"fila_mono\",\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"c\",\n            \"places\": [\n                \"fila_mono\",\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"memb_vert_restraint\",\n            \"places\": [\n                \"memb_vert\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_anchor_distance\",\n            \"places\": [\n                \"fila_mono\",\n                \"anchor\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_ball_distance\",\n            \"places\": [\n                \"fila_mono\",\n                \"ball\"\n            ]\n        }\n    ]\n}\n\n\n\n\n\n\nA snapshot describes the state of a Context at a single point in time.\nA snapshot can be used to set the state of a Context if it was constructed with the same system and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nBy default units are in nm, pN, and s. Coordinates are relative to the center of the grid.\nThe snapshot doesn’t hold the exact full state of a Context, simulations restarted from a snapshot may not have the exact same results because:\n\nThe snapshot doesn’t store the state of the random number generator.\nCoordinates may be rounded to save disk space.\nDictionaries and other internal data structures may get reordered and or resorted when the snapshot is loaded.\nMultithreading may be non deterministic.\n\nBut if rounding isn’t too extreme, the reloaded Context should have the same statistics.\n\n\nThe snapshot format is versioned by the “version” attribute. The current snapshot version is:\n\nusing MEDYAN\nMEDYAN.SNAPSHOT_VERSION\n\nv\"0.14.0\"\n\n\nCurrently before snapshot version 1.0.0 anything goes.\nAfter snapshot version 1.0.0 is released.\nSnapshots written with a previous snapshot version above v\"1\" should be readable. Snapshots written with a newer snapshot version are generally not readable.\nIf new agent types are added to MEDYAN.jl, usually only the minor version needs to be updated, as nothing special needs to be done to read older snapshot versions without that added agent type.\nIf new data is added to an existing agent type, also usually only the minor version needs to be increment, though the case of the new data not existing must be handled with some default.\nIf the way an existing agent type is stored significantly changes, such that external code analyzing the snapshot would need to be modified, the major version must be incremented. Also if possible there should be a function to update a snapshot from the old version to the new version.\n\n\nAny group, dataset, or attribute name prefixed with with “#” can change format or be removed without changing the snapshot version.\n“#experimental” is used for saving new types of agents or other data that doesn’t have a stable format yet.\n“#comment” is used for saving human readable comments that could change in format or wording.\n\n\n\n\n\nusing MEDYAN\nusing SmallZarrGroups\ncinit, s = MEDYAN.example_all_sites_context()\ngroup = MEDYAN.snapshot(cinit)\n\n\n\n\n\n\n\nNoteSnapshot 📂\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\ntime (s)\n\nattrs(group)[\"time (s)\"]\nDefault: No change\nSee MEDYAN.set_time! MEDYAN.get_time\n\n\n\nversion\n\nattrs(group)[\"version\"]\nDefault: No change\nSee Snapshot Versioning\n\n\n\nuuid\n\nattrs(group)[\"uuid\"]\nMust be set to exactly “37eee81f-88ae-4d11-b6b3-d38e1ccf0a08”\nto be considered a valid MEDYAN snapshot.\n\n\n\n\n\n\n\n\n\n\n\nNote📂\n\n\n\n\n\n\n\n\n\n\n\n\nNotechem\n\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nversion\n\nattrs(group[\"chem\"])[\"version\"]\nchem data major version, version 1 is described here.\n\n\n\n\n\n\n\n🔢 dc\n\ncollect(group[\"chem/dc\"])\nDefault: Empty\nA 4D Array of Int32 indexed by [species id, cartesian index] to give count.\nSee MEDYAN.chem_adddiffusingcount!\n\n\n\n🔢 fc\n\ncollect(group[\"chem/fc\"])\nDefault: Empty\nA 4D array of Int64 indexed by [species id, cartesian index] to give count. The count is a fixed point number Q31f32 reinterpreted as an integer. To get the count, divide the integers stored by 2^32.\nSee MEDYAN.chem_addfixedcount!\n\n\n\n🔢 a\n\ncollect(group[\"chem/a\"])\nDefault: Full areas\nA 4D array indexed by (side, cartesian index) to get the area of a minus side of a chem voxel. side 1 is x, 2 is y, and 3 is z. These can be recalculated based on the chem boundaries and membranes by MEDYAN.apply_chem_boundaries!\n\n\n\n🔢 v\n\ncollect(group[\"chem/v\"])\nDefault: Full volumes\nA 3D array indexed by a cartesian index to get the volume of a chem voxel. voxels can have zero volume if they were outside the boundaries when MEDYAN.apply_chem_boundaries! was called. These can be recalculated based on the chem boundaries and membranes by MEDYAN.apply_chem_boundaries!\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.Boundary\n\n\n🔢 ca\n\ncollect(group[\"chem/ca\"])\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 pl\n\ncollect(group[\"chem/pl\"])\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nNoteball\n\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nversion\n\nattrs(group[\"ball\"])[\"version\"]\nball data major version, version 1 is described here.\n\n\n\nposition_scale\n\nattrs(group[\"ball\"])[\"position_scale\"]\nDefault: No effect\nBall positions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\n\n\n🔢 p\n\ncollect(group[\"ball/p\"])\nEach row is a ball position in nm.\n\n\n\n🔢 r\n\ncollect(group[\"ball/r\"])\nBall radius in nm.\n\n\n\n🔢 k\n\ncollect(group[\"ball/k\"])\nBall stiffness in pN/nm.\n\n\n\n🔢 s\n\ncollect(group[\"ball/s\"])\nEach row is a ball state integers.\n\n\n\n🔢 im\n\ncollect(group[\"ball/im\"])\nBoolean vector indicating whether each ball is marked as minimized. true means the ball’s position has been updated by minimize_energy! since it was last created or modified. May be absent in older snapshots (defaults to false for all balls when loading).\n\n\n\n\n\n\n\n\n\n\n\n\nNotefila\n\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nversion\n\nattrs(group[\"fila\"])[\"version\"]\nfila data major version, version 1 is described here.\n\n\n\nposition_scale\n\nattrs(group[\"fila\"])[\"position_scale\"]\nDefault: No effect\nFilament positions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\nThere is a subgroup for each filament type with at least one filament. The subgroups are named by their filament typeid. For example:\n\n\n\n\n\n\n\nNote📂 1\n\n\n\n\n\n\n\n🔢 load\n\ncollect(group[\"fila/1/load\"])\nFilament end load forces (pN).\nEach row is the load force on the minus and plus ends of a filament.\n\n\n\n🔢 newm\n\ncollect(group[\"fila/1/newm\"])\nNumber of newly added monomers to the filament minus ends since last minimization.\n\n\n\n🔢 newp\n\ncollect(group[\"fila/1/newp\"])\nNumber of newly added monomers to the filament plus ends since last minimization.\n\n\n\n🔢 clen\n\ncollect(group[\"fila/1/clen\"])\nNumber of cylinders per filament.\n\n\n\n🔢 mlen\n\ncollect(group[\"fila/1/mlen\"])\nNumber of monomers per filament.\n\n\n\n🔢 nm\n\ncollect(group[\"fila/1/nm\"])\nThe monomer ids at the minus ends of the cylinders.\n                                   |\n                        -----+-----|-----+-----\n    minus end &lt;----       M  |  M  | (M) |  M        ----&gt; plus end\n                        -----+-----|-----+-----\n                                   |\n                                   ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\n\n\n\n🔢 np\n\ncollect(group[\"fila/1/np\"])\nEach row is a node position in nm.\n\n\n\n🔢 ms\n\ncollect(group[\"fila/1/ms\"])\nMonomer states.\n\n\n\n🔢 mdir\n\ncollect(group[\"fila/2/mdir\"])\nThis array only exists if the filament type is twistable. Each row is the material direction associated with the center of each chem cylinder.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotelinks\n\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nversion\n\nattrs(group[\"links\"])[\"version\"]\nlink data major version, version 1 is described here.\n\n\n\n\n\nThere is a subgroup for each link type with at least one current or past link. The subgroups are named by their link typeid. For example:\n\n\n\n\n\n\n\nNote📂 8\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nnum_links\n\nattrs(group[\"links/8\"])[\"num_links\"]\nNumber of links of this type.\n\n\n\nnext_lid\n\nattrs(group[\"links/8\"])[\"next_lid\"]\nThe default next link id for new links.\nThis should be greater than all the existing link ids of this type.\n\n\n\n\n\n\n🔢 be\n\ncollect(group[\"links/8/be\"])\nThe bonds that are enabled.\nEach row of this matrix represents a link, each column represents a bond.\n\n\n\n🔢 ids\n\ncollect(group[\"links/8/ids\"])\nThe link ids.\n\n\n\n🔢 im\n\ncollect(group[\"links/8/im\"])\nIs the link minimized. A link is marked as not minimized when created, and then marked as minimized after running mechanics.\n\n\n\n🔢 re\n\ncollect(group[\"links/8/re\"])\nThe reactions that are enabled.\nEach row of this matrix represents a link, each column represents a reaction.\n\n\n\n🔢 tags\n\ncollect(group[\"links/8/tags\"])\nThe tags of the places the links are attached to.\nEach row of this matrix represents a link.\nEach place has two adjacent columns. First a index into the tags, and next a tag generation. The place type can be found in the header file. If the place is not attached, the generation and index will be zero.\n\n\n\n📂 bs\n\nDefault: default bond states\nSee MEDYAN.update_link!.\nThe state of link bonds, organized in a nested struct of vector like form. Any static arrays will be unwrapped into a tuple of vectors, in column major order. The “name” attribute of each subgroup and dataset is the corresponding property name in the StructArray Any property in the default state that isn’t in the snapshot will stay at its default value.\n\ngroup[\"links/8/bs\"]\n\n📂\n└─ 📂 1 🏷️ name =&gt; \"1\",\n   ├─ 🔢 1: 4 Float64  🏷️ name =&gt; \"k\",\n   └─ 🔢 2: 4 Float64  🏷️ name =&gt; \"L0\",\n\n\n\n\n\n📂 s\n\nDefault: default states\nSee MEDYAN.update_link!.\nThe state of link, organized in a nested struct of vector like form. Any static arrays will be unwrapped into a tuple of vectors, in column major order. The “name” attribute of each subgroup and dataset is the corresponding property name in the StructArray Any property in the default state that isn’t in the snapshot will stay at its default value.\n\ngroup[\"links/8/s\"]\n\n📂\n├─ 🔢 1: 4 Int64  🏷️ name =&gt; \"a\",\n└─ 🔢 2: 4 Float64  🏷️ name =&gt; \"b\",\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotemechboundary\n\n\n\n\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.Boundary\n\n\n🔢 capsules\n\ncollect(group[\"mechboundary/capsules\"])\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 planes\n\ncollect(group[\"mechboundary/planes\"])\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nNotememb\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nversion\n\nattrs(group[\"memb\"])[\"version\"]\nmemb data major version, version 1 is described here.\n\n\n\nnum_membranes\n\nattrs(group[\"memb\"])[\"num_membranes\"]\nTotal number of membranes.\n\n\n\nposition_scale\n\nattrs(group[\"memb\"])[\"position_scale\"]\nDefault: No effect\nPositions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\nThere is a subgroup for each membrane. The subgroups are named by the membrane index. For example:\n\n\n\n\n\n\n\nNote📂 1\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\ntypeid\n\nattrs(group[\"memb/1\"])[\"typeid\"]\nThis membrane’s type id.\n\n\n\n\n\n\n🔢 trilist\n\ncollect(group[\"memb/1/trilist\"])\nEach column is the 3 vertex indexes of a triangle. Indexes are one based, and follow the right hand rule. Looking at the triangle from the outside in, they have counterclockwise winding.\n\n\n\n🔢 vertlist\n\ncollect(group[\"memb/1/vertlist\"])\nEach column is a vertex coordinate in nm.\n\n\n\noptional 🔢 copynumbers\n\ncollect(group[\"memb/1/copynumbers\"])\nArray of vertex membrane species copynumbers. If the membrane has no defined species this dataset will not exist.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteTags\n\n\n\n\n\nThere is a subgroup for each tag type with at least one current or past tag. Each tag type stores tag generations as a vector of UInt32 in g and packed places in p_n where n is the packed format version. If the generation is odd the tag is valid. otherwise the tag is an empty slot à la https://docs.rs/slotmap/latest/slotmap/.\n\n\n\n\n\n\nNote📂 fila_mono\n\n\n\n\n\n\n\n🔢 p_1\n\ncollect(group[\"tags/fila_mono/p_1\"])\nThe filament monomer places for each tag stored as a vector of UInt64. Not all monomers will have tags. For tag i of n total tags, p_1[i]&gt;&gt;&gt;32 is the filament type id, (p_1[i]%UInt32)&gt;&gt;1 is the filament index, and p_1[i+n] is the zigzag encoded monomer id.\n\n\n\n\n\n\n\n\n\n\nNote📂 fila_tip\n\n\n\n\n\n\n\n🔢 p_1\n\ncollect(group[\"tags/fila_tip/p_1\"])\nThe filament tip places for each tag stored as a vector of UInt64. All filament tips will have tags. For tag i of n total tags, p_1[i]&gt;&gt;&gt;32 is the filament type id, (p_1[i]%UInt32)&gt;&gt;1 is the filament index, and p_1[i] is odd for the minus end of the filament and even for the plus end.",
    "crumbs": [
      "Reference",
      "File Formats"
    ]
  },
  {
    "objectID": "reference/fileformats.html#trajectory-output-directory",
    "href": "reference/fileformats.html#trajectory-output-directory",
    "title": "File Formats",
    "section": "",
    "text": "Trajectory outputs and logs are stored in a directory.\nThe output directory contains a traj sub directory with a header.json file, many $(most significant digits)/$(3 least significant digits).zip files, and finally a footer.json.\nThe initial state returned by setup is stored in traj/0/000.zip.\nInside the traj/$(i)/$(j).zip there is a snap/medyan group containing the snapshot of the MEDYAN.Context after the step. Other state may be stored in child groups of snap.\nThe header.json file also has a top level \"medyan\" key with a value describing the system being simulated.\nOther header information may be under other top level keys.\nSee https://github.com/medyan-dev/MEDYANSimRunner.jl for more details on the output directory structure.",
    "crumbs": [
      "Reference",
      "File Formats"
    ]
  },
  {
    "objectID": "reference/fileformats.html#medyan-header-json-object.",
    "href": "reference/fileformats.html#medyan-header-json-object.",
    "title": "File Formats",
    "section": "",
    "text": "header.json[\"medyan\"] contains static metadata about the simulation.\n\n\n\nusing MEDYAN\nimport JSON3\ncinit, s = MEDYAN.example_all_sites_context()\nJSON3.pretty(MEDYAN.header(cinit); allow_inf = true)\n\n{\n    \"version\": \"0.14.0\",\n    \"medyanInfo\": {\n        \"title\": \"MEDYAN.jl\",\n        \"version\": \"0.5.0-dev\",\n        \"sourceCodeUrl\": \"https://github.com/medyan-dev/MEDYAN.jl\"\n    },\n    \"size\": {\n        \"x(nm)\": 2000,\n        \"y(nm)\": 500,\n        \"z(nm)\": 500\n    },\n    \"chem_grid_size\": {\n        \"nx\": 4,\n        \"ny\": 1,\n        \"nz\": 1,\n        \"voxel_x(nm)\": 500,\n        \"voxel_y(nm)\": 500,\n        \"voxel_z(nm)\": 500\n    },\n    \"diffusing_species\": [\n        {\n            \"name\": \"b\"\n        },\n        {\n            \"name\": \"c\"\n        }\n    ],\n    \"membrane_diffusing_species\": [\n        {\n            \"name\": \"ma\"\n        },\n        {\n            \"name\": \"mb\"\n        },\n        {\n            \"name\": \"mc\"\n        }\n    ],\n    \"fixed_species\": [\n        {\n            \"name\": \"d\"\n        },\n        {\n            \"name\": \"a\"\n        }\n    ],\n    \"fila\": [\n        {\n            \"name\": \"a\",\n            \"radius(nm)\": 3,\n            \"monomerstates\": [\n                \"me\",\n                \"a\",\n                \"b\",\n                \"c\",\n                \"pe\"\n            ],\n            \"numpercylinder\": 40\n        },\n        {\n            \"name\": \"b\",\n            \"radius(nm)\": 3,\n            \"monomerstates\": [\n                \"me\",\n                \"a\",\n                \"b\",\n                \"c\",\n                \"pe\"\n            ],\n            \"numpercylinder\": 40,\n            \"twist_per_monomer\": -2.8999316802367323\n        }\n    ],\n    \"links\": [\n        {\n            \"name\": \"fila_tip_restraint\",\n            \"places\": [\n                \"fila_tip\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_restraint\",\n            \"places\": [\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_dummy\",\n            \"places\": [\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_2bonds\",\n            \"places\": [\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_distance_bond\",\n            \"places\": [\n                \"fila_mono\",\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"a\",\n            \"places\": [\n                \"fila_mono\",\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"b\",\n            \"places\": [\n                \"fila_mono\",\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"c\",\n            \"places\": [\n                \"fila_mono\",\n                \"fila_mono\"\n            ]\n        },\n        {\n            \"name\": \"memb_vert_restraint\",\n            \"places\": [\n                \"memb_vert\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_anchor_distance\",\n            \"places\": [\n                \"fila_mono\",\n                \"anchor\"\n            ]\n        },\n        {\n            \"name\": \"fila_mono_ball_distance\",\n            \"places\": [\n                \"fila_mono\",\n                \"ball\"\n            ]\n        }\n    ]\n}",
    "crumbs": [
      "Reference",
      "File Formats"
    ]
  },
  {
    "objectID": "reference/fileformats.html#snapshot-group",
    "href": "reference/fileformats.html#snapshot-group",
    "title": "File Formats",
    "section": "",
    "text": "A snapshot describes the state of a Context at a single point in time.\nA snapshot can be used to set the state of a Context if it was constructed with the same system and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nBy default units are in nm, pN, and s. Coordinates are relative to the center of the grid.\nThe snapshot doesn’t hold the exact full state of a Context, simulations restarted from a snapshot may not have the exact same results because:\n\nThe snapshot doesn’t store the state of the random number generator.\nCoordinates may be rounded to save disk space.\nDictionaries and other internal data structures may get reordered and or resorted when the snapshot is loaded.\nMultithreading may be non deterministic.\n\nBut if rounding isn’t too extreme, the reloaded Context should have the same statistics.\n\n\nThe snapshot format is versioned by the “version” attribute. The current snapshot version is:\n\nusing MEDYAN\nMEDYAN.SNAPSHOT_VERSION\n\nv\"0.14.0\"\n\n\nCurrently before snapshot version 1.0.0 anything goes.\nAfter snapshot version 1.0.0 is released.\nSnapshots written with a previous snapshot version above v\"1\" should be readable. Snapshots written with a newer snapshot version are generally not readable.\nIf new agent types are added to MEDYAN.jl, usually only the minor version needs to be updated, as nothing special needs to be done to read older snapshot versions without that added agent type.\nIf new data is added to an existing agent type, also usually only the minor version needs to be increment, though the case of the new data not existing must be handled with some default.\nIf the way an existing agent type is stored significantly changes, such that external code analyzing the snapshot would need to be modified, the major version must be incremented. Also if possible there should be a function to update a snapshot from the old version to the new version.\n\n\nAny group, dataset, or attribute name prefixed with with “#” can change format or be removed without changing the snapshot version.\n“#experimental” is used for saving new types of agents or other data that doesn’t have a stable format yet.\n“#comment” is used for saving human readable comments that could change in format or wording.\n\n\n\n\n\nusing MEDYAN\nusing SmallZarrGroups\ncinit, s = MEDYAN.example_all_sites_context()\ngroup = MEDYAN.snapshot(cinit)\n\n\n\n\n\n\n\nNoteSnapshot 📂\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\ntime (s)\n\nattrs(group)[\"time (s)\"]\nDefault: No change\nSee MEDYAN.set_time! MEDYAN.get_time\n\n\n\nversion\n\nattrs(group)[\"version\"]\nDefault: No change\nSee Snapshot Versioning\n\n\n\nuuid\n\nattrs(group)[\"uuid\"]\nMust be set to exactly “37eee81f-88ae-4d11-b6b3-d38e1ccf0a08”\nto be considered a valid MEDYAN snapshot.\n\n\n\n\n\n\n\n\n\n\n\nNote📂\n\n\n\n\n\n\n\n\n\n\n\n\nNotechem\n\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nversion\n\nattrs(group[\"chem\"])[\"version\"]\nchem data major version, version 1 is described here.\n\n\n\n\n\n\n\n🔢 dc\n\ncollect(group[\"chem/dc\"])\nDefault: Empty\nA 4D Array of Int32 indexed by [species id, cartesian index] to give count.\nSee MEDYAN.chem_adddiffusingcount!\n\n\n\n🔢 fc\n\ncollect(group[\"chem/fc\"])\nDefault: Empty\nA 4D array of Int64 indexed by [species id, cartesian index] to give count. The count is a fixed point number Q31f32 reinterpreted as an integer. To get the count, divide the integers stored by 2^32.\nSee MEDYAN.chem_addfixedcount!\n\n\n\n🔢 a\n\ncollect(group[\"chem/a\"])\nDefault: Full areas\nA 4D array indexed by (side, cartesian index) to get the area of a minus side of a chem voxel. side 1 is x, 2 is y, and 3 is z. These can be recalculated based on the chem boundaries and membranes by MEDYAN.apply_chem_boundaries!\n\n\n\n🔢 v\n\ncollect(group[\"chem/v\"])\nDefault: Full volumes\nA 3D array indexed by a cartesian index to get the volume of a chem voxel. voxels can have zero volume if they were outside the boundaries when MEDYAN.apply_chem_boundaries! was called. These can be recalculated based on the chem boundaries and membranes by MEDYAN.apply_chem_boundaries!\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.Boundary\n\n\n🔢 ca\n\ncollect(group[\"chem/ca\"])\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 pl\n\ncollect(group[\"chem/pl\"])\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nNoteball\n\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nversion\n\nattrs(group[\"ball\"])[\"version\"]\nball data major version, version 1 is described here.\n\n\n\nposition_scale\n\nattrs(group[\"ball\"])[\"position_scale\"]\nDefault: No effect\nBall positions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\n\n\n🔢 p\n\ncollect(group[\"ball/p\"])\nEach row is a ball position in nm.\n\n\n\n🔢 r\n\ncollect(group[\"ball/r\"])\nBall radius in nm.\n\n\n\n🔢 k\n\ncollect(group[\"ball/k\"])\nBall stiffness in pN/nm.\n\n\n\n🔢 s\n\ncollect(group[\"ball/s\"])\nEach row is a ball state integers.\n\n\n\n🔢 im\n\ncollect(group[\"ball/im\"])\nBoolean vector indicating whether each ball is marked as minimized. true means the ball’s position has been updated by minimize_energy! since it was last created or modified. May be absent in older snapshots (defaults to false for all balls when loading).\n\n\n\n\n\n\n\n\n\n\n\n\nNotefila\n\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nversion\n\nattrs(group[\"fila\"])[\"version\"]\nfila data major version, version 1 is described here.\n\n\n\nposition_scale\n\nattrs(group[\"fila\"])[\"position_scale\"]\nDefault: No effect\nFilament positions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\nThere is a subgroup for each filament type with at least one filament. The subgroups are named by their filament typeid. For example:\n\n\n\n\n\n\n\nNote📂 1\n\n\n\n\n\n\n\n🔢 load\n\ncollect(group[\"fila/1/load\"])\nFilament end load forces (pN).\nEach row is the load force on the minus and plus ends of a filament.\n\n\n\n🔢 newm\n\ncollect(group[\"fila/1/newm\"])\nNumber of newly added monomers to the filament minus ends since last minimization.\n\n\n\n🔢 newp\n\ncollect(group[\"fila/1/newp\"])\nNumber of newly added monomers to the filament plus ends since last minimization.\n\n\n\n🔢 clen\n\ncollect(group[\"fila/1/clen\"])\nNumber of cylinders per filament.\n\n\n\n🔢 mlen\n\ncollect(group[\"fila/1/mlen\"])\nNumber of monomers per filament.\n\n\n\n🔢 nm\n\ncollect(group[\"fila/1/nm\"])\nThe monomer ids at the minus ends of the cylinders.\n                                   |\n                        -----+-----|-----+-----\n    minus end &lt;----       M  |  M  | (M) |  M        ----&gt; plus end\n                        -----+-----|-----+-----\n                                   |\n                                   ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\n\n\n\n🔢 np\n\ncollect(group[\"fila/1/np\"])\nEach row is a node position in nm.\n\n\n\n🔢 ms\n\ncollect(group[\"fila/1/ms\"])\nMonomer states.\n\n\n\n🔢 mdir\n\ncollect(group[\"fila/2/mdir\"])\nThis array only exists if the filament type is twistable. Each row is the material direction associated with the center of each chem cylinder.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotelinks\n\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nversion\n\nattrs(group[\"links\"])[\"version\"]\nlink data major version, version 1 is described here.\n\n\n\n\n\nThere is a subgroup for each link type with at least one current or past link. The subgroups are named by their link typeid. For example:\n\n\n\n\n\n\n\nNote📂 8\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nnum_links\n\nattrs(group[\"links/8\"])[\"num_links\"]\nNumber of links of this type.\n\n\n\nnext_lid\n\nattrs(group[\"links/8\"])[\"next_lid\"]\nThe default next link id for new links.\nThis should be greater than all the existing link ids of this type.\n\n\n\n\n\n\n🔢 be\n\ncollect(group[\"links/8/be\"])\nThe bonds that are enabled.\nEach row of this matrix represents a link, each column represents a bond.\n\n\n\n🔢 ids\n\ncollect(group[\"links/8/ids\"])\nThe link ids.\n\n\n\n🔢 im\n\ncollect(group[\"links/8/im\"])\nIs the link minimized. A link is marked as not minimized when created, and then marked as minimized after running mechanics.\n\n\n\n🔢 re\n\ncollect(group[\"links/8/re\"])\nThe reactions that are enabled.\nEach row of this matrix represents a link, each column represents a reaction.\n\n\n\n🔢 tags\n\ncollect(group[\"links/8/tags\"])\nThe tags of the places the links are attached to.\nEach row of this matrix represents a link.\nEach place has two adjacent columns. First a index into the tags, and next a tag generation. The place type can be found in the header file. If the place is not attached, the generation and index will be zero.\n\n\n\n📂 bs\n\nDefault: default bond states\nSee MEDYAN.update_link!.\nThe state of link bonds, organized in a nested struct of vector like form. Any static arrays will be unwrapped into a tuple of vectors, in column major order. The “name” attribute of each subgroup and dataset is the corresponding property name in the StructArray Any property in the default state that isn’t in the snapshot will stay at its default value.\n\ngroup[\"links/8/bs\"]\n\n📂\n└─ 📂 1 🏷️ name =&gt; \"1\",\n   ├─ 🔢 1: 4 Float64  🏷️ name =&gt; \"k\",\n   └─ 🔢 2: 4 Float64  🏷️ name =&gt; \"L0\",\n\n\n\n\n\n📂 s\n\nDefault: default states\nSee MEDYAN.update_link!.\nThe state of link, organized in a nested struct of vector like form. Any static arrays will be unwrapped into a tuple of vectors, in column major order. The “name” attribute of each subgroup and dataset is the corresponding property name in the StructArray Any property in the default state that isn’t in the snapshot will stay at its default value.\n\ngroup[\"links/8/s\"]\n\n📂\n├─ 🔢 1: 4 Int64  🏷️ name =&gt; \"a\",\n└─ 🔢 2: 4 Float64  🏷️ name =&gt; \"b\",\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotemechboundary\n\n\n\n\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.Boundary\n\n\n🔢 capsules\n\ncollect(group[\"mechboundary/capsules\"])\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 planes\n\ncollect(group[\"mechboundary/planes\"])\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nNotememb\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\nversion\n\nattrs(group[\"memb\"])[\"version\"]\nmemb data major version, version 1 is described here.\n\n\n\nnum_membranes\n\nattrs(group[\"memb\"])[\"num_membranes\"]\nTotal number of membranes.\n\n\n\nposition_scale\n\nattrs(group[\"memb\"])[\"position_scale\"]\nDefault: No effect\nPositions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\nThere is a subgroup for each membrane. The subgroups are named by the membrane index. For example:\n\n\n\n\n\n\n\nNote📂 1\n\n\n\n\n\n\n\n\n\n\n\nNote🏷️\n\n\n\n\n\n\n\ntypeid\n\nattrs(group[\"memb/1\"])[\"typeid\"]\nThis membrane’s type id.\n\n\n\n\n\n\n🔢 trilist\n\ncollect(group[\"memb/1/trilist\"])\nEach column is the 3 vertex indexes of a triangle. Indexes are one based, and follow the right hand rule. Looking at the triangle from the outside in, they have counterclockwise winding.\n\n\n\n🔢 vertlist\n\ncollect(group[\"memb/1/vertlist\"])\nEach column is a vertex coordinate in nm.\n\n\n\noptional 🔢 copynumbers\n\ncollect(group[\"memb/1/copynumbers\"])\nArray of vertex membrane species copynumbers. If the membrane has no defined species this dataset will not exist.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNoteTags\n\n\n\n\n\nThere is a subgroup for each tag type with at least one current or past tag. Each tag type stores tag generations as a vector of UInt32 in g and packed places in p_n where n is the packed format version. If the generation is odd the tag is valid. otherwise the tag is an empty slot à la https://docs.rs/slotmap/latest/slotmap/.\n\n\n\n\n\n\nNote📂 fila_mono\n\n\n\n\n\n\n\n🔢 p_1\n\ncollect(group[\"tags/fila_mono/p_1\"])\nThe filament monomer places for each tag stored as a vector of UInt64. Not all monomers will have tags. For tag i of n total tags, p_1[i]&gt;&gt;&gt;32 is the filament type id, (p_1[i]%UInt32)&gt;&gt;1 is the filament index, and p_1[i+n] is the zigzag encoded monomer id.\n\n\n\n\n\n\n\n\n\n\nNote📂 fila_tip\n\n\n\n\n\n\n\n🔢 p_1\n\ncollect(group[\"tags/fila_tip/p_1\"])\nThe filament tip places for each tag stored as a vector of UInt64. All filament tips will have tags. For tag i of n total tags, p_1[i]&gt;&gt;&gt;32 is the filament type id, (p_1[i]%UInt32)&gt;&gt;1 is the filament index, and p_1[i] is odd for the minus end of the filament and even for the plus end.",
    "crumbs": [
      "Reference",
      "File Formats"
    ]
  },
  {
    "objectID": "docstrings/medyan.set_time--a6dd8f73f68a3759.html",
    "href": "docstrings/medyan.set_time--a6dd8f73f68a3759.html",
    "title": "MEDYAN.set_time!",
    "section": "",
    "text": "set_time!(c::MEDYAN.Context, x::Float64) -&gt; Float64\nTime (s)"
  },
  {
    "objectID": "docstrings/medyan.set_time--a6dd8f73f68a3759.html#tuple-medyan.context--float64--5f0fd8a48f76a337",
    "href": "docstrings/medyan.set_time--a6dd8f73f68a3759.html#tuple-medyan.context--float64--5f0fd8a48f76a337",
    "title": "MEDYAN.set_time!",
    "section": "",
    "text": "set_time!(c::MEDYAN.Context, x::Float64) -&gt; Float64\nTime (s)"
  },
  {
    "objectID": "docstrings/medyan.get_position-5ca1f4a736664040.html",
    "href": "docstrings/medyan.get_position-5ca1f4a736664040.html",
    "title": "MEDYAN.get_position",
    "section": "",
    "text": "get_position(c::Context, x::Union{Tag, Place})::SVector{3, Float64}\nReturn the position of x. Throw an error if x doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.get_position-5ca1f4a736664040.html#tuple-medyan.context--medyan.tag--fedde092ce150cde",
    "href": "docstrings/medyan.get_position-5ca1f4a736664040.html#tuple-medyan.context--medyan.tag--fedde092ce150cde",
    "title": "MEDYAN.get_position",
    "section": "",
    "text": "get_position(c::Context, x::Union{Tag, Place})::SVector{3, Float64}\nReturn the position of x. Throw an error if x doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.has_tag-d550430128572035.html",
    "href": "docstrings/medyan.has_tag-d550430128572035.html",
    "title": "MEDYAN.has_tag",
    "section": "",
    "text": "has_tag(c::Context, p::Place)::Bool\nReturn true iff p has a tag. Otherwise return false. If !place_exists(c, p) return false."
  },
  {
    "objectID": "docstrings/medyan.has_tag-d550430128572035.html#tuple-medyan.context--medyan.place--5f4876ae276f10cb",
    "href": "docstrings/medyan.has_tag-d550430128572035.html#tuple-medyan.context--medyan.place--5f4876ae276f10cb",
    "title": "MEDYAN.has_tag",
    "section": "",
    "text": "has_tag(c::Context, p::Place)::Bool\nReturn true iff p has a tag. Otherwise return false. If !place_exists(c, p) return false."
  },
  {
    "objectID": "docstrings/medyan.make_memb_rectangle--68b3d30b96f64135.html",
    "href": "docstrings/medyan.make_memb_rectangle--68b3d30b96f64135.html",
    "title": "MEDYAN.make_memb_rectangle!",
    "section": "",
    "text": "make_memb_rectangle!(c::Context; width, height=width, center=SA[0.0,0.0,0.0])::MembId\nCreate a new rectangular membrane in the simulation context and return its membrane identifier.\nThe membrane is by default in the X-Y plane, and the outside of the membrane is on the +Z side.\nThe mesh is then scaled by width in the X direction, height in the Y direction, rotated by rotation, and translated to center.\n\n\n\nwidth::Float64: The length of the membrane in the X direction (nm)\nheight::Float64=width: The length of the membrane in the Y direction (nm)\ncenter::SVector{3,Float64}=SA[0.0,0.0,0.0]: Center of the sphere (nm)\nrotation=I: 3x3 matrix to rotate the sphere around its center\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior."
  },
  {
    "objectID": "docstrings/medyan.make_memb_rectangle--68b3d30b96f64135.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.make_memb_rectangle--68b3d30b96f64135.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.make_memb_rectangle!",
    "section": "",
    "text": "make_memb_rectangle!(c::Context; width, height=width, center=SA[0.0,0.0,0.0])::MembId\nCreate a new rectangular membrane in the simulation context and return its membrane identifier.\nThe membrane is by default in the X-Y plane, and the outside of the membrane is on the +Z side.\nThe mesh is then scaled by width in the X direction, height in the Y direction, rotated by rotation, and translated to center.\n\n\n\nwidth::Float64: The length of the membrane in the X direction (nm)\nheight::Float64=width: The length of the membrane in the Y direction (nm)\ncenter::SVector{3,Float64}=SA[0.0,0.0,0.0]: Center of the sphere (nm)\nrotation=I: 3x3 matrix to rotate the sphere around its center\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior."
  },
  {
    "objectID": "docstrings/medyan.membvertidx-4b26f8c9d72f1f49.html",
    "href": "docstrings/medyan.membvertidx-4b26f8c9d72f1f49.html",
    "title": "MEDYAN.MembVertIdx",
    "section": "",
    "text": "MembVertIdx &lt;: Place\nAn index identifying a specific vertex on a membrane mesh. Membranes are represented as triangular meshes, and vertices can participate in chemical reactions and mechanical links.\nThis index may be invalidated by mesh adaptation or membrane removal. Use a Tag{MembVertIdx} for a long-term reference that remains valid across mutations.\n\n\n\nMembVertIdx(): Creates a null vertex index with both indices set to 0\nMembVertIdx(memb_idx::Integer, vert_idx::Integer): Creates a vertex index for the specified membrane and vertex\nMembVertIdx(c::Context, memb_idx::Integer, vert_idx::Integer): Creates a vertex index for the specified membrane and vertex\n\n\n\n\n\nmemb_idx::UInt32: Index of the membrane in the context\nvert_idx::UInt32: Index of the vertex within the membrane mesh\n\n\n\n\nSee make_memb!, make_memb_sphere!, make_memb_rectangle!."
  },
  {
    "objectID": "docstrings/medyan.membvertidx-4b26f8c9d72f1f49.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.membvertidx-4b26f8c9d72f1f49.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.MembVertIdx",
    "section": "",
    "text": "MembVertIdx &lt;: Place\nAn index identifying a specific vertex on a membrane mesh. Membranes are represented as triangular meshes, and vertices can participate in chemical reactions and mechanical links.\nThis index may be invalidated by mesh adaptation or membrane removal. Use a Tag{MembVertIdx} for a long-term reference that remains valid across mutations.\n\n\n\nMembVertIdx(): Creates a null vertex index with both indices set to 0\nMembVertIdx(memb_idx::Integer, vert_idx::Integer): Creates a vertex index for the specified membrane and vertex\nMembVertIdx(c::Context, memb_idx::Integer, vert_idx::Integer): Creates a vertex index for the specified membrane and vertex\n\n\n\n\n\nmemb_idx::UInt32: Index of the membrane in the context\nvert_idx::UInt32: Index of the vertex within the membrane mesh\n\n\n\n\nSee make_memb!, make_memb_sphere!, make_memb_rectangle!."
  },
  {
    "objectID": "docstrings/medyan.addfilamentsite--eb6bfd871a21b6f4.html",
    "href": "docstrings/medyan.addfilamentsite--eb6bfd871a21b6f4.html",
    "title": "MEDYAN.addfilamentsite!",
    "section": "",
    "text": "addfilamentsite!(s::SysDef,filamenttypename::Symbol,filamentsitename::Symbol,site)"
  },
  {
    "objectID": "docstrings/medyan.addfilamentsite--eb6bfd871a21b6f4.html#tuple-medyan.sysdef--symbol--symbol--any--b9a0ed342fa77751",
    "href": "docstrings/medyan.addfilamentsite--eb6bfd871a21b6f4.html#tuple-medyan.sysdef--symbol--symbol--any--b9a0ed342fa77751",
    "title": "MEDYAN.addfilamentsite!",
    "section": "",
    "text": "addfilamentsite!(s::SysDef,filamenttypename::Symbol,filamentsitename::Symbol,site)"
  },
  {
    "objectID": "docstrings/medyan.fila_typeid-1616b490df0cda1e.html",
    "href": "docstrings/medyan.fila_typeid-1616b490df0cda1e.html",
    "title": "MEDYAN.fila_typeid",
    "section": "",
    "text": "fila_typeid(c::Context, f::Union{Tag, FilaIdx})::Int\nfila_typeid(c::Context; type::Union{Symbol,Integer})::Int\nReturn the typeid of a filament f or associated with type."
  },
  {
    "objectID": "docstrings/medyan.fila_typeid-1616b490df0cda1e.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.fila_typeid-1616b490df0cda1e.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.fila_typeid",
    "section": "",
    "text": "fila_typeid(c::Context, f::Union{Tag, FilaIdx})::Int\nfila_typeid(c::Context; type::Union{Symbol,Integer})::Int\nReturn the typeid of a filament f or associated with type."
  },
  {
    "objectID": "docstrings/medyan.num_link_types-2d203a5799bbfdcc.html",
    "href": "docstrings/medyan.num_link_types-2d203a5799bbfdcc.html",
    "title": "MEDYAN.num_link_types",
    "section": "",
    "text": "num_link_types(c::Context)::Int\nReturn the number of link types."
  },
  {
    "objectID": "docstrings/medyan.num_link_types-2d203a5799bbfdcc.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.num_link_types-2d203a5799bbfdcc.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.num_link_types",
    "section": "",
    "text": "num_link_types(c::Context)::Int\nReturn the number of link types."
  },
  {
    "objectID": "docstrings/medyan.def_fixed_species--490fb150d53e2870.html",
    "href": "docstrings/medyan.def_fixed_species--490fb150d53e2870.html",
    "title": "MEDYAN.def_fixed_species!",
    "section": "",
    "text": "def_fixed_species!(s::SysDef, name::Symbol)\nDynamically add a new fixed (non-diffusing) species to the system definition.\nMust be called before adding any sites (filament sites, filament end sites, membrane sites, link types, etc.) or reactions.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new fixed species.\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if the fixed species already exists.\nError if sites or reactions have already been added."
  },
  {
    "objectID": "docstrings/medyan.def_fixed_species--490fb150d53e2870.html#tuple-medyan.sysdef--symbol--772937de98b04e8b",
    "href": "docstrings/medyan.def_fixed_species--490fb150d53e2870.html#tuple-medyan.sysdef--symbol--772937de98b04e8b",
    "title": "MEDYAN.def_fixed_species!",
    "section": "",
    "text": "def_fixed_species!(s::SysDef, name::Symbol)\nDynamically add a new fixed (non-diffusing) species to the system definition.\nMust be called before adding any sites (filament sites, filament end sites, membrane sites, link types, etc.) or reactions.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new fixed species.\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if the fixed species already exists.\nError if sites or reactions have already been added."
  },
  {
    "objectID": "docstrings/medyan.addmembranediffusingcount_rand--7b719dca63a36b1b.html",
    "href": "docstrings/medyan.addmembranediffusingcount_rand--7b719dca63a36b1b.html",
    "title": "MEDYAN.addmembranediffusingcount_rand!",
    "section": "",
    "text": "addmembranediffusingcount_rand!(\n    c::MEDYAN.Context,\n    membraneindex::Int64,\n    speciesindex::Int64,\n    addcount::Int64\n)\nDistribute the added membrane species count randomly to membrane cells, ignoring cell area difference. Does NOT update propensity."
  },
  {
    "objectID": "docstrings/medyan.addmembranediffusingcount_rand--7b719dca63a36b1b.html#tuple-medyan.context--int64--int64--int64--c6aa1d407904887b",
    "href": "docstrings/medyan.addmembranediffusingcount_rand--7b719dca63a36b1b.html#tuple-medyan.context--int64--int64--int64--c6aa1d407904887b",
    "title": "MEDYAN.addmembranediffusingcount_rand!",
    "section": "",
    "text": "addmembranediffusingcount_rand!(\n    c::MEDYAN.Context,\n    membraneindex::Int64,\n    speciesindex::Int64,\n    addcount::Int64\n)\nDistribute the added membrane species count randomly to membrane cells, ignoring cell area difference. Does NOT update propensity."
  },
  {
    "objectID": "docstrings/medyan.addreactioncallback--9c9d46adeded2d88.html",
    "href": "docstrings/medyan.addreactioncallback--9c9d46adeded2d88.html",
    "title": "MEDYAN.addreactioncallback!",
    "section": "",
    "text": "addreactioncallback!(s::SysDef, reactantexpr::AbstractString, rate::Float64, invvolumepower::Int, callback)::SysDef\nLike addreaction! but also adds callback. callback is called when the reaction happens with input of MEDYAN.Context and Int the chem_voxel id where the reaction happened.\nThe callback should handle updating species counts.\nMEDYAN.errorcheck_addcallback(callback,s::SysDef) can optionally be overloaded to add errorchecking when the callback is added."
  },
  {
    "objectID": "docstrings/medyan.addreactioncallback--9c9d46adeded2d88.html#tuple-medyan.sysdef--abstractstring--float64--int64--any--ecdb462076761cce",
    "href": "docstrings/medyan.addreactioncallback--9c9d46adeded2d88.html#tuple-medyan.sysdef--abstractstring--float64--int64--any--ecdb462076761cce",
    "title": "MEDYAN.addreactioncallback!",
    "section": "",
    "text": "addreactioncallback!(s::SysDef, reactantexpr::AbstractString, rate::Float64, invvolumepower::Int, callback)::SysDef\nLike addreaction! but also adds callback. callback is called when the reaction happens with input of MEDYAN.Context and Int the chem_voxel id where the reaction happened.\nThe callback should handle updating species counts.\nMEDYAN.errorcheck_addcallback(callback,s::SysDef) can optionally be overloaded to add errorchecking when the callback is added."
  },
  {
    "objectID": "docstrings/medyan.vertexname-2d87a6a86cabc4f5.html",
    "href": "docstrings/medyan.vertexname-2d87a6a86cabc4f5.html",
    "title": "MEDYAN.VertexName",
    "section": "",
    "text": "membraneindex::Int64: membrane index\nvid::Int64: vertex id"
  },
  {
    "objectID": "docstrings/medyan.vertexname-2d87a6a86cabc4f5.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.vertexname-2d87a6a86cabc4f5.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.VertexName",
    "section": "",
    "text": "membraneindex::Int64: membrane index\nvid::Int64: vertex id"
  },
  {
    "objectID": "docstrings/medyan.set_chem_boundary_oversampling_factor--dd246eef62c89b5f.html",
    "href": "docstrings/medyan.set_chem_boundary_oversampling_factor--dd246eef62c89b5f.html",
    "title": "MEDYAN.set_chem_boundary_oversampling_factor!",
    "section": "",
    "text": "set_chem_boundary_oversampling_factor!(\n    c::MEDYAN.Context,\n    factor::Int64\n)\nSet the oversampling factor for chem boundary TSDF computation. This will invalidate the TSDF cache."
  },
  {
    "objectID": "docstrings/medyan.set_chem_boundary_oversampling_factor--dd246eef62c89b5f.html#tuple-medyan.context--int64--86f0854b67893706",
    "href": "docstrings/medyan.set_chem_boundary_oversampling_factor--dd246eef62c89b5f.html#tuple-medyan.context--int64--86f0854b67893706",
    "title": "MEDYAN.set_chem_boundary_oversampling_factor!",
    "section": "",
    "text": "set_chem_boundary_oversampling_factor!(\n    c::MEDYAN.Context,\n    factor::Int64\n)\nSet the oversampling factor for chem boundary TSDF computation. This will invalidate the TSDF cache."
  },
  {
    "objectID": "docstrings/medyan.anystate-5e989313a9ef75d3.html",
    "href": "docstrings/medyan.anystate-5e989313a9ef75d3.html",
    "title": "MEDYAN.anystate",
    "section": "",
    "text": "const anystate = AnyState()\nA special value in match in def_fila_reaction! and def_fila_tip_reaction! to match any MonomerState."
  },
  {
    "objectID": "docstrings/medyan.anystate-5e989313a9ef75d3.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.anystate-5e989313a9ef75d3.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.anystate",
    "section": "",
    "text": "const anystate = AnyState()\nA special value in match in def_fila_reaction! and def_fila_tip_reaction! to match any MonomerState."
  },
  {
    "objectID": "docstrings/medyan.randompoint-83e939bdee528294.html",
    "href": "docstrings/medyan.randompoint-83e939bdee528294.html",
    "title": "MEDYAN.randompoint",
    "section": "",
    "text": "randompoint(grid::CubicGrid,cid)::SVector{3,Float64}\nReturn a random point in a voxel Note, due to floating point rounding, there is a small chance the returned point may be in a nearby voxel.\n\n\n\n\n\n\n\n\n\n\n\n\nrandompoint(grid::CubicGrid)::SVector{3,Float64}\nReturn a random point in the grid"
  },
  {
    "objectID": "docstrings/medyan.randompoint-83e939bdee528294.html#tuple-medyan.cubicgrid--any--1be3c03f7960c1a3",
    "href": "docstrings/medyan.randompoint-83e939bdee528294.html#tuple-medyan.cubicgrid--any--1be3c03f7960c1a3",
    "title": "MEDYAN.randompoint",
    "section": "",
    "text": "randompoint(grid::CubicGrid,cid)::SVector{3,Float64}\nReturn a random point in a voxel Note, due to floating point rounding, there is a small chance the returned point may be in a nearby voxel."
  },
  {
    "objectID": "docstrings/medyan.randompoint-83e939bdee528294.html#tuple-medyan.cubicgrid--0971be2da0774049",
    "href": "docstrings/medyan.randompoint-83e939bdee528294.html#tuple-medyan.cubicgrid--0971be2da0774049",
    "title": "MEDYAN.randompoint",
    "section": "",
    "text": "randompoint(grid::CubicGrid)::SVector{3,Float64}\nReturn a random point in the grid"
  },
  {
    "objectID": "docstrings/medyan.make_memb_sphere--5ed5984bc3221359.html",
    "href": "docstrings/medyan.make_memb_sphere--5ed5984bc3221359.html",
    "title": "MEDYAN.make_memb_sphere!",
    "section": "",
    "text": "make_memb_sphere!(c::Context; radius, center=SA[0.0,0.0,0.0], subdivisions=2)::MembId\nCreate a new spherical membrane in the simulation context and return its membrane identifier.\nThis function generates an icosphere mesh by subdividing the faces of a regular icosahedron. Each subdivision step splits every triangle into four smaller triangles, resulting in a more refined, nearly uniform triangulation of the sphere. The mesh is then scaled by radius, rotated by rotation, and translated to center.\n\n\n\nradius::Float64: Radius of the sphere (nm)\ncenter::SVector{3,Float64}=SA[0.0,0.0,0.0]: Center of the sphere (nm)\nsubdivisions::Int=3: Number of subdivisions (1 = icosahedron, each increment quadruples the number of triangles)\nrotation=I: 3x3 matrix to rotate the sphere around its center\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior.\n\n\n\n\n\nMesh construction method: https://web.archive.org/web/20200210070737/http://blog.andreaskahler.com/2009/06/creating-icosphere-mesh-in-code.html"
  },
  {
    "objectID": "docstrings/medyan.make_memb_sphere--5ed5984bc3221359.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.make_memb_sphere--5ed5984bc3221359.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.make_memb_sphere!",
    "section": "",
    "text": "make_memb_sphere!(c::Context; radius, center=SA[0.0,0.0,0.0], subdivisions=2)::MembId\nCreate a new spherical membrane in the simulation context and return its membrane identifier.\nThis function generates an icosphere mesh by subdividing the faces of a regular icosahedron. Each subdivision step splits every triangle into four smaller triangles, resulting in a more refined, nearly uniform triangulation of the sphere. The mesh is then scaled by radius, rotated by rotation, and translated to center.\n\n\n\nradius::Float64: Radius of the sphere (nm)\ncenter::SVector{3,Float64}=SA[0.0,0.0,0.0]: Center of the sphere (nm)\nsubdivisions::Int=3: Number of subdivisions (1 = icosahedron, each increment quadruples the number of triangles)\nrotation=I: 3x3 matrix to rotate the sphere around its center\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior.\n\n\n\n\n\nMesh construction method: https://web.archive.org/web/20200210070737/http://blog.andreaskahler.com/2009/06/creating-icosphere-mesh-in-code.html"
  },
  {
    "objectID": "docstrings/medyan.get_reaction_enabled-95b8e03d3766db53.html",
    "href": "docstrings/medyan.get_reaction_enabled-95b8e03d3766db53.html",
    "title": "MEDYAN.get_reaction_enabled",
    "section": "",
    "text": "get_reaction_enabled(c::Context, link::Link, [d::LinkData])\nReturn the reaction_enabled flags of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.get_reaction_enabled-95b8e03d3766db53.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--any---03b671600f22589f",
    "href": "docstrings/medyan.get_reaction_enabled-95b8e03d3766db53.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--any---03b671600f22589f",
    "title": "MEDYAN.get_reaction_enabled",
    "section": "",
    "text": "get_reaction_enabled(c::Context, link::Link, [d::LinkData])\nReturn the reaction_enabled flags of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.link_exists-0f95437072169f8d.html",
    "href": "docstrings/medyan.link_exists-0f95437072169f8d.html",
    "title": "MEDYAN.link_exists",
    "section": "",
    "text": "link_exists(c::Context, link::Link)::Bool\nReturn true iff link exists in context c. Otherwise return false."
  },
  {
    "objectID": "docstrings/medyan.link_exists-0f95437072169f8d.html#tuple-medyan.context--medyan.link--d37b229d2ebf6962",
    "href": "docstrings/medyan.link_exists-0f95437072169f8d.html#tuple-medyan.context--medyan.link--d37b229d2ebf6962",
    "title": "MEDYAN.link_exists",
    "section": "",
    "text": "link_exists(c::Context, link::Link)::Bool\nReturn true iff link exists in context c. Otherwise return false."
  },
  {
    "objectID": "docstrings/medyan.is_chem_boundary_tsdf_cache_valid-3823b443227db869.html",
    "href": "docstrings/medyan.is_chem_boundary_tsdf_cache_valid-3823b443227db869.html",
    "title": "MEDYAN.is_chem_boundary_tsdf_cache_valid",
    "section": "",
    "text": "is_chem_boundary_tsdf_cache_valid(c::MEDYAN.Context) -&gt; Bool\nReturn true if the chem boundary TSDF cache is valid."
  },
  {
    "objectID": "docstrings/medyan.is_chem_boundary_tsdf_cache_valid-3823b443227db869.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.is_chem_boundary_tsdf_cache_valid-3823b443227db869.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.is_chem_boundary_tsdf_cache_valid",
    "section": "",
    "text": "is_chem_boundary_tsdf_cache_valid(c::MEDYAN.Context) -&gt; Bool\nReturn true if the chem boundary TSDF cache is valid."
  },
  {
    "objectID": "docstrings/medyan.link_type_name-275d5954d07419f4.html",
    "href": "docstrings/medyan.link_type_name-275d5954d07419f4.html",
    "title": "MEDYAN.link_type_name",
    "section": "",
    "text": "link_type_name(c::Context, link::Link)::Symbol\nlink_type_name(c::Context; type::Union{Symbol, Integer})::Symbol\nReturn the name of the link’s type, or the name associated with type"
  },
  {
    "objectID": "docstrings/medyan.link_type_name-275d5954d07419f4.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.link_type_name-275d5954d07419f4.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.link_type_name",
    "section": "",
    "text": "link_type_name(c::Context, link::Link)::Symbol\nlink_type_name(c::Context; type::Union{Symbol, Integer})::Symbol\nReturn the name of the link’s type, or the name associated with type"
  },
  {
    "objectID": "docstrings/medyan.apply_chem_boundary--86fcf1aed37adaf6.html",
    "href": "docstrings/medyan.apply_chem_boundary--86fcf1aed37adaf6.html",
    "title": "MEDYAN.apply_chem_boundary!",
    "section": "",
    "text": "apply_chem_boundary!(c::Context)::Nothing\nUpdate chem voxel volumes and diffusion rates.\nThe chem boundary is the intersection of any boundary set by set_chem_boundary! and membranes with chem_boundary=true.\nset_chem_boundary_oversampling_factor! can be used to increase the boundary sampling resolution at the expense of increased memory use.\nCalling this will invalidate the chem cache."
  },
  {
    "objectID": "docstrings/medyan.apply_chem_boundary--86fcf1aed37adaf6.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.apply_chem_boundary--86fcf1aed37adaf6.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.apply_chem_boundary!",
    "section": "",
    "text": "apply_chem_boundary!(c::Context)::Nothing\nUpdate chem voxel volumes and diffusion rates.\nThe chem boundary is the intersection of any boundary set by set_chem_boundary! and membranes with chem_boundary=true.\nset_chem_boundary_oversampling_factor! can be used to increase the boundary sampling resolution at the expense of increased memory use.\nCalling this will invalidate the chem cache."
  },
  {
    "objectID": "docstrings/medyan.addfilamentendsite--95612d72d1fda05f.html",
    "href": "docstrings/medyan.addfilamentendsite--95612d72d1fda05f.html",
    "title": "MEDYAN.addfilamentendsite!",
    "section": "",
    "text": "addfilamentendsite!(s::SysDef,filamenttypename::Symbol,filamentendsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.addfilamentendsite--95612d72d1fda05f.html#tuple-medyan.sysdef--symbol--symbol--any--b9a0ed342fa77751",
    "href": "docstrings/medyan.addfilamentendsite--95612d72d1fda05f.html#tuple-medyan.sysdef--symbol--symbol--any--b9a0ed342fa77751",
    "title": "MEDYAN.addfilamentendsite!",
    "section": "",
    "text": "addfilamentendsite!(s::SysDef,filamenttypename::Symbol,filamentendsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.run_chemistry--dda22fac5c555b9e.html",
    "href": "docstrings/medyan.run_chemistry--dda22fac5c555b9e.html",
    "title": "MEDYAN.run_chemistry!",
    "section": "",
    "text": "run_chemistry!(c::Context, Δt)\nRun chemistry for Δt time.\nUpdate c.time."
  },
  {
    "objectID": "docstrings/medyan.run_chemistry--dda22fac5c555b9e.html#tuple-medyan.context--any--86fc06bb8cbd13e8",
    "href": "docstrings/medyan.run_chemistry--dda22fac5c555b9e.html#tuple-medyan.context--any--86fc06bb8cbd13e8",
    "title": "MEDYAN.run_chemistry!",
    "section": "",
    "text": "run_chemistry!(c::Context, Δt)\nRun chemistry for Δt time.\nUpdate c.time."
  },
  {
    "objectID": "docstrings/medyan.num_fila_types-1698969c2a51ad88.html",
    "href": "docstrings/medyan.num_fila_types-1698969c2a51ad88.html",
    "title": "MEDYAN.num_fila_types",
    "section": "",
    "text": "num_fila_types(c::MEDYAN.Context) -&gt; Int64\nReturn the number of filament types."
  },
  {
    "objectID": "docstrings/medyan.num_fila_types-1698969c2a51ad88.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.num_fila_types-1698969c2a51ad88.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.num_fila_types",
    "section": "",
    "text": "num_fila_types(c::MEDYAN.Context) -&gt; Int64\nReturn the number of filament types."
  },
  {
    "objectID": "docstrings/medyan.adddiffusingcount_rand--9d3ddfabbceeef92.html",
    "href": "docstrings/medyan.adddiffusingcount_rand--9d3ddfabbceeef92.html",
    "title": "MEDYAN.adddiffusingcount_rand!",
    "section": "",
    "text": "adddiffusingcount_rand!(c::Context, dsid, inccount)\nDistribute the added diffusing species count randomly to compartments weighted by volume.\n\ndsid: diffusing species id.\ninccount: amount to add."
  },
  {
    "objectID": "docstrings/medyan.adddiffusingcount_rand--9d3ddfabbceeef92.html#tuple-medyan.context--any--any--0ecbb5ec6f703ddd",
    "href": "docstrings/medyan.adddiffusingcount_rand--9d3ddfabbceeef92.html#tuple-medyan.context--any--any--0ecbb5ec6f703ddd",
    "title": "MEDYAN.adddiffusingcount_rand!",
    "section": "",
    "text": "adddiffusingcount_rand!(c::Context, dsid, inccount)\nDistribute the added diffusing species count randomly to compartments weighted by volume.\n\ndsid: diffusing species id.\ninccount: amount to add."
  },
  {
    "objectID": "docstrings/medyan.compute_all_membrane_geometry-_system-05b4d2a32e31560c.html",
    "href": "docstrings/medyan.compute_all_membrane_geometry-_system-05b4d2a32e31560c.html",
    "title": "MEDYAN.compute_all_membrane_geometry!_system",
    "section": "",
    "text": "Updates all membrane geometries used across various parts of MEDYAN.\nThe list of all items can be found in the document for MEDYAN.compute_geometry!_system function.\nKeyword parameters:\n\ninclude_ff::Bool: If true, compute_geometry! used in energy computations will be applied as well, requiring vectorization of the membrane. This happens before system geometry computation in case some fields are overriden."
  },
  {
    "objectID": "docstrings/medyan.compute_all_membrane_geometry-_system-05b4d2a32e31560c.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.compute_all_membrane_geometry-_system-05b4d2a32e31560c.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.compute_all_membrane_geometry!_system",
    "section": "",
    "text": "Updates all membrane geometries used across various parts of MEDYAN.\nThe list of all items can be found in the document for MEDYAN.compute_geometry!_system function.\nKeyword parameters:\n\ninclude_ff::Bool: If true, compute_geometry! used in energy computations will be applied as well, requiring vectorization of the membrane. This happens before system geometry computation in case some fields are overriden."
  },
  {
    "objectID": "docstrings/medyan.set_chem_boundary--8446b49a230e3146.html",
    "href": "docstrings/medyan.set_chem_boundary--8446b49a230e3146.html",
    "title": "MEDYAN.set_chem_boundary!",
    "section": "",
    "text": "set_chem_boundary!(\n    c::MEDYAN.Context,\n    boundary::MEDYAN.Boundary\n)\nSet chemical boundary Note, the chem boundary should be outside the mech boundary so that it is rare for filaments to go outside the chem boundary.\nMake sure to call apply_chem_boundary! to update the chem voxels.\nSee also Boundary"
  },
  {
    "objectID": "docstrings/medyan.set_chem_boundary--8446b49a230e3146.html#tuple-medyan.context--medyan.boundary--d2ddd15e09dbc97e",
    "href": "docstrings/medyan.set_chem_boundary--8446b49a230e3146.html#tuple-medyan.context--medyan.boundary--d2ddd15e09dbc97e",
    "title": "MEDYAN.set_chem_boundary!",
    "section": "",
    "text": "set_chem_boundary!(\n    c::MEDYAN.Context,\n    boundary::MEDYAN.Boundary\n)\nSet chemical boundary Note, the chem boundary should be outside the mech boundary so that it is rare for filaments to go outside the chem boundary.\nMake sure to call apply_chem_boundary! to update the chem voxels.\nSee also Boundary"
  },
  {
    "objectID": "docstrings/medyan.place2tag-9d62565424ca3705.html",
    "href": "docstrings/medyan.place2tag-9d62565424ca3705.html",
    "title": "MEDYAN.place2tag",
    "section": "",
    "text": "place2tag(c::Context, p::Place)::Tag\nReturn the tag of the place. Throw an error if !has_tag(p)."
  },
  {
    "objectID": "docstrings/medyan.place2tag-9d62565424ca3705.html#union-tuple-p---tuple-medyan.context--p---where-p--medyan.place-316eaf4f0092762b",
    "href": "docstrings/medyan.place2tag-9d62565424ca3705.html#union-tuple-p---tuple-medyan.context--p---where-p--medyan.place-316eaf4f0092762b",
    "title": "MEDYAN.place2tag",
    "section": "",
    "text": "place2tag(c::Context, p::Place)::Tag\nReturn the tag of the place. Throw an error if !has_tag(p)."
  },
  {
    "objectID": "docstrings/medyan.add_membranesitereaction--59d1fe245302e071.html",
    "href": "docstrings/medyan.add_membranesitereaction--59d1fe245302e071.html",
    "title": "MEDYAN.add_membranesitereaction!",
    "section": "",
    "text": "Add a membrane site with the corresponding reaction with callback.\nKeyword arguments:\n\ns: SysDef.\nname_newmembranesite: Symbol.\nmembranediffusingreactants: Vector of symbols as membrane reactants. 0 or 1 reactant is currently supported.\nmembranediffusingproducts: Vector of symbols as membrane products.\nreactionexpr_extra: Reaction expression for other species involved.\nrate: Float.\nchangerage_bypotentialenergy: Whether the rate is affected by potential energy.\ninvvolumepower: rate scaling with compartment volume.\n\nNotes:\n\nIf error occurs, this function does not ensure that s is unchanged."
  },
  {
    "objectID": "docstrings/medyan.add_membranesitereaction--59d1fe245302e071.html#tuple---3937a4f1811c9dc1",
    "href": "docstrings/medyan.add_membranesitereaction--59d1fe245302e071.html#tuple---3937a4f1811c9dc1",
    "title": "MEDYAN.add_membranesitereaction!",
    "section": "",
    "text": "Add a membrane site with the corresponding reaction with callback.\nKeyword arguments:\n\ns: SysDef.\nname_newmembranesite: Symbol.\nmembranediffusingreactants: Vector of symbols as membrane reactants. 0 or 1 reactant is currently supported.\nmembranediffusingproducts: Vector of symbols as membrane products.\nreactionexpr_extra: Reaction expression for other species involved.\nrate: Float.\nchangerage_bypotentialenergy: Whether the rate is affected by potential energy.\ninvvolumepower: rate scaling with compartment volume.\n\nNotes:\n\nIf error occurs, this function does not ensure that s is unchanged."
  },
  {
    "objectID": "docstrings/medyan.make_fila_rand--7c63c7a09ece60c8.html",
    "href": "docstrings/medyan.make_fila_rand--7c63c7a09ece60c8.html",
    "title": "MEDYAN.make_fila_rand!",
    "section": "",
    "text": "make_fila_rand!(c::Context, mono_states; iterations = 10^9, type = 1)::Tag{FilaTipIdx}\nAdd a filament to the Context with random center position and direction.\nReturn the tag of the plus tip of the new filament.\nmono_states is a collection of the MonomerState of the monomers in the new filament.\nThe filament will be inside the mech boundary, assuming the boundary is convex.\nErrors if it fails to add a filament.\nThe monomer are spaced by the value in the filament type’s mechanical parameters.\n\n\n\ntype=1: filament type id or symbol.\niterations = 10^9: number of positions to try before failing with an error."
  },
  {
    "objectID": "docstrings/medyan.make_fila_rand--7c63c7a09ece60c8.html#tuple-medyan.context--any--86fc06bb8cbd13e8",
    "href": "docstrings/medyan.make_fila_rand--7c63c7a09ece60c8.html#tuple-medyan.context--any--86fc06bb8cbd13e8",
    "title": "MEDYAN.make_fila_rand!",
    "section": "",
    "text": "make_fila_rand!(c::Context, mono_states; iterations = 10^9, type = 1)::Tag{FilaTipIdx}\nAdd a filament to the Context with random center position and direction.\nReturn the tag of the plus tip of the new filament.\nmono_states is a collection of the MonomerState of the monomers in the new filament.\nThe filament will be inside the mech boundary, assuming the boundary is convex.\nErrors if it fails to add a filament.\nThe monomer are spaced by the value in the filament type’s mechanical parameters.\n\n\n\ntype=1: filament type id or symbol.\niterations = 10^9: number of positions to try before failing with an error."
  },
  {
    "objectID": "docstrings/src/links/balls.html",
    "href": "docstrings/src/links/balls.html",
    "title": "src/links/balls.jl",
    "section": "",
    "text": "make_ball!(c::Context; position, radius, stiffness=1.0f0, state=SA[0,0,0], is_minimized=false) -&gt; Tag{BallIdx}\nCreate a new ball in c and return a tag for it.\n\n\n\nposition::SVector{3, Float64}: 3D position of the ball center (nm)\nradius::Float32: Radius of the ball (nm)\nstiffness::Float32=1.0: Mechanical stiffness coefficient (pN/nm)\nstate::SVector{3, Int64}=SA[0,0,0]: Three-component state vector for chemical reactions\nis_minimized::Bool=false: Whether the ball is marked as minimized. By default balls are not minimized when created. Set to true to create a ball that is already marked as minimized.\n\nSee also: remove_ball!, update_ball!, get_position, is_minimized\n\n\n\n\n\n\n\n\n\n\n\n\n\nremove_ball!(c::Context, ball::Union{BallIdx, Tag{BallIdx}})\nRemove a ball from the simulation and unlink all connected links.\nSee also: make_ball!, update_ball!, get_position, is_minimized\n\n\n\n\n\n\n\n\n\n\n\n\nupdate_ball!(c::Context, ball::Union{BallIdx, Tag{BallIdx}}; kwargs...)\nUpdate properties of an existing ball. Unspecified properties remain unchanged.\n\n\n\nposition::Union{Nothing, SVector{3, Float64}}=nothing: New position (nm)\nradius::Union{Nothing, Float32}=nothing: New radius (nm)\nstiffness::Union{Nothing, Float32}=nothing: New stiffness (pN/nm)\nstate::Union{Nothing, SVector{3, Int64}}=nothing: New state vector\nis_minimized::Union{Nothing, Bool}=nothing: Whether the ball is marked as minimized. Defaults to false when position or radius is changed, otherwise unchanged. Set explicitly to override the default behavior.\n\nSee also: make_ball!, remove_ball!, get_position, is_minimized\n\n\n\n\n\n\n\n\n\n\n\n\n\nis_minimized(c::Context, ball::Union{BallIdx, Tag{BallIdx}})::Bool\nReturn true if the ball has been minimized (i.e. its position has been updated by minimize_energy! since it was last created or modified).\nBalls are marked as not minimized when created with make_ball! or when their position or radius is changed via update_ball!. All balls are marked as minimized at the end of minimize_energy!.\nSee also: make_ball!, update_ball!, minimize_energy!"
  },
  {
    "objectID": "docstrings/src/links/balls.html#medyan.make_ball--ae25720dbd2acec6",
    "href": "docstrings/src/links/balls.html#medyan.make_ball--ae25720dbd2acec6",
    "title": "src/links/balls.jl",
    "section": "",
    "text": "make_ball!(c::Context; position, radius, stiffness=1.0f0, state=SA[0,0,0], is_minimized=false) -&gt; Tag{BallIdx}\nCreate a new ball in c and return a tag for it.\n\n\n\nposition::SVector{3, Float64}: 3D position of the ball center (nm)\nradius::Float32: Radius of the ball (nm)\nstiffness::Float32=1.0: Mechanical stiffness coefficient (pN/nm)\nstate::SVector{3, Int64}=SA[0,0,0]: Three-component state vector for chemical reactions\nis_minimized::Bool=false: Whether the ball is marked as minimized. By default balls are not minimized when created. Set to true to create a ball that is already marked as minimized.\n\nSee also: remove_ball!, update_ball!, get_position, is_minimized"
  },
  {
    "objectID": "docstrings/src/links/balls.html#medyan.remove_ball--57fbfd7855882ccd",
    "href": "docstrings/src/links/balls.html#medyan.remove_ball--57fbfd7855882ccd",
    "title": "src/links/balls.jl",
    "section": "",
    "text": "remove_ball!(c::Context, ball::Union{BallIdx, Tag{BallIdx}})\nRemove a ball from the simulation and unlink all connected links.\nSee also: make_ball!, update_ball!, get_position, is_minimized"
  },
  {
    "objectID": "docstrings/src/links/balls.html#medyan.update_ball--83d0c0fbbdbab087",
    "href": "docstrings/src/links/balls.html#medyan.update_ball--83d0c0fbbdbab087",
    "title": "src/links/balls.jl",
    "section": "",
    "text": "update_ball!(c::Context, ball::Union{BallIdx, Tag{BallIdx}}; kwargs...)\nUpdate properties of an existing ball. Unspecified properties remain unchanged.\n\n\n\nposition::Union{Nothing, SVector{3, Float64}}=nothing: New position (nm)\nradius::Union{Nothing, Float32}=nothing: New radius (nm)\nstiffness::Union{Nothing, Float32}=nothing: New stiffness (pN/nm)\nstate::Union{Nothing, SVector{3, Int64}}=nothing: New state vector\nis_minimized::Union{Nothing, Bool}=nothing: Whether the ball is marked as minimized. Defaults to false when position or radius is changed, otherwise unchanged. Set explicitly to override the default behavior.\n\nSee also: make_ball!, remove_ball!, get_position, is_minimized"
  },
  {
    "objectID": "docstrings/src/links/balls.html#medyan.is_minimized-ff3858ada5447c46",
    "href": "docstrings/src/links/balls.html#medyan.is_minimized-ff3858ada5447c46",
    "title": "src/links/balls.jl",
    "section": "",
    "text": "is_minimized(c::Context, ball::Union{BallIdx, Tag{BallIdx}})::Bool\nReturn true if the ball has been minimized (i.e. its position has been updated by minimize_energy! since it was last created or modified).\nBalls are marked as not minimized when created with make_ball! or when their position or radius is changed via update_ball!. All balls are marked as minimized at the end of minimize_energy!.\nSee also: make_ball!, update_ball!, minimize_energy!"
  },
  {
    "objectID": "docstrings/src/links/anchors.html",
    "href": "docstrings/src/links/anchors.html",
    "title": "src/links/anchors.jl",
    "section": "",
    "text": "make_anchor!(c::Context, p::Anchor)::Tag{Anchor}\nReturn the new tagged anchor.\nThis represents a fixed position and frame in the simulation.\n\n\n\n\n\n\n\n\n\n\n\n\nremove_anchor!(c::Context, anchor::Union{Anchor, Tag{Anchor}})::Nothing\nRemove an anchor. Any attached links will be unlinked.\n\n\n\n\n\n\n\n\n\n\n\n\nupdate_anchor!(c::Context, tag::Tag{Anchor}, new_anchor::Anchor)::Nothing\nUpdate an anchor associated with a tag."
  },
  {
    "objectID": "docstrings/src/links/anchors.html#medyan.make_anchor--5895a6f222d457ad",
    "href": "docstrings/src/links/anchors.html#medyan.make_anchor--5895a6f222d457ad",
    "title": "src/links/anchors.jl",
    "section": "",
    "text": "make_anchor!(c::Context, p::Anchor)::Tag{Anchor}\nReturn the new tagged anchor.\nThis represents a fixed position and frame in the simulation."
  },
  {
    "objectID": "docstrings/src/links/anchors.html#medyan.remove_anchor--5ded3fc420c1ef42",
    "href": "docstrings/src/links/anchors.html#medyan.remove_anchor--5ded3fc420c1ef42",
    "title": "src/links/anchors.jl",
    "section": "",
    "text": "remove_anchor!(c::Context, anchor::Union{Anchor, Tag{Anchor}})::Nothing\nRemove an anchor. Any attached links will be unlinked."
  },
  {
    "objectID": "docstrings/src/links/anchors.html#medyan.update_anchor--d2dbcaf15f4f7c90",
    "href": "docstrings/src/links/anchors.html#medyan.update_anchor--d2dbcaf15f4f7c90",
    "title": "src/links/anchors.jl",
    "section": "",
    "text": "update_anchor!(c::Context, tag::Tag{Anchor}, new_anchor::Anchor)::Nothing\nUpdate an anchor associated with a tag."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html",
    "href": "docstrings/src/links/link-manager.html",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "num_link_types(c::Context)::Int\nReturn the number of link types.\n\n\n\n\n\n\n\n\n\n\n\n\nlink_type_name(c::Context, link::Link)::Symbol\nlink_type_name(c::Context; type::Union{Symbol, Integer})::Symbol\nReturn the name of the link’s type, or the name associated with type\n\n\n\n\n\n\n\n\n\n\n\n\nlink_typeid(c::Context, link::Link)::Int\nlink_typeid(c::Context; type::Union{Symbol, Integer})::Int\nReturn the typeid of the link’s type, or the typeid associated with type\n\n\n\n\n\n\n\n\n\n\n\n\nplace2tag(c::Context, p::Place)::Tag\nReturn the tag of the place. Throw an error if !has_tag(p).\n\n\n\n\n\n\n\n\n\n\n\n\ntag!(c::Context, p::Place)::Tag\nReturn the tag of the place. Throw an error if !place_exists(p). Create a new tag if !has_tag(p).\n\n\n\n\n\n\n\n\n\n\n\n\nhas_tag(c::Context, p::Place)::Bool\nReturn true iff p has a tag. Otherwise return false. If !place_exists(c, p) return false.\n\n\n\n\n\n\n\n\n\n\n\n\ntag2place(c::Context, t::Tag)::Place\nReturn the place of the tag. Throw an error if !tag_exists(t).\n\n\n\n\n\n\n\n\n\n\n\n\nget_position(c::Context, x::Union{Tag, Place})::SVector{3, Float64}\nReturn the position of x. Throw an error if x doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\nget_directions(c::Context, x::Union{Tag, Place})::SVector{N, SVector{3, Float64}}\nReturn the directions of x. N is from num_directions. Throw an error if x doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\nget_material_frame(c::Context, x::Union{Tag, Place})::RotMatrix3{Float64}\nReturn the material frame of x. Throw an error if x doesn’t exist.\nThe first column is the first direction. The second column is the second direction. The third column is cross(dirs[1], dirs[2]) to complete the right handed frame.\n\n\n\n\n\n\n\n\n\n\n\n\nget_chem_state(c::Context, x::Union{Tag, Place})\nReturn the chemical state of x. Each type of place has a different type of chemical state. If the chemical state of a place changes, any attached links will have their reaction rates recalculated. Throw an error if x doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\ntag_exists(c::Context, t::Tag)::Bool\nReturn true iff tag t exists in context c. Otherwise return false.\n\n\n\n\n\n\n\n\n\n\n\n\nget_all_tags(c::Context, p::Place) -&gt; Tag{typeof(p)} iterator\nReturn an iterator of existing tags for the type of p.\n\n\n\n\n\n\n\n\n\n\n\n\nlink2tags(c::Context, link::Link, [d::LinkData]) -&gt; Tag tuple\nReturn a tuple of tags of places that link is attached to. If one of the places of link is not attached that tag will be null. Throw an error if link doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\nget_state(c::Context, link::Link, [d::LinkData])\nReturn the state of the link. Throw an error if link doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\nget_bond_states(c::Context, link::Link, [d::LinkData])\nReturn the bond_states of the link. Throw an error if link doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\nget_bond_enabled(c::Context, link::Link, [d::LinkData])\nReturn the bond_enabled flags of the link. Throw an error if link doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\nget_reaction_enabled(c::Context, link::Link, [d::LinkData])\nReturn the reaction_enabled flags of the link. Throw an error if link doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\nis_minimized(c::Context, link::Link, [d::LinkData])::Bool\nReturn the is_minimized flag of the link. Throw an error if link doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\nlink_exists(c::Context, link::Link)::Bool\nReturn true iff link exists in context c. Otherwise return false.\n\n\n\n\n\n\n\n\n\n\n\n\nplace2links(c::Context, p::Place) -&gt; Link iterator\nReturn an iterator of Links attached to p. If !place_exists(c, p) return an empty iterator.\n\n\n\n\n\n\n\n\n\n\n\n\ntag2links(c::Context, t::Tag) -&gt; Link iterator\nReturn an iterator of Links attached to t. If !tag_exists(c, t) return an empty iterator.\n\n\n\n\n\n\n\n\n\n\n\n\nmake_link!(c::Context; kwargs...)::Link\nReturn the new link.\nThe type keyword argument is required.\nThe other keyword arguments can be used to change the link from default.\n\n\n\ntype::Union{Symbol,Integer}: the link type id or symbol.\nplaces=(): places or tags to attach to the link.\nSet an element to nothing not change the attached place. Set an element to a null place or tag to detach that place.\nstate=(;): state properties to change.\nA NamedTuple of changes. For example, state = (;k1 = 3.6, k7 = 2.0,) to change state.k1 to 3.6 and state.k7 to 2.0.\nbond_states=(): bond state properties to change.\nA Tuple of changes. If an element in the tuple is nothing, the corresponding bond state isn’t changed. For example, bond_states = (nothing, (;L0 = 3.6,)) to change bond_states[2].L0 to 3.6.\nbond_enabled=(): bond enable flags to change.\nA Tuple of Union{Bool, Nothing}. If an element in the tuple isnothing, the corresponding bond enable flag isn't changed. For example,bond_enabled = (nothing, true, false)` to not change bond 1, enable bond 2, and disable bond 3.\nreaction_enabled=(): reaction enable flags to change.\nA Tuple of NamedTuple of changes. If an element in the tuple is nothing, the corresponding reaction enable flags aren’t changed. For example, reaction_enabled = (nothing, (;a=true, b=false)) to not change any reactions on place 1, enable reaction a on place 2, and disable reaction b on place 2.\nis_minimized::Bool=false: is the link marked as minimized.\nBy default links are marked as minimized at the end of mechanics when updated.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nremove_link!(c::Context, link::Link)::Nothing\nRemove the link.\n\n\n\n\n\n\n\n\n\n\n\n\nupdate_link!(c::Context, link::Link; kwargs...)::Nothing\nUpdate the link.\n\n\n\nplaces=(): places or tags to attach to the link.\nSet an element to nothing not change the attached place. Set an element to a null place or tag to detach that place.\nstate=(;): state properties to change.\nA NamedTuple of changes. For example, state = (;k1 = 3.6, k7 = 2.0,) to change state.k1 to 3.6 and state.k7 to 2.0.\nbond_states=(): bond state properties to change.\nA Tuple of changes. If an element in the tuple is nothing, the corresponding bond state isn’t changed. For example, bond_states = (nothing, (;L0 = 3.6,)) to change bond_states[2].L0 to 3.6.\nbond_enabled=(): bond enable flags to change.\nA Tuple of Union{Bool, Nothing}. If an element in the tuple isnothing, the corresponding bond enable flag isn't changed. For example,bond_enabled = (nothing, true, false)` to not change bond 1, enable bond 2, and disable bond 3.\nreaction_enabled=(): reaction enable flags to change.\nA Tuple of NamedTuple of changes. If an element in the tuple is nothing, the corresponding reaction enable flags aren’t changed. For example, reaction_enabled = (nothing, (;a=true, b=false)) to not change any reactions on place 1, enable reaction a on place 2, and disable reaction b on place 2.\nis_minimized::Bool=false: is the link marked as minimized.\nBy default links are marked as minimized at the end of mechanics when updated.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nget_all_links(c::Context; type::Union{Symbol,Integer}) -&gt; Link iterator\nReturn an iterator of all Links of type type."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.num_link_types-2d203a5799bbfdcc",
    "href": "docstrings/src/links/link-manager.html#medyan.num_link_types-2d203a5799bbfdcc",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "num_link_types(c::Context)::Int\nReturn the number of link types."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.link_type_name-275d5954d07419f4",
    "href": "docstrings/src/links/link-manager.html#medyan.link_type_name-275d5954d07419f4",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "link_type_name(c::Context, link::Link)::Symbol\nlink_type_name(c::Context; type::Union{Symbol, Integer})::Symbol\nReturn the name of the link’s type, or the name associated with type"
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.link_typeid-a14290ff2f9378f7",
    "href": "docstrings/src/links/link-manager.html#medyan.link_typeid-a14290ff2f9378f7",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "link_typeid(c::Context, link::Link)::Int\nlink_typeid(c::Context; type::Union{Symbol, Integer})::Int\nReturn the typeid of the link’s type, or the typeid associated with type"
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.place2tag-9d62565424ca3705",
    "href": "docstrings/src/links/link-manager.html#medyan.place2tag-9d62565424ca3705",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "place2tag(c::Context, p::Place)::Tag\nReturn the tag of the place. Throw an error if !has_tag(p)."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.tag--518214eeb95e748e",
    "href": "docstrings/src/links/link-manager.html#medyan.tag--518214eeb95e748e",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "tag!(c::Context, p::Place)::Tag\nReturn the tag of the place. Throw an error if !place_exists(p). Create a new tag if !has_tag(p)."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.has_tag-d550430128572035",
    "href": "docstrings/src/links/link-manager.html#medyan.has_tag-d550430128572035",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "has_tag(c::Context, p::Place)::Bool\nReturn true iff p has a tag. Otherwise return false. If !place_exists(c, p) return false."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.tag2place-68ab43363a4c1760",
    "href": "docstrings/src/links/link-manager.html#medyan.tag2place-68ab43363a4c1760",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "tag2place(c::Context, t::Tag)::Place\nReturn the place of the tag. Throw an error if !tag_exists(t)."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.get_position-5ca1f4a736664040",
    "href": "docstrings/src/links/link-manager.html#medyan.get_position-5ca1f4a736664040",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "get_position(c::Context, x::Union{Tag, Place})::SVector{3, Float64}\nReturn the position of x. Throw an error if x doesn’t exist."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.get_directions-326e10fbe4341527",
    "href": "docstrings/src/links/link-manager.html#medyan.get_directions-326e10fbe4341527",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "get_directions(c::Context, x::Union{Tag, Place})::SVector{N, SVector{3, Float64}}\nReturn the directions of x. N is from num_directions. Throw an error if x doesn’t exist."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.get_material_frame-33a63ae3a3b9c211",
    "href": "docstrings/src/links/link-manager.html#medyan.get_material_frame-33a63ae3a3b9c211",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "get_material_frame(c::Context, x::Union{Tag, Place})::RotMatrix3{Float64}\nReturn the material frame of x. Throw an error if x doesn’t exist.\nThe first column is the first direction. The second column is the second direction. The third column is cross(dirs[1], dirs[2]) to complete the right handed frame."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.get_chem_state-a69539a7b114572a",
    "href": "docstrings/src/links/link-manager.html#medyan.get_chem_state-a69539a7b114572a",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "get_chem_state(c::Context, x::Union{Tag, Place})\nReturn the chemical state of x. Each type of place has a different type of chemical state. If the chemical state of a place changes, any attached links will have their reaction rates recalculated. Throw an error if x doesn’t exist."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.tag_exists-c112bb84254d0b58",
    "href": "docstrings/src/links/link-manager.html#medyan.tag_exists-c112bb84254d0b58",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "tag_exists(c::Context, t::Tag)::Bool\nReturn true iff tag t exists in context c. Otherwise return false."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.get_all_tags-3a8e6bc0634c8a4d",
    "href": "docstrings/src/links/link-manager.html#medyan.get_all_tags-3a8e6bc0634c8a4d",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "get_all_tags(c::Context, p::Place) -&gt; Tag{typeof(p)} iterator\nReturn an iterator of existing tags for the type of p."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.link2tags-645330bedbf54254",
    "href": "docstrings/src/links/link-manager.html#medyan.link2tags-645330bedbf54254",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "link2tags(c::Context, link::Link, [d::LinkData]) -&gt; Tag tuple\nReturn a tuple of tags of places that link is attached to. If one of the places of link is not attached that tag will be null. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.get_state-e99d22cacff37374",
    "href": "docstrings/src/links/link-manager.html#medyan.get_state-e99d22cacff37374",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "get_state(c::Context, link::Link, [d::LinkData])\nReturn the state of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.get_bond_states-b314ae6ee2a2b3cf",
    "href": "docstrings/src/links/link-manager.html#medyan.get_bond_states-b314ae6ee2a2b3cf",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "get_bond_states(c::Context, link::Link, [d::LinkData])\nReturn the bond_states of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.get_bond_enabled-c3461fb32deb4276",
    "href": "docstrings/src/links/link-manager.html#medyan.get_bond_enabled-c3461fb32deb4276",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "get_bond_enabled(c::Context, link::Link, [d::LinkData])\nReturn the bond_enabled flags of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.get_reaction_enabled-95b8e03d3766db53",
    "href": "docstrings/src/links/link-manager.html#medyan.get_reaction_enabled-95b8e03d3766db53",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "get_reaction_enabled(c::Context, link::Link, [d::LinkData])\nReturn the reaction_enabled flags of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.is_minimized-ff3858ada5447c46",
    "href": "docstrings/src/links/link-manager.html#medyan.is_minimized-ff3858ada5447c46",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "is_minimized(c::Context, link::Link, [d::LinkData])::Bool\nReturn the is_minimized flag of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.link_exists-0f95437072169f8d",
    "href": "docstrings/src/links/link-manager.html#medyan.link_exists-0f95437072169f8d",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "link_exists(c::Context, link::Link)::Bool\nReturn true iff link exists in context c. Otherwise return false."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.place2links-0b74317627f4b920",
    "href": "docstrings/src/links/link-manager.html#medyan.place2links-0b74317627f4b920",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "place2links(c::Context, p::Place) -&gt; Link iterator\nReturn an iterator of Links attached to p. If !place_exists(c, p) return an empty iterator."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.tag2links-e8376daf0b29e2fd",
    "href": "docstrings/src/links/link-manager.html#medyan.tag2links-e8376daf0b29e2fd",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "tag2links(c::Context, t::Tag) -&gt; Link iterator\nReturn an iterator of Links attached to t. If !tag_exists(c, t) return an empty iterator."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.make_link--0fd0bab9dac08837",
    "href": "docstrings/src/links/link-manager.html#medyan.make_link--0fd0bab9dac08837",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "make_link!(c::Context; kwargs...)::Link\nReturn the new link.\nThe type keyword argument is required.\nThe other keyword arguments can be used to change the link from default.\n\n\n\ntype::Union{Symbol,Integer}: the link type id or symbol.\nplaces=(): places or tags to attach to the link.\nSet an element to nothing not change the attached place. Set an element to a null place or tag to detach that place.\nstate=(;): state properties to change.\nA NamedTuple of changes. For example, state = (;k1 = 3.6, k7 = 2.0,) to change state.k1 to 3.6 and state.k7 to 2.0.\nbond_states=(): bond state properties to change.\nA Tuple of changes. If an element in the tuple is nothing, the corresponding bond state isn’t changed. For example, bond_states = (nothing, (;L0 = 3.6,)) to change bond_states[2].L0 to 3.6.\nbond_enabled=(): bond enable flags to change.\nA Tuple of Union{Bool, Nothing}. If an element in the tuple isnothing, the corresponding bond enable flag isn't changed. For example,bond_enabled = (nothing, true, false)` to not change bond 1, enable bond 2, and disable bond 3.\nreaction_enabled=(): reaction enable flags to change.\nA Tuple of NamedTuple of changes. If an element in the tuple is nothing, the corresponding reaction enable flags aren’t changed. For example, reaction_enabled = (nothing, (;a=true, b=false)) to not change any reactions on place 1, enable reaction a on place 2, and disable reaction b on place 2.\nis_minimized::Bool=false: is the link marked as minimized.\nBy default links are marked as minimized at the end of mechanics when updated."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.remove_link--01531e04ef5077e7",
    "href": "docstrings/src/links/link-manager.html#medyan.remove_link--01531e04ef5077e7",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "remove_link!(c::Context, link::Link)::Nothing\nRemove the link."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.update_link--67d413cca6fe82eb",
    "href": "docstrings/src/links/link-manager.html#medyan.update_link--67d413cca6fe82eb",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "update_link!(c::Context, link::Link; kwargs...)::Nothing\nUpdate the link.\n\n\n\nplaces=(): places or tags to attach to the link.\nSet an element to nothing not change the attached place. Set an element to a null place or tag to detach that place.\nstate=(;): state properties to change.\nA NamedTuple of changes. For example, state = (;k1 = 3.6, k7 = 2.0,) to change state.k1 to 3.6 and state.k7 to 2.0.\nbond_states=(): bond state properties to change.\nA Tuple of changes. If an element in the tuple is nothing, the corresponding bond state isn’t changed. For example, bond_states = (nothing, (;L0 = 3.6,)) to change bond_states[2].L0 to 3.6.\nbond_enabled=(): bond enable flags to change.\nA Tuple of Union{Bool, Nothing}. If an element in the tuple isnothing, the corresponding bond enable flag isn't changed. For example,bond_enabled = (nothing, true, false)` to not change bond 1, enable bond 2, and disable bond 3.\nreaction_enabled=(): reaction enable flags to change.\nA Tuple of NamedTuple of changes. If an element in the tuple is nothing, the corresponding reaction enable flags aren’t changed. For example, reaction_enabled = (nothing, (;a=true, b=false)) to not change any reactions on place 1, enable reaction a on place 2, and disable reaction b on place 2.\nis_minimized::Bool=false: is the link marked as minimized.\nBy default links are marked as minimized at the end of mechanics when updated."
  },
  {
    "objectID": "docstrings/src/links/link-manager.html#medyan.get_all_links-fe0d12c0df825f7e",
    "href": "docstrings/src/links/link-manager.html#medyan.get_all_links-fe0d12c0df825f7e",
    "title": "src/links/link-manager.jl",
    "section": "",
    "text": "get_all_links(c::Context; type::Union{Symbol,Integer}) -&gt; Link iterator\nReturn an iterator of all Links of type type."
  },
  {
    "objectID": "docstrings/src/membrane/membranesites.html",
    "href": "docstrings/src/membrane/membranesites.html",
    "title": "src/membrane/membranesites.jl",
    "section": "",
    "text": "Allows up to 1 membrane diffusing species as reactants. Also stores net stoich of membrane diffusing species.\n\nid_membranediffusing_reactant::Int64: Set to 0 if no membrane diffusing species is involved.\ncanchangerate_bypotentialenergy::Bool: Whether the reaction rate depends on reactant species potential energy.\nmembranediffusingnet_stoich::Vector{Pair{Int64, Int64}}: Pairs of membrane diffusing species index =&gt; Δcount"
  },
  {
    "objectID": "docstrings/src/membrane/membranesites.html#medyan.membranesitediffusing-66734014eb12ddb1",
    "href": "docstrings/src/membrane/membranesites.html#medyan.membranesitediffusing-66734014eb12ddb1",
    "title": "src/membrane/membranesites.jl",
    "section": "",
    "text": "Allows up to 1 membrane diffusing species as reactants. Also stores net stoich of membrane diffusing species.\n\nid_membranediffusing_reactant::Int64: Set to 0 if no membrane diffusing species is involved.\ncanchangerate_bypotentialenergy::Bool: Whether the reaction rate depends on reactant species potential energy.\nmembranediffusingnet_stoich::Vector{Pair{Int64, Int64}}: Pairs of membrane diffusing species index =&gt; Δcount"
  },
  {
    "objectID": "docstrings/src/membrane/make_memb.html",
    "href": "docstrings/src/membrane/make_memb.html",
    "title": "src/membrane/make_memb.jl",
    "section": "",
    "text": "make_memb!(c::Context; vertex_positions, triangles)::MembId\nReturn a membrane identifier of the newly created membrane.\n\n\n\nvertex_positions: Each element is a vertex position (nm).\ntriangles::Vector{SVector{3, Int}}: Each element is the 3 vertex indexes of a triangle.\nIndexes are one based, and follow the right hand rule. Looking at the triangle from the outside in, they have counterclockwise winding.\nvertex_states::Union{Vector{Int64}, Nothing} = nothing: Each element is a vertex state.\nBy default vertices have a state of zero. If a vertex has a non zero state, it will not be removed during mesh adaption.\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior."
  },
  {
    "objectID": "docstrings/src/membrane/make_memb.html#medyan.make_memb--3b9234d85f7612ed",
    "href": "docstrings/src/membrane/make_memb.html#medyan.make_memb--3b9234d85f7612ed",
    "title": "src/membrane/make_memb.jl",
    "section": "",
    "text": "make_memb!(c::Context; vertex_positions, triangles)::MembId\nReturn a membrane identifier of the newly created membrane.\n\n\n\nvertex_positions: Each element is a vertex position (nm).\ntriangles::Vector{SVector{3, Int}}: Each element is the 3 vertex indexes of a triangle.\nIndexes are one based, and follow the right hand rule. Looking at the triangle from the outside in, they have counterclockwise winding.\nvertex_states::Union{Vector{Int64}, Nothing} = nothing: Each element is a vertex state.\nBy default vertices have a state of zero. If a vertex has a non zero state, it will not be removed during mesh adaption.\nmech_params::MembraneMechParams = MembraneMechParams(): Mechanical parameters for membrane mechanics\narea0::Union{Float64, Nothing} = nothing: Reference area (if nothing, computed from initial mesh) (nm^2)\nvolume0::Union{Float64, Nothing} = nothing: Reference volume (if nothing, computed from initial mesh) (nm^3)\noffset_volume::Float64=0.0: Actual volume is cone volume with the origin plus the offset (nm^3)\ntype::Int=1: Membrane type index\nchem_boundary::Bool = false: If true, the membrane acts as a boundary for 3D diffusing species.\nchem_boundary_exterior::Bool = false: If true, the confined chemical domain is the exterior; otherwise the confined domain is the interior."
  },
  {
    "objectID": "docstrings/src/membrane/meshadapt.html",
    "href": "docstrings/src/membrane/meshadapt.html",
    "title": "src/membrane/meshadapt.jl",
    "section": "",
    "text": "Return the number of vertices with state vertex_state."
  },
  {
    "objectID": "docstrings/src/membrane/meshadapt.html#medyan.num_vertexwithstate-3cf6fcd964588d37",
    "href": "docstrings/src/membrane/meshadapt.html#medyan.num_vertexwithstate-3cf6fcd964588d37",
    "title": "src/membrane/meshadapt.jl",
    "section": "",
    "text": "Return the number of vertices with state vertex_state."
  },
  {
    "objectID": "docstrings/src/sys_def.html",
    "href": "docstrings/src/sys_def.html",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "add_diffusion_coeff!(s::SysDef, name::Symbol, coeff::Float64)\nUpdate the diffusion coefficient for an existing diffusing species.\nThe species must already exist in s.diffusing (typically added via def_diffusing_species!.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the existing diffusing species.\ncoeff::Float64: The diffusion coefficient in units of nm²/s.\n\n\n\n\nThe modified SysDef.\nSee also: def_diffusing_species! to add a new species with its diffusion coefficient in one step.\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef_diffusing_species!(s::SysDef, name::Symbol; coeff::Float64)\nDynamically add a new diffusing species to the system definition.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new diffusing species.\ncoeff::Float64: The diffusion coefficient in units of (nm²/s).\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if a diffusing species with the given name already exists.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef_fixed_species!(s::SysDef, name::Symbol)\nDynamically add a new fixed (non-diffusing) species to the system definition.\nMust be called before adding any sites (filament sites, filament end sites, membrane sites, link types, etc.) or reactions.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new fixed species.\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if the fixed species already exists.\nError if sites or reactions have already been added.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef_fila_type!(s::SysDef; name::Symbol, mono_states::Vector{Symbol}, param::FilamentMechParams)\nAdd a new filament type to the system definition.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new filament type.\nmono_states::Vector{Symbol}: Vector of monomer state names for this filament type. Must not be empty.\nparam::FilamentMechParams: The filament mechanical parameters.\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if a filament type with the given name already exists.\nError if mono_states is empty.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nadd_filament_params!(s::SysDef, filament_name::Symbol, filament_params::FilamentMechParams)\nUpdate the filament mechanical parameters for an existing filament type.\nThe filament type must already exist in s.filament (typically added via def_fila_type!.\n\n\n\ns::SysDef: The system definition to modify.\nfilament_name::Symbol: The name of the existing filament type.\nfilament_params::FilamentMechParams: The mechanical parameters to set.\n\n\n\n\nThe modified SysDef.\nSee also: def_fila_type! to add a new filament type with its parameters in one step.\n\n\n\n\n\n\n\n\n\n\n\n\n\naddfilamentsite!(s::SysDef,filamenttypename::Symbol,filamentsitename::Symbol,site)\n\n\n\n\n\n\n\n\n\n\n\n\naddfilamentendsite!(s::SysDef,filamenttypename::Symbol,filamentendsitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\nadd_decimated_2mon_site!(s::SysDef,decimated_2mon_sitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddpossiblecadherinsite!(s::SysDef,possiblecadherinsitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddmembranesite!(\n    s::MEDYAN.SysDef,\n    membranesitename::Symbol,\n    site\n) -&gt; MEDYAN.SysDef\nAdd a new site with a specified name. During this process, a new fixed species is created suffixed with “membranesite.”.\n\n\n\n\n\n\n\n\n\n\n\n\ndef_link_type!(s::SysDef; name, description, places, bonds, reactions, param, state)::SysDef\nAdd a new link type to the system definition. Links represent connections between simulation elements (filament monomers, filament tips, anchors, membrane vertices) that can have associated mechanical bonds and chemical reactions.\n\n\n\nname::Symbol: Unique identifier for this link type.\ndescription::String=\"\": Human-readable description of the link’s purpose.\nplaces::Vector{&lt;:Place}: The places this link connects. Each place can be:\n\nFilaMonoIdx(): A filament monomer\nFilaTipIdx(): A filament tip (plus or minus end)\nAnchor(): A free-floating anchor point (e.g., membrane-bound protein)\nBallIdx(): A ball (spherical object)\nMembVertIdx(): A membrane vertex\n\nbonds::Vector: Mechanical bonds between places. Each bond is a NamedTuple with:\n\nbond: Bond type (e.g., DistanceRestraint(), custom Bond subtype)\ninput::Tuple{Int...}: Which places the bond connects\nparam::NamedTuple: Fixed parameters (e.g., spring constant k)\nstate::NamedTuple: Mutable state (e.g., rest length L0)\nenabled::Bool=true: Whether bond is active by default\n\nreactions::Vector{Vector}: Reactions for each place. reactions[i] is a Vector of reactions for places[i]. Trailing places with no reactions can be omitted (i.e. length(reactions) ≤ length(places)). Each reaction is a NamedTuple with:\n\nRequired fields:\n\nname::Symbol: Unique identifier for this reaction within the place.\naffect!: Callback that executes the reaction. Signature: (c::Context; link::Link, chem_voxel::Int, reaction_id, place_idx, kwargs...) -&gt; Int. link is a handle identifying the specific link instance — pass it to get_state, update_link!, link2tags, etc. Return a status code for debugging purposes. For fila_cutoff reactions, also receives place::FilaMonoIdx (a randomly chosen nearby filament monomer within the cutoff distance).\n\nOptional fields:\n\nrate = Returns(1.0): Function (c::Context; link::Link, link_data, place_idx, link_state::NamedTuple, kwargs...) -&gt; Float64 returning the state-dependent rate factor. link_state is the current mutable state of this link instance (as defined by the state keyword). For multi-site binding, return the number of available sites (e.g., MAX_ARP23 - link_state.num_arp23). link_data is an internal object — pass it through to link2tags or get_link_mechanics for a small performance gain over the 1-argument forms. See “When rates are reevaluated” below for important constraints on what this function should depend on.\nbase_rate::Float64 = 1.0: Rate constant multiplier. Units depend on invvolumepower: 1/s for unimolecular (invvolumepower=0), nm³/s for bimolecular (invvolumepower=1). For example, a diffusion-limited on-rate k_D = 4πDR ≈ 1.57×10⁹ nm³/s for D=25 μm²/s, R=5 nm. Separating large rate constants from small integer multipliers in rate avoids overflow.\ninvvolumepower::Int64 = 0: Volume scaling. Set to 1 for bimolecular (nm³/s), 0 for unimolecular (1/s).\nreactants_extra::String = \"\": Additional reactant species whose counts multiply the propensity (e.g., \"diffusing.ARP23\"). Uses the same \"+\"-separated format as def_reaction! (e.g., \"diffusing.A + diffusing.B\").\nfila_cutoff::Tuple{Symbol, Float64} = nothing: If set, e.g., (:actin, 50.0), the propensity is multiplied by the number of nearby filament monomers of that type within the cutoff distance (nm). When the reaction fires, affect! receives one such monomer as place::FilaMonoIdx. Some monomers are invisible to this search until after a mechanics cycle — see “Monomer count caching and mechanics” below.\nenabled::Bool = true: Whether reaction is active by default.\n\n\nparam::NamedTuple=(;): Fixed parameters for the link type.\nstate::NamedTuple=(;): Initial mutable state (e.g., (num_bound=Int32(0),)).\n\n\n\n\nAlthough the rate callback receives the full Context and could in principle read any simulation state, the cached rate value is only incrementally recalculated for a specific link when one of the following events occurs during a chemistry step:\n\nupdate_link! is called on this link — any change to state, places, bond_states, bond_enabled, or reaction_enabled triggers a rate recalculation for all reactions on this link.\nThe chemical state (get_chem_state) of an attached place changes — specifically:\n\nA filament monomer state changes (e.g., via polymerization, depolymerization, severing, or update_fila_mono_state!): rates are recalculated for links attached to the changed monomer and its ±1 neighbors (and attached tips).\nAn anchor is moved via update_anchor!.\nA ball is modified via update_ball!.\n\n\nThe entire cache is fully rebuilt at the start of each chemistry phase after mechanics — so all rates are recomputed from scratch using the current Context state after mechanics.\nThis means: within a chemistry step, if the rate function reads something from the Context other than link_state or the chem state of its own places (see get_chem_state), that dependency will not be tracked and the cached rate will become stale until the next full cache rebuild. For example:\n\n✅ Safe: Reading link_state fields (e.g., link_state.num_arp23). Updated immediately when update_link! changes state.\n✅ Safe: Reading get_chem_state of attached places, or calling get_link_mechanics / is_minimized on the same link (these change only after mechanics, which triggers a full cache rebuild before the next chemistry step).\n⚠️ Stale within a chemistry step: Reading diffusing species counts, other links’ states, or the chem state of places that this link is not attached to. These values may change during chemistry without triggering a rate update for this link.\n\nWorkaround — rejection sampling: If a reaction rate genuinely depends on state that rate cannot track (e.g., the state of a nearby monomer not attached to this link), have rate return an upper bound of the true rate. Then in affect!, read the current state and accept the reaction with probability true_rate / upper_bound (rejecting by returning 0 otherwise). This preserves correct stochastic kinetics despite the stale cache.\n\n\n\nWhen a reaction has fila_cutoff set, its total propensity is base_rate × rate(...) × nearby_monomer_count × .... The nearby monomer count is cached alongside the rate factor and has its own important update semantics:\nUnminimized monomers are invisible to the neighbor search. The map_nearby_monomers function skips monomers within fila_num_unmin_ends of each filament end. Several operations mark monomers as “not minimized”, making them invisible until after the next mechanics cycle (which zeros fila_num_unmin_ends):\n\nmake_fila! / make_fila_rand!: All monomers on a newly created filament start unminimized.\npolymerize_fila!: The newly added monomer at the polymerized end is unminimized.\ndepolymerize_fila!: Decrements the unminimized count on the depolymerized end (saturating at 0).\nsever_fila!: All monomers on both daughter filaments are marked unminimized.\n\n\n\n\nconst NPF_MAX_ARP23 = Int32(3)  # maximum ARP2/3 that can bind per NPF\n\nMEDYAN.def_link_type!(s;\n    name=:npf_anchor,\n    description=\"Nucleation promoting factor anchored to membrane\",\n    places=[Anchor()],\n    state=(;\n        num_arp23 = Int32(0),  # bound ARP2/3 count\n        num_actin = Int32(0),  # bound actin count\n    ),\n    reactions=[\n        [  # reactions for places[1] (the Anchor)\n            # Bimolecular binding: NPF + diffusing ARP2/3 → NPF·ARP2/3\n            (;\n                name = :arp23_bind,\n                affect! = (c; link, chem_voxel, kwargs...) -&gt; let\n                    link_state = get_state(c, link)\n                    update_link!(c, link; state=(num_arp23=link_state.num_arp23 + Int32(1),))\n                    add_diffusing_count!(c; species=:ARP23, chem_voxel, amount=-1)\n                    1  # success\n                end,\n                rate = (c; link_state, kwargs...) -&gt; NPF_MAX_ARP23 - link_state.num_arp23,\n                base_rate = 5E7,  # nm³/s (bimolecular on-rate)\n                reactants_extra = \"diffusing.ARP23\",\n                invvolumepower = 1,\n            ),\n            # Unimolecular unbinding: NPF·ARP2/3 → NPF + ARP2/3\n            (;\n                name = :arp23_unbind,\n                affect! = (c; link, chem_voxel, kwargs...) -&gt; let\n                    link_state = get_state(c, link)\n                    update_link!(c, link; state=(num_arp23=link_state.num_arp23 - Int32(1),))\n                    add_diffusing_count!(c; species=:ARP23, chem_voxel, amount=+1)\n                    1  # success\n                end,\n                rate = (c; link_state, kwargs...) -&gt; link_state.num_arp23,\n                base_rate = 0.01,  # 1/s per bound ARP2/3\n            ),\n        ],\n    ],\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\naddreaction!(s::SysDef,reactionexpr::AbstractString,rate::Float64,invvolumepower::Int)::SysDef\nAdd a reaction to the system. Return s\nreactionexpr is a string describing the reaction stoichiometry\nreactionexpr is comprised of reactant and product parts seperated by a \"--&gt;\"\nAll whitespace characters are ignored.\nEach side is then split by \"+\" to get the species names.\nRepeated or extra \"+\" are ignored.\nA species name can be prepended by a positive integer to represent multiple copies.\n\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s) rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)).\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\"diffusing.a + diffusing.b --&gt; diffusing.c\"\n\"diffusing.c --&gt; diffusing.a + diffusing.b\"\n\"+ + diffusing.c + --&gt; + diffusing.a + + diffusing.b + +\"\n\" --&gt; diffusing.a + diffusing.b\"\n\"diffusing.a + diffusing.b --&gt; \"\n\"diffusing.a + diffusing.a --&gt; \"\n\"2diffusing.a --&gt; \"\n\"2diffusing.a --&gt; 20diffusing.a\"\n\"diffusing.c + diffusing.b --&gt; diffusing.c + diffusing.b\"\n\"fixedspecies.rate1b --&gt; fixedspecies.g\"\n\"fixedspecies.rate1b + fixedspecies.g --&gt; fixedspecies.g\"\n\"fixedspecies.rate1b + 23fixedspecies.g --&gt; fixedspecies.g\"\n\"fixedspecies.g --&gt; fixedspecies.rate1b + 23fixedspecies.g\"\n\"fixedspecies.g + fixedspecies.rate1b--&gt; 2fixedspecies.rate1b + 23fixedspecies.g\"\n\"filamentsite.MT.d --&gt; filamentsite.MT.d\"\n\"filamentsite.MT.d + diffusing.a --&gt; filamentsite.MT.d\"\n\"fixedspecies.g --&gt; diffusing.a\"\n\"diffusing.a --&gt; fixedspecies.g\"\n\"filamentsite.actin.pm + diffusing.a --&gt; filamentsite.actin.pm\"\n\n\n\n\n\n\n\n\n\n\n\n\n\naddreactioncallback!(s::SysDef, reactantexpr::AbstractString, rate::Float64, invvolumepower::Int, callback)::SysDef\nLike addreaction! but also adds callback. callback is called when the reaction happens with input of MEDYAN.Context and Int the chem_voxel id where the reaction happened.\nThe callback should handle updating species counts.\nMEDYAN.errorcheck_addcallback(callback,s::SysDef) can optionally be overloaded to add errorchecking when the callback is added.\n\n\n\n\n\n\n\n\n\n\n\n\ndef_reaction!(s::SysDef, reaction_expr::AbstractString; base_rate, invvolumepower=0, affect!=nothing)\nAdd a chem_voxel reaction to the system definition. Returns s.\nreaction_expr is a string describing the reaction. The format depends on whether affect! is provided:\n\nWithout affect!: reaction_expr must contain \"--&gt;\" to separate reactants from products. Stoichiometry is computed automatically.\nWith affect!: reaction_expr lists only the reactants (no \"--&gt;\"). Net stoichiometry is zero; the callback handles all state changes.\n\nreaction_expr is comprised of reactant and product parts separated by \"--&gt;\". All whitespace is ignored. Each side is split by \"+\" to get species names. Repeated or extra \"+\" are ignored. A species name can be prepended by a positive integer to represent multiple copies (e.g., \"2diffusing.A\").\nSpecies name prefixes:\n\ndiffusing.X — diffusing species\nfixedspecies.X — fixed (non-diffusing) species\nfilamentsite.T.N — filament monomer site\nfilamentendsite.T.N — filament end site\ndecimated_2mon_site.N — decimated two-monomer site\n\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s. Rate constants are stochastic rate constants in the sense of Gillespie (1976).\ninvvolumepower::Int = 0: volumefactor = (1/volume)^invvolumepower where volume is the chem_voxel volume in nm³. Typically 0 for unimolecular, 1 for bimolecular, 2 for trimolecular.\n\n\n\n\n\naffect!: Callback fired when the reaction occurs. Signature: (c::Context; chem_voxel::Int, kwargs...) -&gt; Any. When provided, reaction_expr must not contain \"--&gt;\".\n\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_diffusing_species!(s, :A; coeff=2.5e7)\ndef_diffusing_species!(s, :B; coeff=2.5e7)\ndef_diffusing_species!(s, :C; coeff=2.5e7)\n\n# Bimolecular: A + B → C\ndef_reaction!(s, \"diffusing.A + diffusing.B --&gt; diffusing.C\";\n    base_rate = 1.5e6,\n    invvolumepower = 1,\n)\n\n# Unimolecular: C → A + B\ndef_reaction!(s, \"diffusing.C --&gt; diffusing.A + diffusing.B\";\n    base_rate = 1.75,\n)\n\n# Zero-order creation\ndef_reaction!(s, \" --&gt; diffusing.A + diffusing.B\";\n    base_rate = 1.75,\n)\n\n# With a callback (reactants only, no \"--&gt;\")\ndef_reaction!(s, \"diffusing.A + diffusing.B\";\n    base_rate = 1e8,\n    invvolumepower = 1,\n    affect! = (c; chem_voxel, kwargs...) -&gt; begin\n        # custom logic here\n        nothing\n    end,\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef_fila_reaction!(s::SysDef; fila_type, name, match, ...)\nAdd a filament monomer reaction. The reaction fires at monomers whose local neighborhood matches a pattern of states. When it fires, the matched monomers can be changed to new, or a custom affect! callback can handle arbitrary side effects.\nAll pattern positions must lie on the filament. Monomers near the ends where the pattern would extend past the boundary are automatically skipped. Use def_fila_tip_reaction! for reactions at filament ends.\n\n\n\n\n\nfila_type::Symbol: Filament type (e.g., :actin).\nname::Symbol: Unique name for this reaction site.\nmatch::Vector: Pattern of monomer states to match, ordered minus → plus end. Each element can be:\n\nSymbol — exact state (e.g., :a)\nVector{Symbol} — any of these states (e.g., [:a, :b])\nanystate — any state\n\n\n\n\n\n\nnew::Vector{Symbol}: States to assign to the matched monomers after firing. Must be the same length as match. Cannot be used with affect!.\naffect!: Custom callback (c::Context; chem_voxel::Int, center::FilaMonoIdx, kwargs...) -&gt; Int. Called instead of automatic state changes. The returned Int is a status code. Cannot be used with new.\n\n\n\n\n\nnet_stoich::Vector{Pair{Symbol,Int}} = Pair{Symbol,Int}[]: Net change to diffusing species when the reaction fires. Each entry is species_name =&gt; amount, e.g. [:ligand =&gt; -1] to consume one ligand per firing. The callback handles the count update automatically. Can only be used with new, not with affect!.\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s.\ninvvolumepower::Int = 0: Set to 0 for unimolecular, 1 for bimolecular.\nreactants_extra::String = \"\": Additional reactant species that contribute to propensity (e.g., \"diffusing.ligand\"). The species is not consumed automatically.\n\n\n\n\n\ncenter::Int = cld(length(match), 2): Which position in match is the center of the reaction. Determines which chem_voxel the reaction is assigned to.\n\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_fila_type!(s; name=:actin, mono_states=[:a, :b, :c], param=MEDYAN.ACTIN_TWIST_PARAMS)\n\n# Aging: every :a monomer transitions to :b\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :aging,\n    match = [:a],\n    new = [:b],\n    base_rate = 2.4,\n)\n\n# Cooperative transition: :a next to :b on the minus side becomes :b\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :cooperate,\n    match = [:b, :a],\n    new = [:b, :b],\n    center = 2,\n    base_rate = 0.4,\n)\n\n# Bimolecular binding with a diffusing ligand using affect!\ndef_diffusing_species!(s, :ligand; coeff=2.5e7)\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :bind_affect,\n    match = [:a],\n    affect! = (c; center, chem_voxel, kwargs...) -&gt; let\n        update_fila_mono_state!(c, center, :b)\n        add_diffusing_count!(c; species=:ligand, chem_voxel, amount=-1)\n        1\n    end,\n    base_rate = 1e6,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.ligand\",\n)\n\n# Bimolecular binding with a diffusing ligand using net_stoich\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :bind_stoich,\n    match = [:a],\n    new = [:b],\n    net_stoich = [:ligand =&gt; -1],\n    base_rate = 1e6,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.ligand\",\n)\n\n# Match a set of states: :a or :b → :c\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :a_or_b,\n    match = [[:a, :b]],\n    new = [:c],\n    base_rate = 1.0,\n)\n\n# anystate with neighbor constraint: any monomer whose plus neighbor is :a\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :any_then_a,\n    match = [anystate, :a],\n    new = [:a, :b],\n    center = 2,\n    base_rate = 1.0,\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef_fila_tip_reaction!(s::SysDef; fila_type, name, is_minus_end, match, spacing, ...)\nAdd a filament tip reaction that fires only at either the plus or minus end of a filament.\nThis mirrors def_fila_reaction! in API style and rate wiring, but the pattern is anchored at a filament end. new may be shorter or longer than match to represent depolymerization or polymerization.\nmatch and new are always ordered from minus end toward plus end. If is_minus_end = true, the pattern is matched against the first length(match) monomers; if is_minus_end = false, it is matched against the last length(match) monomers.\n\n\n\n\n\nfila_type::Symbol: Filament type (e.g., :actin).\nname::Symbol: Unique name for this tip site.\nis_minus_end::Bool: Which filament end to target. true targets the minus end; false targets the plus end.\nmatch::Vector: Pattern of monomer states to match (minus → plus order). Elements can be Symbol, Vector{Symbol} (state set), or anystate.\nspacing::Float64: Space needed at the filament end for this reaction (nm). This affects a load-force rate factor via exp(-β * spacing * loadforce) where β is 1/kT and loadforce is the external force pushing axially on the end of the filament.\n\n\n\n\n\nnew::Vector{Symbol}: New monomer states (minus → plus order) for the tip region. If length(new) &gt; length(match), monomers are added. If length(new) &lt; length(match), monomers are removed. Cannot be used with affect!.\naffect!: Custom callback (c::Context; chem_voxel::Int, tip::FilaTipIdx, kwargs...) -&gt; Int. Called instead of automatic changes. Cannot be used with new.\n\n\n\n\n\nnet_stoich::Vector{Pair{Symbol,Int}} = Pair{Symbol,Int}[]: Net change to diffusing species when the reaction fires. Each entry is species_name =&gt; amount, e.g. [:actin_mon =&gt; -1] to consume one monomer per polymerization. The callback handles the count update automatically. Can only be used with new, not with affect!.\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s.\ninvvolumepower::Int = 0: Set to 0 for unimolecular, 1 for bimolecular.\nreactants_extra::String = \"\": Additional reactant species that contribute to propensity (e.g., \"diffusing.ligand\"). The species is not consumed automatically.\nadded_monomers::Union{Int, Nothing}: The number of monomers added by the reaction. This is automatically determined if new is passed. Each filament has a limited number of monomers that can be added per end\n\nbetween mechanic solves given by FilamentMechParams.max_num_unmin_end. The filament tip reaction is disabled on tips where the added monomers would cause that limit to be exceeded.\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_fila_type!(s; name=:actin, mono_states=[:a, :plusend, :minusend], param=MEDYAN.ACTIN_TWIST_PARAMS)\ndef_diffusing_species!(s, :actin_mon; coeff=2.5e7)\n\n# Plus-end polymerization: add one monomer (bimolecular with diffusing actin)\ndef_fila_tip_reaction!(s;\n    fila_type = :actin,\n    name = :pp,\n    is_minus_end = false,\n    match = [:plusend],\n    spacing = 2.7,\n    new = [:a, :plusend],\n    net_stoich = [:actin_mon =&gt; -1],\n    base_rate = 1.93e7,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.actin_mon\",\n)\n\n# Plus-end polymerization: add one monomer (bimolecular with diffusing actin)\n# Using affect!\ndef_fila_tip_reaction!(s;\n    fila_type = :actin,\n    name = :pp_affect,\n    is_minus_end = false,\n    match = [:a, :plusend],\n    spacing = 2.7,\n    affect! = (c; tip, chem_voxel, kwargs...) -&gt; begin\n        update_fila_mono_state!(c, FilaMonoIdx(c, tip), :a)\n        polymerize_fila!(c, tip, :plusend)\n        add_diffusing_count!(c; species=:actin_mon, chem_voxel, amount=-1)\n        1\n    end,\n    added_monomers = 1,\n    base_rate = 1.93e7,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.actin_mon\",\n)\n\n# Minus-end depolymerization: remove one monomer, release actin back to solution\ndef_fila_tip_reaction!(s;\n    fila_type = :actin, name = :dm,\n    is_minus_end = true,\n    match = [:minusend, :a],\n    spacing = 0.0,\n    new = [:minusend],\n    net_stoich = [:actin_mon =&gt; +1],\n    base_rate = 1.4,\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd a membrane site with the corresponding reaction with callback.\nKeyword arguments:\n\ns: SysDef.\nname_newmembranesite: Symbol.\nmembranediffusingreactants: Vector of symbols as membrane reactants. 0 or 1 reactant is currently supported.\nmembranediffusingproducts: Vector of symbols as membrane products.\nreactionexpr_extra: Reaction expression for other species involved.\nrate: Float.\nchangerage_bypotentialenergy: Whether the rate is affected by potential energy.\ninvvolumepower: rate scaling with compartment volume.\n\nNotes:\n\nIf error occurs, this function does not ensure that s is unchanged."
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.add_diffusion_coeff--a77d1ef833cfdedd",
    "href": "docstrings/src/sys_def.html#medyan.add_diffusion_coeff--a77d1ef833cfdedd",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "add_diffusion_coeff!(s::SysDef, name::Symbol, coeff::Float64)\nUpdate the diffusion coefficient for an existing diffusing species.\nThe species must already exist in s.diffusing (typically added via def_diffusing_species!.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the existing diffusing species.\ncoeff::Float64: The diffusion coefficient in units of nm²/s.\n\n\n\n\nThe modified SysDef.\nSee also: def_diffusing_species! to add a new species with its diffusion coefficient in one step."
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.def_diffusing_species--e07d4f4fa5062c57",
    "href": "docstrings/src/sys_def.html#medyan.def_diffusing_species--e07d4f4fa5062c57",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "def_diffusing_species!(s::SysDef, name::Symbol; coeff::Float64)\nDynamically add a new diffusing species to the system definition.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new diffusing species.\ncoeff::Float64: The diffusion coefficient in units of (nm²/s).\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if a diffusing species with the given name already exists."
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.def_fixed_species--490fb150d53e2870",
    "href": "docstrings/src/sys_def.html#medyan.def_fixed_species--490fb150d53e2870",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "def_fixed_species!(s::SysDef, name::Symbol)\nDynamically add a new fixed (non-diffusing) species to the system definition.\nMust be called before adding any sites (filament sites, filament end sites, membrane sites, link types, etc.) or reactions.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new fixed species.\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if the fixed species already exists.\nError if sites or reactions have already been added."
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.def_fila_type--5a1f6234215ea82d",
    "href": "docstrings/src/sys_def.html#medyan.def_fila_type--5a1f6234215ea82d",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "def_fila_type!(s::SysDef; name::Symbol, mono_states::Vector{Symbol}, param::FilamentMechParams)\nAdd a new filament type to the system definition.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new filament type.\nmono_states::Vector{Symbol}: Vector of monomer state names for this filament type. Must not be empty.\nparam::FilamentMechParams: The filament mechanical parameters.\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if a filament type with the given name already exists.\nError if mono_states is empty."
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.add_filament_params--74c7d0081157ca31",
    "href": "docstrings/src/sys_def.html#medyan.add_filament_params--74c7d0081157ca31",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "add_filament_params!(s::SysDef, filament_name::Symbol, filament_params::FilamentMechParams)\nUpdate the filament mechanical parameters for an existing filament type.\nThe filament type must already exist in s.filament (typically added via def_fila_type!.\n\n\n\ns::SysDef: The system definition to modify.\nfilament_name::Symbol: The name of the existing filament type.\nfilament_params::FilamentMechParams: The mechanical parameters to set.\n\n\n\n\nThe modified SysDef.\nSee also: def_fila_type! to add a new filament type with its parameters in one step."
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.addfilamentsite--eb6bfd871a21b6f4",
    "href": "docstrings/src/sys_def.html#medyan.addfilamentsite--eb6bfd871a21b6f4",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "addfilamentsite!(s::SysDef,filamenttypename::Symbol,filamentsitename::Symbol,site)"
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.addfilamentendsite--95612d72d1fda05f",
    "href": "docstrings/src/sys_def.html#medyan.addfilamentendsite--95612d72d1fda05f",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "addfilamentendsite!(s::SysDef,filamenttypename::Symbol,filamentendsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.add_decimated_2mon_site--ad56e7ee56067940",
    "href": "docstrings/src/sys_def.html#medyan.add_decimated_2mon_site--ad56e7ee56067940",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "add_decimated_2mon_site!(s::SysDef,decimated_2mon_sitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.addpossiblecadherinsite--ae8586daa0b5454a",
    "href": "docstrings/src/sys_def.html#medyan.addpossiblecadherinsite--ae8586daa0b5454a",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "addpossiblecadherinsite!(s::SysDef,possiblecadherinsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.addmembranesite--892875b2c079002d",
    "href": "docstrings/src/sys_def.html#medyan.addmembranesite--892875b2c079002d",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "addmembranesite!(\n    s::MEDYAN.SysDef,\n    membranesitename::Symbol,\n    site\n) -&gt; MEDYAN.SysDef\nAdd a new site with a specified name. During this process, a new fixed species is created suffixed with “membranesite.”."
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.def_link_type--339fe050fe131631",
    "href": "docstrings/src/sys_def.html#medyan.def_link_type--339fe050fe131631",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "def_link_type!(s::SysDef; name, description, places, bonds, reactions, param, state)::SysDef\nAdd a new link type to the system definition. Links represent connections between simulation elements (filament monomers, filament tips, anchors, membrane vertices) that can have associated mechanical bonds and chemical reactions.\n\n\n\nname::Symbol: Unique identifier for this link type.\ndescription::String=\"\": Human-readable description of the link’s purpose.\nplaces::Vector{&lt;:Place}: The places this link connects. Each place can be:\n\nFilaMonoIdx(): A filament monomer\nFilaTipIdx(): A filament tip (plus or minus end)\nAnchor(): A free-floating anchor point (e.g., membrane-bound protein)\nBallIdx(): A ball (spherical object)\nMembVertIdx(): A membrane vertex\n\nbonds::Vector: Mechanical bonds between places. Each bond is a NamedTuple with:\n\nbond: Bond type (e.g., DistanceRestraint(), custom Bond subtype)\ninput::Tuple{Int...}: Which places the bond connects\nparam::NamedTuple: Fixed parameters (e.g., spring constant k)\nstate::NamedTuple: Mutable state (e.g., rest length L0)\nenabled::Bool=true: Whether bond is active by default\n\nreactions::Vector{Vector}: Reactions for each place. reactions[i] is a Vector of reactions for places[i]. Trailing places with no reactions can be omitted (i.e. length(reactions) ≤ length(places)). Each reaction is a NamedTuple with:\n\nRequired fields:\n\nname::Symbol: Unique identifier for this reaction within the place.\naffect!: Callback that executes the reaction. Signature: (c::Context; link::Link, chem_voxel::Int, reaction_id, place_idx, kwargs...) -&gt; Int. link is a handle identifying the specific link instance — pass it to get_state, update_link!, link2tags, etc. Return a status code for debugging purposes. For fila_cutoff reactions, also receives place::FilaMonoIdx (a randomly chosen nearby filament monomer within the cutoff distance).\n\nOptional fields:\n\nrate = Returns(1.0): Function (c::Context; link::Link, link_data, place_idx, link_state::NamedTuple, kwargs...) -&gt; Float64 returning the state-dependent rate factor. link_state is the current mutable state of this link instance (as defined by the state keyword). For multi-site binding, return the number of available sites (e.g., MAX_ARP23 - link_state.num_arp23). link_data is an internal object — pass it through to link2tags or get_link_mechanics for a small performance gain over the 1-argument forms. See “When rates are reevaluated” below for important constraints on what this function should depend on.\nbase_rate::Float64 = 1.0: Rate constant multiplier. Units depend on invvolumepower: 1/s for unimolecular (invvolumepower=0), nm³/s for bimolecular (invvolumepower=1). For example, a diffusion-limited on-rate k_D = 4πDR ≈ 1.57×10⁹ nm³/s for D=25 μm²/s, R=5 nm. Separating large rate constants from small integer multipliers in rate avoids overflow.\ninvvolumepower::Int64 = 0: Volume scaling. Set to 1 for bimolecular (nm³/s), 0 for unimolecular (1/s).\nreactants_extra::String = \"\": Additional reactant species whose counts multiply the propensity (e.g., \"diffusing.ARP23\"). Uses the same \"+\"-separated format as def_reaction! (e.g., \"diffusing.A + diffusing.B\").\nfila_cutoff::Tuple{Symbol, Float64} = nothing: If set, e.g., (:actin, 50.0), the propensity is multiplied by the number of nearby filament monomers of that type within the cutoff distance (nm). When the reaction fires, affect! receives one such monomer as place::FilaMonoIdx. Some monomers are invisible to this search until after a mechanics cycle — see “Monomer count caching and mechanics” below.\nenabled::Bool = true: Whether reaction is active by default.\n\n\nparam::NamedTuple=(;): Fixed parameters for the link type.\nstate::NamedTuple=(;): Initial mutable state (e.g., (num_bound=Int32(0),)).\n\n\n\n\nAlthough the rate callback receives the full Context and could in principle read any simulation state, the cached rate value is only incrementally recalculated for a specific link when one of the following events occurs during a chemistry step:\n\nupdate_link! is called on this link — any change to state, places, bond_states, bond_enabled, or reaction_enabled triggers a rate recalculation for all reactions on this link.\nThe chemical state (get_chem_state) of an attached place changes — specifically:\n\nA filament monomer state changes (e.g., via polymerization, depolymerization, severing, or update_fila_mono_state!): rates are recalculated for links attached to the changed monomer and its ±1 neighbors (and attached tips).\nAn anchor is moved via update_anchor!.\nA ball is modified via update_ball!.\n\n\nThe entire cache is fully rebuilt at the start of each chemistry phase after mechanics — so all rates are recomputed from scratch using the current Context state after mechanics.\nThis means: within a chemistry step, if the rate function reads something from the Context other than link_state or the chem state of its own places (see get_chem_state), that dependency will not be tracked and the cached rate will become stale until the next full cache rebuild. For example:\n\n✅ Safe: Reading link_state fields (e.g., link_state.num_arp23). Updated immediately when update_link! changes state.\n✅ Safe: Reading get_chem_state of attached places, or calling get_link_mechanics / is_minimized on the same link (these change only after mechanics, which triggers a full cache rebuild before the next chemistry step).\n⚠️ Stale within a chemistry step: Reading diffusing species counts, other links’ states, or the chem state of places that this link is not attached to. These values may change during chemistry without triggering a rate update for this link.\n\nWorkaround — rejection sampling: If a reaction rate genuinely depends on state that rate cannot track (e.g., the state of a nearby monomer not attached to this link), have rate return an upper bound of the true rate. Then in affect!, read the current state and accept the reaction with probability true_rate / upper_bound (rejecting by returning 0 otherwise). This preserves correct stochastic kinetics despite the stale cache.\n\n\n\nWhen a reaction has fila_cutoff set, its total propensity is base_rate × rate(...) × nearby_monomer_count × .... The nearby monomer count is cached alongside the rate factor and has its own important update semantics:\nUnminimized monomers are invisible to the neighbor search. The map_nearby_monomers function skips monomers within fila_num_unmin_ends of each filament end. Several operations mark monomers as “not minimized”, making them invisible until after the next mechanics cycle (which zeros fila_num_unmin_ends):\n\nmake_fila! / make_fila_rand!: All monomers on a newly created filament start unminimized.\npolymerize_fila!: The newly added monomer at the polymerized end is unminimized.\ndepolymerize_fila!: Decrements the unminimized count on the depolymerized end (saturating at 0).\nsever_fila!: All monomers on both daughter filaments are marked unminimized.\n\n\n\n\nconst NPF_MAX_ARP23 = Int32(3)  # maximum ARP2/3 that can bind per NPF\n\nMEDYAN.def_link_type!(s;\n    name=:npf_anchor,\n    description=\"Nucleation promoting factor anchored to membrane\",\n    places=[Anchor()],\n    state=(;\n        num_arp23 = Int32(0),  # bound ARP2/3 count\n        num_actin = Int32(0),  # bound actin count\n    ),\n    reactions=[\n        [  # reactions for places[1] (the Anchor)\n            # Bimolecular binding: NPF + diffusing ARP2/3 → NPF·ARP2/3\n            (;\n                name = :arp23_bind,\n                affect! = (c; link, chem_voxel, kwargs...) -&gt; let\n                    link_state = get_state(c, link)\n                    update_link!(c, link; state=(num_arp23=link_state.num_arp23 + Int32(1),))\n                    add_diffusing_count!(c; species=:ARP23, chem_voxel, amount=-1)\n                    1  # success\n                end,\n                rate = (c; link_state, kwargs...) -&gt; NPF_MAX_ARP23 - link_state.num_arp23,\n                base_rate = 5E7,  # nm³/s (bimolecular on-rate)\n                reactants_extra = \"diffusing.ARP23\",\n                invvolumepower = 1,\n            ),\n            # Unimolecular unbinding: NPF·ARP2/3 → NPF + ARP2/3\n            (;\n                name = :arp23_unbind,\n                affect! = (c; link, chem_voxel, kwargs...) -&gt; let\n                    link_state = get_state(c, link)\n                    update_link!(c, link; state=(num_arp23=link_state.num_arp23 - Int32(1),))\n                    add_diffusing_count!(c; species=:ARP23, chem_voxel, amount=+1)\n                    1  # success\n                end,\n                rate = (c; link_state, kwargs...) -&gt; link_state.num_arp23,\n                base_rate = 0.01,  # 1/s per bound ARP2/3\n            ),\n        ],\n    ],\n)"
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.addreaction--da9bd35e7d1df7c3",
    "href": "docstrings/src/sys_def.html#medyan.addreaction--da9bd35e7d1df7c3",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "addreaction!(s::SysDef,reactionexpr::AbstractString,rate::Float64,invvolumepower::Int)::SysDef\nAdd a reaction to the system. Return s\nreactionexpr is a string describing the reaction stoichiometry\nreactionexpr is comprised of reactant and product parts seperated by a \"--&gt;\"\nAll whitespace characters are ignored.\nEach side is then split by \"+\" to get the species names.\nRepeated or extra \"+\" are ignored.\nA species name can be prepended by a positive integer to represent multiple copies.\n\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s) rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)).\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\"diffusing.a + diffusing.b --&gt; diffusing.c\"\n\"diffusing.c --&gt; diffusing.a + diffusing.b\"\n\"+ + diffusing.c + --&gt; + diffusing.a + + diffusing.b + +\"\n\" --&gt; diffusing.a + diffusing.b\"\n\"diffusing.a + diffusing.b --&gt; \"\n\"diffusing.a + diffusing.a --&gt; \"\n\"2diffusing.a --&gt; \"\n\"2diffusing.a --&gt; 20diffusing.a\"\n\"diffusing.c + diffusing.b --&gt; diffusing.c + diffusing.b\"\n\"fixedspecies.rate1b --&gt; fixedspecies.g\"\n\"fixedspecies.rate1b + fixedspecies.g --&gt; fixedspecies.g\"\n\"fixedspecies.rate1b + 23fixedspecies.g --&gt; fixedspecies.g\"\n\"fixedspecies.g --&gt; fixedspecies.rate1b + 23fixedspecies.g\"\n\"fixedspecies.g + fixedspecies.rate1b--&gt; 2fixedspecies.rate1b + 23fixedspecies.g\"\n\"filamentsite.MT.d --&gt; filamentsite.MT.d\"\n\"filamentsite.MT.d + diffusing.a --&gt; filamentsite.MT.d\"\n\"fixedspecies.g --&gt; diffusing.a\"\n\"diffusing.a --&gt; fixedspecies.g\"\n\"filamentsite.actin.pm + diffusing.a --&gt; filamentsite.actin.pm\""
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.addreactioncallback--9c9d46adeded2d88",
    "href": "docstrings/src/sys_def.html#medyan.addreactioncallback--9c9d46adeded2d88",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "addreactioncallback!(s::SysDef, reactantexpr::AbstractString, rate::Float64, invvolumepower::Int, callback)::SysDef\nLike addreaction! but also adds callback. callback is called when the reaction happens with input of MEDYAN.Context and Int the chem_voxel id where the reaction happened.\nThe callback should handle updating species counts.\nMEDYAN.errorcheck_addcallback(callback,s::SysDef) can optionally be overloaded to add errorchecking when the callback is added."
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.def_reaction--60ae13f69a537c68",
    "href": "docstrings/src/sys_def.html#medyan.def_reaction--60ae13f69a537c68",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "def_reaction!(s::SysDef, reaction_expr::AbstractString; base_rate, invvolumepower=0, affect!=nothing)\nAdd a chem_voxel reaction to the system definition. Returns s.\nreaction_expr is a string describing the reaction. The format depends on whether affect! is provided:\n\nWithout affect!: reaction_expr must contain \"--&gt;\" to separate reactants from products. Stoichiometry is computed automatically.\nWith affect!: reaction_expr lists only the reactants (no \"--&gt;\"). Net stoichiometry is zero; the callback handles all state changes.\n\nreaction_expr is comprised of reactant and product parts separated by \"--&gt;\". All whitespace is ignored. Each side is split by \"+\" to get species names. Repeated or extra \"+\" are ignored. A species name can be prepended by a positive integer to represent multiple copies (e.g., \"2diffusing.A\").\nSpecies name prefixes:\n\ndiffusing.X — diffusing species\nfixedspecies.X — fixed (non-diffusing) species\nfilamentsite.T.N — filament monomer site\nfilamentendsite.T.N — filament end site\ndecimated_2mon_site.N — decimated two-monomer site\n\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s. Rate constants are stochastic rate constants in the sense of Gillespie (1976).\ninvvolumepower::Int = 0: volumefactor = (1/volume)^invvolumepower where volume is the chem_voxel volume in nm³. Typically 0 for unimolecular, 1 for bimolecular, 2 for trimolecular.\n\n\n\n\n\naffect!: Callback fired when the reaction occurs. Signature: (c::Context; chem_voxel::Int, kwargs...) -&gt; Any. When provided, reaction_expr must not contain \"--&gt;\".\n\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_diffusing_species!(s, :A; coeff=2.5e7)\ndef_diffusing_species!(s, :B; coeff=2.5e7)\ndef_diffusing_species!(s, :C; coeff=2.5e7)\n\n# Bimolecular: A + B → C\ndef_reaction!(s, \"diffusing.A + diffusing.B --&gt; diffusing.C\";\n    base_rate = 1.5e6,\n    invvolumepower = 1,\n)\n\n# Unimolecular: C → A + B\ndef_reaction!(s, \"diffusing.C --&gt; diffusing.A + diffusing.B\";\n    base_rate = 1.75,\n)\n\n# Zero-order creation\ndef_reaction!(s, \" --&gt; diffusing.A + diffusing.B\";\n    base_rate = 1.75,\n)\n\n# With a callback (reactants only, no \"--&gt;\")\ndef_reaction!(s, \"diffusing.A + diffusing.B\";\n    base_rate = 1e8,\n    invvolumepower = 1,\n    affect! = (c; chem_voxel, kwargs...) -&gt; begin\n        # custom logic here\n        nothing\n    end,\n)"
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.def_fila_reaction--070b0fa01eaea608",
    "href": "docstrings/src/sys_def.html#medyan.def_fila_reaction--070b0fa01eaea608",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "def_fila_reaction!(s::SysDef; fila_type, name, match, ...)\nAdd a filament monomer reaction. The reaction fires at monomers whose local neighborhood matches a pattern of states. When it fires, the matched monomers can be changed to new, or a custom affect! callback can handle arbitrary side effects.\nAll pattern positions must lie on the filament. Monomers near the ends where the pattern would extend past the boundary are automatically skipped. Use def_fila_tip_reaction! for reactions at filament ends.\n\n\n\n\n\nfila_type::Symbol: Filament type (e.g., :actin).\nname::Symbol: Unique name for this reaction site.\nmatch::Vector: Pattern of monomer states to match, ordered minus → plus end. Each element can be:\n\nSymbol — exact state (e.g., :a)\nVector{Symbol} — any of these states (e.g., [:a, :b])\nanystate — any state\n\n\n\n\n\n\nnew::Vector{Symbol}: States to assign to the matched monomers after firing. Must be the same length as match. Cannot be used with affect!.\naffect!: Custom callback (c::Context; chem_voxel::Int, center::FilaMonoIdx, kwargs...) -&gt; Int. Called instead of automatic state changes. The returned Int is a status code. Cannot be used with new.\n\n\n\n\n\nnet_stoich::Vector{Pair{Symbol,Int}} = Pair{Symbol,Int}[]: Net change to diffusing species when the reaction fires. Each entry is species_name =&gt; amount, e.g. [:ligand =&gt; -1] to consume one ligand per firing. The callback handles the count update automatically. Can only be used with new, not with affect!.\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s.\ninvvolumepower::Int = 0: Set to 0 for unimolecular, 1 for bimolecular.\nreactants_extra::String = \"\": Additional reactant species that contribute to propensity (e.g., \"diffusing.ligand\"). The species is not consumed automatically.\n\n\n\n\n\ncenter::Int = cld(length(match), 2): Which position in match is the center of the reaction. Determines which chem_voxel the reaction is assigned to.\n\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_fila_type!(s; name=:actin, mono_states=[:a, :b, :c], param=MEDYAN.ACTIN_TWIST_PARAMS)\n\n# Aging: every :a monomer transitions to :b\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :aging,\n    match = [:a],\n    new = [:b],\n    base_rate = 2.4,\n)\n\n# Cooperative transition: :a next to :b on the minus side becomes :b\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :cooperate,\n    match = [:b, :a],\n    new = [:b, :b],\n    center = 2,\n    base_rate = 0.4,\n)\n\n# Bimolecular binding with a diffusing ligand using affect!\ndef_diffusing_species!(s, :ligand; coeff=2.5e7)\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :bind_affect,\n    match = [:a],\n    affect! = (c; center, chem_voxel, kwargs...) -&gt; let\n        update_fila_mono_state!(c, center, :b)\n        add_diffusing_count!(c; species=:ligand, chem_voxel, amount=-1)\n        1\n    end,\n    base_rate = 1e6,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.ligand\",\n)\n\n# Bimolecular binding with a diffusing ligand using net_stoich\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :bind_stoich,\n    match = [:a],\n    new = [:b],\n    net_stoich = [:ligand =&gt; -1],\n    base_rate = 1e6,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.ligand\",\n)\n\n# Match a set of states: :a or :b → :c\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :a_or_b,\n    match = [[:a, :b]],\n    new = [:c],\n    base_rate = 1.0,\n)\n\n# anystate with neighbor constraint: any monomer whose plus neighbor is :a\ndef_fila_reaction!(s;\n    fila_type = :actin, name = :any_then_a,\n    match = [anystate, :a],\n    new = [:a, :b],\n    center = 2,\n    base_rate = 1.0,\n)"
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.def_fila_tip_reaction--488aa3a14ff39688",
    "href": "docstrings/src/sys_def.html#medyan.def_fila_tip_reaction--488aa3a14ff39688",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "def_fila_tip_reaction!(s::SysDef; fila_type, name, is_minus_end, match, spacing, ...)\nAdd a filament tip reaction that fires only at either the plus or minus end of a filament.\nThis mirrors def_fila_reaction! in API style and rate wiring, but the pattern is anchored at a filament end. new may be shorter or longer than match to represent depolymerization or polymerization.\nmatch and new are always ordered from minus end toward plus end. If is_minus_end = true, the pattern is matched against the first length(match) monomers; if is_minus_end = false, it is matched against the last length(match) monomers.\n\n\n\n\n\nfila_type::Symbol: Filament type (e.g., :actin).\nname::Symbol: Unique name for this tip site.\nis_minus_end::Bool: Which filament end to target. true targets the minus end; false targets the plus end.\nmatch::Vector: Pattern of monomer states to match (minus → plus order). Elements can be Symbol, Vector{Symbol} (state set), or anystate.\nspacing::Float64: Space needed at the filament end for this reaction (nm). This affects a load-force rate factor via exp(-β * spacing * loadforce) where β is 1/kT and loadforce is the external force pushing axially on the end of the filament.\n\n\n\n\n\nnew::Vector{Symbol}: New monomer states (minus → plus order) for the tip region. If length(new) &gt; length(match), monomers are added. If length(new) &lt; length(match), monomers are removed. Cannot be used with affect!.\naffect!: Custom callback (c::Context; chem_voxel::Int, tip::FilaTipIdx, kwargs...) -&gt; Int. Called instead of automatic changes. Cannot be used with new.\n\n\n\n\n\nnet_stoich::Vector{Pair{Symbol,Int}} = Pair{Symbol,Int}[]: Net change to diffusing species when the reaction fires. Each entry is species_name =&gt; amount, e.g. [:actin_mon =&gt; -1] to consume one monomer per polymerization. The callback handles the count update automatically. Can only be used with new, not with affect!.\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s.\ninvvolumepower::Int = 0: Set to 0 for unimolecular, 1 for bimolecular.\nreactants_extra::String = \"\": Additional reactant species that contribute to propensity (e.g., \"diffusing.ligand\"). The species is not consumed automatically.\nadded_monomers::Union{Int, Nothing}: The number of monomers added by the reaction. This is automatically determined if new is passed. Each filament has a limited number of monomers that can be added per end\n\nbetween mechanic solves given by FilamentMechParams.max_num_unmin_end. The filament tip reaction is disabled on tips where the added monomers would cause that limit to be exceeded.\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_fila_type!(s; name=:actin, mono_states=[:a, :plusend, :minusend], param=MEDYAN.ACTIN_TWIST_PARAMS)\ndef_diffusing_species!(s, :actin_mon; coeff=2.5e7)\n\n# Plus-end polymerization: add one monomer (bimolecular with diffusing actin)\ndef_fila_tip_reaction!(s;\n    fila_type = :actin,\n    name = :pp,\n    is_minus_end = false,\n    match = [:plusend],\n    spacing = 2.7,\n    new = [:a, :plusend],\n    net_stoich = [:actin_mon =&gt; -1],\n    base_rate = 1.93e7,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.actin_mon\",\n)\n\n# Plus-end polymerization: add one monomer (bimolecular with diffusing actin)\n# Using affect!\ndef_fila_tip_reaction!(s;\n    fila_type = :actin,\n    name = :pp_affect,\n    is_minus_end = false,\n    match = [:a, :plusend],\n    spacing = 2.7,\n    affect! = (c; tip, chem_voxel, kwargs...) -&gt; begin\n        update_fila_mono_state!(c, FilaMonoIdx(c, tip), :a)\n        polymerize_fila!(c, tip, :plusend)\n        add_diffusing_count!(c; species=:actin_mon, chem_voxel, amount=-1)\n        1\n    end,\n    added_monomers = 1,\n    base_rate = 1.93e7,\n    invvolumepower = 1,\n    reactants_extra = \"diffusing.actin_mon\",\n)\n\n# Minus-end depolymerization: remove one monomer, release actin back to solution\ndef_fila_tip_reaction!(s;\n    fila_type = :actin, name = :dm,\n    is_minus_end = true,\n    match = [:minusend, :a],\n    spacing = 0.0,\n    new = [:minusend],\n    net_stoich = [:actin_mon =&gt; +1],\n    base_rate = 1.4,\n)"
  },
  {
    "objectID": "docstrings/src/sys_def.html#medyan.add_membranesitereaction--59d1fe245302e071",
    "href": "docstrings/src/sys_def.html#medyan.add_membranesitereaction--59d1fe245302e071",
    "title": "src/sys_def.jl",
    "section": "",
    "text": "Add a membrane site with the corresponding reaction with callback.\nKeyword arguments:\n\ns: SysDef.\nname_newmembranesite: Symbol.\nmembranediffusingreactants: Vector of symbols as membrane reactants. 0 or 1 reactant is currently supported.\nmembranediffusingproducts: Vector of symbols as membrane products.\nreactionexpr_extra: Reaction expression for other species involved.\nrate: Float.\nchangerage_bypotentialenergy: Whether the rate is affected by potential energy.\ninvvolumepower: rate scaling with compartment volume.\n\nNotes:\n\nIf error occurs, this function does not ensure that s is unchanged."
  },
  {
    "objectID": "docstrings/src/trajectory-io/snapshot.html",
    "href": "docstrings/src/trajectory-io/snapshot.html",
    "title": "src/trajectory-io/snapshot.jl",
    "section": "",
    "text": "load_snapshot!(c::Context,group::ZGroup)\nEmpty the context and load the state saved in the snapshot group.\nc should be constructed with the same SysDef and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nSee Snapshot group for more details."
  },
  {
    "objectID": "docstrings/src/trajectory-io/snapshot.html#medyan.load_snapshot--e534be293ce74465",
    "href": "docstrings/src/trajectory-io/snapshot.html#medyan.load_snapshot--e534be293ce74465",
    "title": "src/trajectory-io/snapshot.jl",
    "section": "",
    "text": "load_snapshot!(c::Context,group::ZGroup)\nEmpty the context and load the state saved in the snapshot group.\nc should be constructed with the same SysDef and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nSee Snapshot group for more details."
  },
  {
    "objectID": "docstrings/src/filament/sites.html",
    "href": "docstrings/src/filament/sites.html",
    "title": "src/filament/sites.jl",
    "section": "",
    "text": "General filament site just matches monomer states\n\ncenter::Int64: index of center monomer in states\nstates::Vector{UInt8}: monomer states to match\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnyState()\nSingleton type used in match in def_fila_reaction! and def_fila_tip_reaction! to match any MonomerState.\nUse the exported constant anystate instead of constructing directly.\n\n\n\n\n\n\n\n\n\n\n\n\nconst anystate = AnyState()\nA special value in match in def_fila_reaction! and def_fila_tip_reaction! to match any MonomerState."
  },
  {
    "objectID": "docstrings/src/filament/sites.html#medyan.filamentsitegeneral-0d87ce44fed17b2c",
    "href": "docstrings/src/filament/sites.html#medyan.filamentsitegeneral-0d87ce44fed17b2c",
    "title": "src/filament/sites.jl",
    "section": "",
    "text": "General filament site just matches monomer states\n\ncenter::Int64: index of center monomer in states\nstates::Vector{UInt8}: monomer states to match"
  },
  {
    "objectID": "docstrings/src/filament/sites.html#medyan.anystate-1965db924963e911",
    "href": "docstrings/src/filament/sites.html#medyan.anystate-1965db924963e911",
    "title": "src/filament/sites.jl",
    "section": "",
    "text": "AnyState()\nSingleton type used in match in def_fila_reaction! and def_fila_tip_reaction! to match any MonomerState.\nUse the exported constant anystate instead of constructing directly."
  },
  {
    "objectID": "docstrings/src/filament/sites.html#medyan.anystate-5e989313a9ef75d3",
    "href": "docstrings/src/filament/sites.html#medyan.anystate-5e989313a9ef75d3",
    "title": "src/filament/sites.jl",
    "section": "",
    "text": "const anystate = AnyState()\nA special value in match in def_fila_reaction! and def_fila_tip_reaction! to match any MonomerState."
  },
  {
    "objectID": "docstrings/src/filament/sever_fila.html",
    "href": "docstrings/src/filament/sever_fila.html",
    "title": "src/filament/sever_fila.jl",
    "section": "",
    "text": "sever_fila!(c::Context, place::FilaMonoIdx)::Tag{FilaTipIdx}\nReturn the tag of the new filament plus end.\nThe split will happen between place and the monomer slightly towards the minus end.\nThe split cannot create a filament with less than 2 monomers."
  },
  {
    "objectID": "docstrings/src/filament/sever_fila.html#medyan.sever_fila--161c869bc5d06d6a",
    "href": "docstrings/src/filament/sever_fila.html#medyan.sever_fila--161c869bc5d06d6a",
    "title": "src/filament/sever_fila.jl",
    "section": "",
    "text": "sever_fila!(c::Context, place::FilaMonoIdx)::Tag{FilaTipIdx}\nReturn the tag of the new filament plus end.\nThe split will happen between place and the monomer slightly towards the minus end.\nThe split cannot create a filament with less than 2 monomers."
  },
  {
    "objectID": "docstrings/src/filament/make_fila.html",
    "href": "docstrings/src/filament/make_fila.html",
    "title": "src/filament/make_fila.jl",
    "section": "",
    "text": "make_fila!(c::Context;\n    type=1,\n    mono_states,\n    node_mids,\n    node_positions,\n)::Tag{FilaTipIdx}\nReturn the tag of the plus tip of the new filament. Error if the filament isn’t initially over 2 monomers long. Newly added filaments can’t be selected from nearby monomers until after minimization.\n\n\n\ntype=1: filament type id or symbol.\nmono_states: Collection of the MonomerState or Symbol of the monomers in the new filament. In order from minus end to plus end. length(mono_states)&gt;1\nnode_positions: Collection of SVector{3,Float64}. The positions of the nodes, monomers are between nodes.\nnode_mids: Collection of Integer. The monomer ids at (slightly plus side of) the node_positions | ––-+––-|––-+––- minus end &lt;–– M | M | (M) | M ––&gt; plus end ––-+––-|––-+––- | ^ A node_position is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids length(node_mids) == length(node_positions) - 1\nminus_end_mat_dir=nothing: SVector{3,Float64}. The mat direction of the minus end node.\njoint_twists=nothing: Collection ofFloat64`. The extra material frame axial rotation at the joints between the cylinders.\ntip_load_forces=(0.0=&gt;0.0): tip load forces, usually don’t use this, because load forces will automatically get updated at the next minimization."
  },
  {
    "objectID": "docstrings/src/filament/make_fila.html#medyan.make_fila--f2346a40b4792de5",
    "href": "docstrings/src/filament/make_fila.html#medyan.make_fila--f2346a40b4792de5",
    "title": "src/filament/make_fila.jl",
    "section": "",
    "text": "make_fila!(c::Context;\n    type=1,\n    mono_states,\n    node_mids,\n    node_positions,\n)::Tag{FilaTipIdx}\nReturn the tag of the plus tip of the new filament. Error if the filament isn’t initially over 2 monomers long. Newly added filaments can’t be selected from nearby monomers until after minimization.\n\n\n\ntype=1: filament type id or symbol.\nmono_states: Collection of the MonomerState or Symbol of the monomers in the new filament. In order from minus end to plus end. length(mono_states)&gt;1\nnode_positions: Collection of SVector{3,Float64}. The positions of the nodes, monomers are between nodes.\nnode_mids: Collection of Integer. The monomer ids at (slightly plus side of) the node_positions | ––-+––-|––-+––- minus end &lt;–– M | M | (M) | M ––&gt; plus end ––-+––-|––-+––- | ^ A node_position is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids length(node_mids) == length(node_positions) - 1\nminus_end_mat_dir=nothing: SVector{3,Float64}. The mat direction of the minus end node.\njoint_twists=nothing: Collection ofFloat64`. The extra material frame axial rotation at the joints between the cylinders.\ntip_load_forces=(0.0=&gt;0.0): tip load forces, usually don’t use this, because load forces will automatically get updated at the next minimization."
  },
  {
    "objectID": "docstrings/src/filament/depolymerize_fila.html",
    "href": "docstrings/src/filament/depolymerize_fila.html",
    "title": "src/filament/depolymerize_fila.jl",
    "section": "",
    "text": "depolymerize_fila!(c::Context, fila_tip_idx::FilaTipIdx)\nRemove a monomer from the end of the filament.\nThis doesn’t affect the other monomer states, positions, or change any of the monomer ids.\nError if the filament isn’t initially over 2 monomers long.\nUnlink any monomers on the filament that are referenced by any links. The links will not be removed, but will have a null reference. Links attached to the filament tip will remain attached."
  },
  {
    "objectID": "docstrings/src/filament/depolymerize_fila.html#medyan.depolymerize_fila--7aae43ce27544212",
    "href": "docstrings/src/filament/depolymerize_fila.html#medyan.depolymerize_fila--7aae43ce27544212",
    "title": "src/filament/depolymerize_fila.jl",
    "section": "",
    "text": "depolymerize_fila!(c::Context, fila_tip_idx::FilaTipIdx)\nRemove a monomer from the end of the filament.\nThis doesn’t affect the other monomer states, positions, or change any of the monomer ids.\nError if the filament isn’t initially over 2 monomers long.\nUnlink any monomers on the filament that are referenced by any links. The links will not be removed, but will have a null reference. Links attached to the filament tip will remain attached."
  },
  {
    "objectID": "docstrings/src/filament/functions.html",
    "href": "docstrings/src/filament/functions.html",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "num_fila_types(c::MEDYAN.Context) -&gt; Int64\nReturn the number of filament types.\n\n\n\n\n\n\n\n\n\n\n\n\nfila_type_name(c::Context, f::Union{Tag, FilaIdx})::Symbol\nfila_type_name(c::Context; type::Union{Symbol, Integer})::Symbol\nReturn the name of the f’s type, or the name associated with type\n\n\n\n\n\n\n\n\n\n\n\n\nfila_typeid(c::Context, f::Union{Tag, FilaIdx})::Int\nfila_typeid(c::Context; type::Union{Symbol,Integer})::Int\nReturn the typeid of a filament f or associated with type.\n\n\n\n\n\n\n\n\n\n\n\n\nnum_fila(c::MEDYAN.Context; type) -&gt; Int64\nReturn the number of filaments of a given type.\n\n\n\n\n\n\n\n\n\n\n\n\nfila_mono_ids(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; UnitRange{Int64}\nReturn a UnitRange{Int64} of monomer IDs on a filament.\n\n\n\n\n\n\n\n\n\n\n\n\nfila_mono_states(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{UInt8}\nReturn a read only Vector of monomer states on a filament.\nThis can be invalid after any mutations to context, so copy if needed.\n\n\n\n\n\n\n\n\n\n\n\n\nfila_num_nodes(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Int64\nReturn the number of mechanical node positions of a filament.\n\n\n\n\n\n\n\n\n\n\n\n\nfila_node_mids(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{Int64}\nReturn the node_mids of the filament.\nThe node_mids are the monomer ids at (slightly plus side of) the node_positions\n                                 |\n                      -----+-----|-----+-----\n  minus end &lt;----       M  |  M  | (M) |  M        ----&gt; plus end\n                      -----+-----|-----+-----\n                                 |\n                                 ^ A node position is indicated by the line.\n\nThe monomer id with parenthesis (M) will in `node_mids`\nThe first monomer id is the first monomer id on the filament. The last monomer id is the last monomer id on the filament + 1\n\n\n\n\n\n\n\n\n\n\n\n\nfila_node_positions(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{StaticArraysCore.SVector{3, Float64}}\nReturn the mechanical node positions of the filament.\n\n\n\n\n\n\n\n\n\n\n\n\nfila_tip_tags(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Pair{MEDYAN.Tag{MEDYAN.FilaTipIdx}, MEDYAN.Tag{MEDYAN.FilaTipIdx}}\nReturn the pair of minus end, plus end filament tip tags.\n\n\n\n\n\n\n\n\n\n\n\n\nfila_num_unmin_ends(\n    c::MEDYAN.Context,\n    fila_idx::MEDYAN.FilaIdx\n) -&gt; Pair{Int64, Int64}\nReturn a pair (minus =&gt; plus) of the number of unminimized monomers on the minus and plus end of a filament.\nThis will be reset to (0 =&gt; 0) by minimize_energy!\nWhen an end is depolymerized this will decrease, but saturate at 0. When an end is polymerized this will increase.\nFor example if after minimization a filament has a plus end depolymerization, this function will return (0 =&gt; 0). Then if a plus end polymerization happens, this function will return (0 =&gt; 1), even though the net change in filament length is zero.\n\n\n\n\n\n\n\n\n\n\n\n\nis_minimized(c::Context, p::Union{FilaMonoIdx, FilaTipIdx, Tag})::Bool\nReturn true iff the monomer or tip has been minimized. Throw an error if p doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\npick_rand_fila_mono_site(c::Context, chem_voxel, fila_typeid, fsid)::Union{FilaMonoIdx, Nothing}\nReturn a FilaMonoIdx of a random filamonosite, or return nothing if rejected weighted by counts, using the default RNG.\n\n\n\n\n\n\n\n\n\n\n\n\npick_rand_fila_tip_site(c::Context, chem_voxel, fila_typeid, fesid)::Union{FilaTipIdx, Nothing}\nReturn a FilaTipIdx of a random filaendsite, or return nothing if rejected weighted by counts, using the default RNG."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.num_fila_types-1698969c2a51ad88",
    "href": "docstrings/src/filament/functions.html#medyan.num_fila_types-1698969c2a51ad88",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "num_fila_types(c::MEDYAN.Context) -&gt; Int64\nReturn the number of filament types."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.fila_type_name-6e5acc13d811899b",
    "href": "docstrings/src/filament/functions.html#medyan.fila_type_name-6e5acc13d811899b",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "fila_type_name(c::Context, f::Union{Tag, FilaIdx})::Symbol\nfila_type_name(c::Context; type::Union{Symbol, Integer})::Symbol\nReturn the name of the f’s type, or the name associated with type"
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.fila_typeid-1616b490df0cda1e",
    "href": "docstrings/src/filament/functions.html#medyan.fila_typeid-1616b490df0cda1e",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "fila_typeid(c::Context, f::Union{Tag, FilaIdx})::Int\nfila_typeid(c::Context; type::Union{Symbol,Integer})::Int\nReturn the typeid of a filament f or associated with type."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.num_fila-6aa6f32d094c895e",
    "href": "docstrings/src/filament/functions.html#medyan.num_fila-6aa6f32d094c895e",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "num_fila(c::MEDYAN.Context; type) -&gt; Int64\nReturn the number of filaments of a given type."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.fila_mono_ids-946d70c3169126dd",
    "href": "docstrings/src/filament/functions.html#medyan.fila_mono_ids-946d70c3169126dd",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "fila_mono_ids(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; UnitRange{Int64}\nReturn a UnitRange{Int64} of monomer IDs on a filament."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.fila_mono_states-bf83d6c80fc4d691",
    "href": "docstrings/src/filament/functions.html#medyan.fila_mono_states-bf83d6c80fc4d691",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "fila_mono_states(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{UInt8}\nReturn a read only Vector of monomer states on a filament.\nThis can be invalid after any mutations to context, so copy if needed."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.fila_num_nodes-a3efee39b1440945",
    "href": "docstrings/src/filament/functions.html#medyan.fila_num_nodes-a3efee39b1440945",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "fila_num_nodes(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Int64\nReturn the number of mechanical node positions of a filament."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.fila_node_mids-35de9fc339cbec42",
    "href": "docstrings/src/filament/functions.html#medyan.fila_node_mids-35de9fc339cbec42",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "fila_node_mids(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{Int64}\nReturn the node_mids of the filament.\nThe node_mids are the monomer ids at (slightly plus side of) the node_positions\n                                 |\n                      -----+-----|-----+-----\n  minus end &lt;----       M  |  M  | (M) |  M        ----&gt; plus end\n                      -----+-----|-----+-----\n                                 |\n                                 ^ A node position is indicated by the line.\n\nThe monomer id with parenthesis (M) will in `node_mids`\nThe first monomer id is the first monomer id on the filament. The last monomer id is the last monomer id on the filament + 1"
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.fila_node_positions-f4c5bac0dcb570ff",
    "href": "docstrings/src/filament/functions.html#medyan.fila_node_positions-f4c5bac0dcb570ff",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "fila_node_positions(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{StaticArraysCore.SVector{3, Float64}}\nReturn the mechanical node positions of the filament."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.fila_tip_tags-f05dfa7a845b20ea",
    "href": "docstrings/src/filament/functions.html#medyan.fila_tip_tags-f05dfa7a845b20ea",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "fila_tip_tags(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Pair{MEDYAN.Tag{MEDYAN.FilaTipIdx}, MEDYAN.Tag{MEDYAN.FilaTipIdx}}\nReturn the pair of minus end, plus end filament tip tags."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.fila_num_unmin_ends-09448ccb823dbeac",
    "href": "docstrings/src/filament/functions.html#medyan.fila_num_unmin_ends-09448ccb823dbeac",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "fila_num_unmin_ends(\n    c::MEDYAN.Context,\n    fila_idx::MEDYAN.FilaIdx\n) -&gt; Pair{Int64, Int64}\nReturn a pair (minus =&gt; plus) of the number of unminimized monomers on the minus and plus end of a filament.\nThis will be reset to (0 =&gt; 0) by minimize_energy!\nWhen an end is depolymerized this will decrease, but saturate at 0. When an end is polymerized this will increase.\nFor example if after minimization a filament has a plus end depolymerization, this function will return (0 =&gt; 0). Then if a plus end polymerization happens, this function will return (0 =&gt; 1), even though the net change in filament length is zero."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.is_minimized-ff3858ada5447c46",
    "href": "docstrings/src/filament/functions.html#medyan.is_minimized-ff3858ada5447c46",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "is_minimized(c::Context, p::Union{FilaMonoIdx, FilaTipIdx, Tag})::Bool\nReturn true iff the monomer or tip has been minimized. Throw an error if p doesn’t exist."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.pick_rand_fila_mono_site-6641f66ed8873af1",
    "href": "docstrings/src/filament/functions.html#medyan.pick_rand_fila_mono_site-6641f66ed8873af1",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "pick_rand_fila_mono_site(c::Context, chem_voxel, fila_typeid, fsid)::Union{FilaMonoIdx, Nothing}\nReturn a FilaMonoIdx of a random filamonosite, or return nothing if rejected weighted by counts, using the default RNG."
  },
  {
    "objectID": "docstrings/src/filament/functions.html#medyan.pick_rand_fila_tip_site-d1418d43027273e9",
    "href": "docstrings/src/filament/functions.html#medyan.pick_rand_fila_tip_site-d1418d43027273e9",
    "title": "src/filament/functions.jl",
    "section": "",
    "text": "pick_rand_fila_tip_site(c::Context, chem_voxel, fila_typeid, fesid)::Union{FilaTipIdx, Nothing}\nReturn a FilaTipIdx of a random filaendsite, or return nothing if rejected weighted by counts, using the default RNG."
  },
  {
    "objectID": "docstrings/src/util/stableindex.html",
    "href": "docstrings/src/util/stableindex.html",
    "title": "src/util/stableindex.jl",
    "section": "",
    "text": "Whether an ID is in use.\n\n\n\n\n\n\n\n\n\n\n\n\nTotal number of IDs in use.\n\n\n\n\n\n\n\n\n\n\n\n\nGet index at ID.\n\n\n\n\n\n\n\n\n\n\n\n\nMap ID to a new index. The ID must be in use.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd a new index. Returns its ID.\n\n\n\n\n\n\n\n\n\n\n\n\nRemove a recorded index at ID.\n\n\n\n\n\n\n\n\n\n\n\n\nClear all index records.\n\n\n\n\n\n\n\n\n\n\n\n\nIterates through valid IDs in the StableIndex."
  },
  {
    "objectID": "docstrings/src/util/stableindex.html#base.haskey-e7d3f961991e2663",
    "href": "docstrings/src/util/stableindex.html#base.haskey-e7d3f961991e2663",
    "title": "src/util/stableindex.jl",
    "section": "",
    "text": "Whether an ID is in use."
  },
  {
    "objectID": "docstrings/src/util/stableindex.html#base.length-7ea31a421de7d258",
    "href": "docstrings/src/util/stableindex.html#base.length-7ea31a421de7d258",
    "title": "src/util/stableindex.jl",
    "section": "",
    "text": "Total number of IDs in use."
  },
  {
    "objectID": "docstrings/src/util/stableindex.html#base.getindex-f593dde852851bc8",
    "href": "docstrings/src/util/stableindex.html#base.getindex-f593dde852851bc8",
    "title": "src/util/stableindex.jl",
    "section": "",
    "text": "Get index at ID."
  },
  {
    "objectID": "docstrings/src/util/stableindex.html#base.setindex--725f722fff4cfa6d",
    "href": "docstrings/src/util/stableindex.html#base.setindex--725f722fff4cfa6d",
    "title": "src/util/stableindex.jl",
    "section": "",
    "text": "Map ID to a new index. The ID must be in use."
  },
  {
    "objectID": "docstrings/src/util/stableindex.html#base.push--8715d52e2302aaeb",
    "href": "docstrings/src/util/stableindex.html#base.push--8715d52e2302aaeb",
    "title": "src/util/stableindex.jl",
    "section": "",
    "text": "Add a new index. Returns its ID."
  },
  {
    "objectID": "docstrings/src/util/stableindex.html#base.delete--56ef520341df3c06",
    "href": "docstrings/src/util/stableindex.html#base.delete--56ef520341df3c06",
    "title": "src/util/stableindex.jl",
    "section": "",
    "text": "Remove a recorded index at ID."
  },
  {
    "objectID": "docstrings/src/util/stableindex.html#base.empty--418304748816268d",
    "href": "docstrings/src/util/stableindex.html#base.empty--418304748816268d",
    "title": "src/util/stableindex.jl",
    "section": "",
    "text": "Clear all index records."
  },
  {
    "objectID": "docstrings/src/util/stableindex.html#base.iterate-5228367cd62c0bf2",
    "href": "docstrings/src/util/stableindex.html#base.iterate-5228367cd62c0bf2",
    "title": "src/util/stableindex.jl",
    "section": "",
    "text": "Iterates through valid IDs in the StableIndex."
  },
  {
    "objectID": "docstrings/src/sys_def-types.html",
    "href": "docstrings/src/sys_def-types.html",
    "title": "src/sys_def-types.jl",
    "section": "",
    "text": "The names of the agents in a simulation\n\ndiffusingspeciesnames::Vector{Symbol}\nbulkspeciesnames::Vector{Symbol}\nmembranediffusingspeciesnames::Vector{Symbol}\nfixedspeciesnames::Vector{Symbol}\nfilamentnames::Vector{Tuple{Symbol, Vector{Symbol}}}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmembraneindex::Int64: membrane index\nvid::Int64: vertex id\n\n\n\n\n\n\n\n\n\n\n\n\n\nSysDef(agent_names::AgentNames)\nA mutable struct mapping names to id numbers in a simulation\n\nagent_names::MEDYAN.AgentNames\ndiffusing::MEDYAN.PropDictionary\ndiffusing_coeff::MEDYAN.PropDictionary\nbulkspecies_indexmap::MEDYAN.PropDictionary\nmembranediffusing::MEDYAN.PropDictionary\nfixedspecies::MEDYAN.PropDictionary\nfilament::MEDYAN.PropDictionary\nfilament_params::MEDYAN.PropDictionary\nstate::MEDYAN.PropDictionary\nfilamentsite::MEDYAN.PropDictionary\nfilamentendsite::MEDYAN.PropDictionary\nmembranesite::MEDYAN.PropDictionary: Each membrane site represents the membrane patches in each compartment together with some membrane diffusing species.\ndecimated_2mon_site::MEDYAN.PropDictionary\npossiblecadherinsite::MEDYAN.PropDictionary\nallfixedspeciesnames::Vector{String}\ncompartmentreactions::Vector{MEDYAN.CompartmentReaction}\ncompartmentreactioncallbacks::Vector{Any}\nbulkreactions::Vector{MEDYAN.BulkReaction}\nbulkreactioncallbacks::Vector{Any}: Context -&gt; Nothing\nlink::MEDYAN.PropDictionary\ntotal_num_link_types_places::Int64\nlink_reaction_site::MEDYAN.PropDictionary\n\n\n\n\n\n\n\n\n\n\nCreate an empty SysDef with no agents."
  },
  {
    "objectID": "docstrings/src/sys_def-types.html#medyan.agentnames-948e6a24b4fb0cb5",
    "href": "docstrings/src/sys_def-types.html#medyan.agentnames-948e6a24b4fb0cb5",
    "title": "src/sys_def-types.jl",
    "section": "",
    "text": "The names of the agents in a simulation\n\ndiffusingspeciesnames::Vector{Symbol}\nbulkspeciesnames::Vector{Symbol}\nmembranediffusingspeciesnames::Vector{Symbol}\nfixedspeciesnames::Vector{Symbol}\nfilamentnames::Vector{Tuple{Symbol, Vector{Symbol}}}"
  },
  {
    "objectID": "docstrings/src/sys_def-types.html#medyan.vertexname-2d87a6a86cabc4f5",
    "href": "docstrings/src/sys_def-types.html#medyan.vertexname-2d87a6a86cabc4f5",
    "title": "src/sys_def-types.jl",
    "section": "",
    "text": "membraneindex::Int64: membrane index\nvid::Int64: vertex id"
  },
  {
    "objectID": "docstrings/src/sys_def-types.html#medyan.sysdef-c0c4da7a2b3d4fef",
    "href": "docstrings/src/sys_def-types.html#medyan.sysdef-c0c4da7a2b3d4fef",
    "title": "src/sys_def-types.jl",
    "section": "",
    "text": "SysDef(agent_names::AgentNames)\nA mutable struct mapping names to id numbers in a simulation\n\nagent_names::MEDYAN.AgentNames\ndiffusing::MEDYAN.PropDictionary\ndiffusing_coeff::MEDYAN.PropDictionary\nbulkspecies_indexmap::MEDYAN.PropDictionary\nmembranediffusing::MEDYAN.PropDictionary\nfixedspecies::MEDYAN.PropDictionary\nfilament::MEDYAN.PropDictionary\nfilament_params::MEDYAN.PropDictionary\nstate::MEDYAN.PropDictionary\nfilamentsite::MEDYAN.PropDictionary\nfilamentendsite::MEDYAN.PropDictionary\nmembranesite::MEDYAN.PropDictionary: Each membrane site represents the membrane patches in each compartment together with some membrane diffusing species.\ndecimated_2mon_site::MEDYAN.PropDictionary\npossiblecadherinsite::MEDYAN.PropDictionary\nallfixedspeciesnames::Vector{String}\ncompartmentreactions::Vector{MEDYAN.CompartmentReaction}\ncompartmentreactioncallbacks::Vector{Any}\nbulkreactions::Vector{MEDYAN.BulkReaction}\nbulkreactioncallbacks::Vector{Any}: Context -&gt; Nothing\nlink::MEDYAN.PropDictionary\ntotal_num_link_types_places::Int64\nlink_reaction_site::MEDYAN.PropDictionary\n\n\n\n\n\n\n\n\n\n\nCreate an empty SysDef with no agents."
  },
  {
    "objectID": "docstrings/src/minimize_energy.html",
    "href": "docstrings/src/minimize_energy.html",
    "title": "src/minimize_energy.jl",
    "section": "",
    "text": "minimize_energy!(c::Context)::MinimizeEnergyResults\nMinimize mechanical energy of the context.\n\n\n\ncheck_closest::Bool=true:\n\nIf true, the function will warn if two objects get too close during minimization.\n\nbrownian_motion_time::Float64=Inf: This parameter is used to simulate the effect\n\nof Brownian motion over a certain period of time in seconds. It is currently experimental. By default, the effect of Brownian motion is ignored.\n\ng_tol::Float64=c.g_tol: The acceptable maximum residual force on any degree of freedom in pN.\niter_max::Int=c.iter_max_cg_minimization: The maximum number of congugate gradient iterations to do before exiting."
  },
  {
    "objectID": "docstrings/src/minimize_energy.html#medyan.minimize_energy--84c4aeab5457d3ee",
    "href": "docstrings/src/minimize_energy.html#medyan.minimize_energy--84c4aeab5457d3ee",
    "title": "src/minimize_energy.jl",
    "section": "",
    "text": "minimize_energy!(c::Context)::MinimizeEnergyResults\nMinimize mechanical energy of the context.\n\n\n\ncheck_closest::Bool=true:\n\nIf true, the function will warn if two objects get too close during minimization.\n\nbrownian_motion_time::Float64=Inf: This parameter is used to simulate the effect\n\nof Brownian motion over a certain period of time in seconds. It is currently experimental. By default, the effect of Brownian motion is ignored.\n\ng_tol::Float64=c.g_tol: The acceptable maximum residual force on any degree of freedom in pN.\niter_max::Int=c.iter_max_cg_minimization: The maximum number of congugate gradient iterations to do before exiting."
  },
  {
    "objectID": "docstrings/base.length-7ea31a421de7d258.html",
    "href": "docstrings/base.length-7ea31a421de7d258.html",
    "title": "Base.length",
    "section": "",
    "text": "Total number of IDs in use.\n\n\n\n\n\n\n\n\n\n\n\n\nBase.length(grid::CubicGrid)\nTotal number of voxels in the grid"
  },
  {
    "objectID": "docstrings/base.length-7ea31a421de7d258.html#tuple-medyan.stableindex--aec9c239cf42c0b9",
    "href": "docstrings/base.length-7ea31a421de7d258.html#tuple-medyan.stableindex--aec9c239cf42c0b9",
    "title": "Base.length",
    "section": "",
    "text": "Total number of IDs in use."
  },
  {
    "objectID": "docstrings/base.length-7ea31a421de7d258.html#tuple-medyan.cubicgrid--0971be2da0774049",
    "href": "docstrings/base.length-7ea31a421de7d258.html#tuple-medyan.cubicgrid--0971be2da0774049",
    "title": "Base.length",
    "section": "",
    "text": "Base.length(grid::CubicGrid)\nTotal number of voxels in the grid"
  },
  {
    "objectID": "docstrings/medyan.get_chem_boundary_tsdf_actual_max_distance-387d81e42009c2e5.html",
    "href": "docstrings/medyan.get_chem_boundary_tsdf_actual_max_distance-387d81e42009c2e5.html",
    "title": "MEDYAN.get_chem_boundary_tsdf_actual_max_distance",
    "section": "",
    "text": "get_chem_boundary_tsdf_actual_max_distance(\n    c::MEDYAN.Context\n) -&gt; Float64\nGet the actual maximum distance used for TSDF truncation (nm). This is max(userspecifiedmaxdistance, 2.5grid*spacing)."
  },
  {
    "objectID": "docstrings/medyan.get_chem_boundary_tsdf_actual_max_distance-387d81e42009c2e5.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.get_chem_boundary_tsdf_actual_max_distance-387d81e42009c2e5.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.get_chem_boundary_tsdf_actual_max_distance",
    "section": "",
    "text": "get_chem_boundary_tsdf_actual_max_distance(\n    c::MEDYAN.Context\n) -&gt; Float64\nGet the actual maximum distance used for TSDF truncation (nm). This is max(userspecifiedmaxdistance, 2.5grid*spacing)."
  },
  {
    "objectID": "docstrings/medyan.update_ball--83d0c0fbbdbab087.html",
    "href": "docstrings/medyan.update_ball--83d0c0fbbdbab087.html",
    "title": "MEDYAN.update_ball!",
    "section": "",
    "text": "update_ball!(c::Context, ball::Union{BallIdx, Tag{BallIdx}}; kwargs...)\nUpdate properties of an existing ball. Unspecified properties remain unchanged.\n\n\n\nposition::Union{Nothing, SVector{3, Float64}}=nothing: New position (nm)\nradius::Union{Nothing, Float32}=nothing: New radius (nm)\nstiffness::Union{Nothing, Float32}=nothing: New stiffness (pN/nm)\nstate::Union{Nothing, SVector{3, Int64}}=nothing: New state vector\nis_minimized::Union{Nothing, Bool}=nothing: Whether the ball is marked as minimized. Defaults to false when position or radius is changed, otherwise unchanged. Set explicitly to override the default behavior.\n\nSee also: make_ball!, remove_ball!, get_position, is_minimized"
  },
  {
    "objectID": "docstrings/medyan.update_ball--83d0c0fbbdbab087.html#tuple-medyan.context--medyan.ballidx--277715bc057ae4e8",
    "href": "docstrings/medyan.update_ball--83d0c0fbbdbab087.html#tuple-medyan.context--medyan.ballidx--277715bc057ae4e8",
    "title": "MEDYAN.update_ball!",
    "section": "",
    "text": "update_ball!(c::Context, ball::Union{BallIdx, Tag{BallIdx}}; kwargs...)\nUpdate properties of an existing ball. Unspecified properties remain unchanged.\n\n\n\nposition::Union{Nothing, SVector{3, Float64}}=nothing: New position (nm)\nradius::Union{Nothing, Float32}=nothing: New radius (nm)\nstiffness::Union{Nothing, Float32}=nothing: New stiffness (pN/nm)\nstate::Union{Nothing, SVector{3, Int64}}=nothing: New state vector\nis_minimized::Union{Nothing, Bool}=nothing: Whether the ball is marked as minimized. Defaults to false when position or radius is changed, otherwise unchanged. Set explicitly to override the default behavior.\n\nSee also: make_ball!, remove_ball!, get_position, is_minimized"
  },
  {
    "objectID": "docstrings/medyan.add_filament_params--74c7d0081157ca31.html",
    "href": "docstrings/medyan.add_filament_params--74c7d0081157ca31.html",
    "title": "MEDYAN.add_filament_params!",
    "section": "",
    "text": "add_filament_params!(s::SysDef, filament_name::Symbol, filament_params::FilamentMechParams)\nUpdate the filament mechanical parameters for an existing filament type.\nThe filament type must already exist in s.filament (typically added via def_fila_type!.\n\n\n\ns::SysDef: The system definition to modify.\nfilament_name::Symbol: The name of the existing filament type.\nfilament_params::FilamentMechParams: The mechanical parameters to set.\n\n\n\n\nThe modified SysDef.\nSee also: def_fila_type! to add a new filament type with its parameters in one step."
  },
  {
    "objectID": "docstrings/medyan.add_filament_params--74c7d0081157ca31.html#tuple-medyan.sysdef--symbol--any--444c61f2a1ac78e1",
    "href": "docstrings/medyan.add_filament_params--74c7d0081157ca31.html#tuple-medyan.sysdef--symbol--any--444c61f2a1ac78e1",
    "title": "MEDYAN.add_filament_params!",
    "section": "",
    "text": "add_filament_params!(s::SysDef, filament_name::Symbol, filament_params::FilamentMechParams)\nUpdate the filament mechanical parameters for an existing filament type.\nThe filament type must already exist in s.filament (typically added via def_fila_type!.\n\n\n\ns::SysDef: The system definition to modify.\nfilament_name::Symbol: The name of the existing filament type.\nfilament_params::FilamentMechParams: The mechanical parameters to set.\n\n\n\n\nThe modified SysDef.\nSee also: def_fila_type! to add a new filament type with its parameters in one step."
  },
  {
    "objectID": "docstrings/medyan.fila_num_unmin_ends-09448ccb823dbeac.html",
    "href": "docstrings/medyan.fila_num_unmin_ends-09448ccb823dbeac.html",
    "title": "MEDYAN.fila_num_unmin_ends",
    "section": "",
    "text": "fila_num_unmin_ends(\n    c::MEDYAN.Context,\n    fila_idx::MEDYAN.FilaIdx\n) -&gt; Pair{Int64, Int64}\nReturn a pair (minus =&gt; plus) of the number of unminimized monomers on the minus and plus end of a filament.\nThis will be reset to (0 =&gt; 0) by minimize_energy!\nWhen an end is depolymerized this will decrease, but saturate at 0. When an end is polymerized this will increase.\nFor example if after minimization a filament has a plus end depolymerization, this function will return (0 =&gt; 0). Then if a plus end polymerization happens, this function will return (0 =&gt; 1), even though the net change in filament length is zero."
  },
  {
    "objectID": "docstrings/medyan.fila_num_unmin_ends-09448ccb823dbeac.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "href": "docstrings/medyan.fila_num_unmin_ends-09448ccb823dbeac.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "title": "MEDYAN.fila_num_unmin_ends",
    "section": "",
    "text": "fila_num_unmin_ends(\n    c::MEDYAN.Context,\n    fila_idx::MEDYAN.FilaIdx\n) -&gt; Pair{Int64, Int64}\nReturn a pair (minus =&gt; plus) of the number of unminimized monomers on the minus and plus end of a filament.\nThis will be reset to (0 =&gt; 0) by minimize_energy!\nWhen an end is depolymerized this will decrease, but saturate at 0. When an end is polymerized this will increase.\nFor example if after minimization a filament has a plus end depolymerization, this function will return (0 =&gt; 0). Then if a plus end polymerization happens, this function will return (0 =&gt; 1), even though the net change in filament length is zero."
  },
  {
    "objectID": "docstrings/medyan.get_state-e99d22cacff37374.html",
    "href": "docstrings/medyan.get_state-e99d22cacff37374.html",
    "title": "MEDYAN.get_state",
    "section": "",
    "text": "get_state(c::Context, link::Link, [d::LinkData])\nReturn the state of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.get_state-e99d22cacff37374.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--any---03b671600f22589f",
    "href": "docstrings/medyan.get_state-e99d22cacff37374.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--any---03b671600f22589f",
    "title": "MEDYAN.get_state",
    "section": "",
    "text": "get_state(c::Context, link::Link, [d::LinkData])\nReturn the state of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.pick_rand_fila_tip_site-d1418d43027273e9.html",
    "href": "docstrings/medyan.pick_rand_fila_tip_site-d1418d43027273e9.html",
    "title": "MEDYAN.pick_rand_fila_tip_site",
    "section": "",
    "text": "pick_rand_fila_tip_site(c::Context, chem_voxel, fila_typeid, fesid)::Union{FilaTipIdx, Nothing}\nReturn a FilaTipIdx of a random filaendsite, or return nothing if rejected weighted by counts, using the default RNG."
  },
  {
    "objectID": "docstrings/medyan.pick_rand_fila_tip_site-d1418d43027273e9.html#tuple-medyan.context--any--any--any--3e36a14adf838425",
    "href": "docstrings/medyan.pick_rand_fila_tip_site-d1418d43027273e9.html#tuple-medyan.context--any--any--any--3e36a14adf838425",
    "title": "MEDYAN.pick_rand_fila_tip_site",
    "section": "",
    "text": "pick_rand_fila_tip_site(c::Context, chem_voxel, fila_typeid, fesid)::Union{FilaTipIdx, Nothing}\nReturn a FilaTipIdx of a random filaendsite, or return nothing if rejected weighted by counts, using the default RNG."
  },
  {
    "objectID": "docstrings/medyan.adapt_membranes--1d26092defd0f4fa.html",
    "href": "docstrings/medyan.adapt_membranes--1d26092defd0f4fa.html",
    "title": "MEDYAN.adapt_membranes!",
    "section": "",
    "text": "Remesh all membrane meshes.\nAlso remove unreferenced MembVertIdx tags."
  },
  {
    "objectID": "docstrings/medyan.adapt_membranes--1d26092defd0f4fa.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.adapt_membranes--1d26092defd0f4fa.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.adapt_membranes!",
    "section": "",
    "text": "Remesh all membrane meshes.\nAlso remove unreferenced MembVertIdx tags."
  },
  {
    "objectID": "docstrings/base.empty--418304748816268d.html",
    "href": "docstrings/base.empty--418304748816268d.html",
    "title": "Base.empty!",
    "section": "",
    "text": "Clear all index records.\n\n\n\n\n\n\n\n\n\n\n\n\nempty!(c::Context)\nRemove all filaments, membranes, links, diffusing species, fixed species, bulk species, chemboundary, and mechboundary."
  },
  {
    "objectID": "docstrings/base.empty--418304748816268d.html#tuple-medyan.stableindex--aec9c239cf42c0b9",
    "href": "docstrings/base.empty--418304748816268d.html#tuple-medyan.stableindex--aec9c239cf42c0b9",
    "title": "Base.empty!",
    "section": "",
    "text": "Clear all index records."
  },
  {
    "objectID": "docstrings/base.empty--418304748816268d.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/base.empty--418304748816268d.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "Base.empty!",
    "section": "",
    "text": "empty!(c::Context)\nRemove all filaments, membranes, links, diffusing species, fixed species, bulk species, chemboundary, and mechboundary."
  },
  {
    "objectID": "docstrings/medyan.place_exists-fcab2f7674b282f4.html",
    "href": "docstrings/medyan.place_exists-fcab2f7674b282f4.html",
    "title": "MEDYAN.place_exists",
    "section": "",
    "text": "place_exists(c::Context, p::Place)::Bool\nReturn true iff place p exists in context c. Otherwise return false."
  },
  {
    "objectID": "docstrings/medyan.place_exists-fcab2f7674b282f4.html#tuple-medyan.context--medyan.filatipidx--d592866d39d8c362",
    "href": "docstrings/medyan.place_exists-fcab2f7674b282f4.html#tuple-medyan.context--medyan.filatipidx--d592866d39d8c362",
    "title": "MEDYAN.place_exists",
    "section": "",
    "text": "place_exists(c::Context, p::Place)::Bool\nReturn true iff place p exists in context c. Otherwise return false."
  },
  {
    "objectID": "docstrings/medyan.fila_node_mids-35de9fc339cbec42.html",
    "href": "docstrings/medyan.fila_node_mids-35de9fc339cbec42.html",
    "title": "MEDYAN.fila_node_mids",
    "section": "",
    "text": "fila_node_mids(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{Int64}\nReturn the node_mids of the filament.\nThe node_mids are the monomer ids at (slightly plus side of) the node_positions\n                                 |\n                      -----+-----|-----+-----\n  minus end &lt;----       M  |  M  | (M) |  M        ----&gt; plus end\n                      -----+-----|-----+-----\n                                 |\n                                 ^ A node position is indicated by the line.\n\nThe monomer id with parenthesis (M) will in `node_mids`\nThe first monomer id is the first monomer id on the filament. The last monomer id is the last monomer id on the filament + 1"
  },
  {
    "objectID": "docstrings/medyan.fila_node_mids-35de9fc339cbec42.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "href": "docstrings/medyan.fila_node_mids-35de9fc339cbec42.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "title": "MEDYAN.fila_node_mids",
    "section": "",
    "text": "fila_node_mids(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{Int64}\nReturn the node_mids of the filament.\nThe node_mids are the monomer ids at (slightly plus side of) the node_positions\n                                 |\n                      -----+-----|-----+-----\n  minus end &lt;----       M  |  M  | (M) |  M        ----&gt; plus end\n                      -----+-----|-----+-----\n                                 |\n                                 ^ A node position is indicated by the line.\n\nThe monomer id with parenthesis (M) will in `node_mids`\nThe first monomer id is the first monomer id on the filament. The last monomer id is the last monomer id on the filament + 1"
  },
  {
    "objectID": "docstrings/medyan.get_directions-326e10fbe4341527.html",
    "href": "docstrings/medyan.get_directions-326e10fbe4341527.html",
    "title": "MEDYAN.get_directions",
    "section": "",
    "text": "get_directions(c::Context, x::Union{Tag, Place})::SVector{N, SVector{3, Float64}}\nReturn the directions of x. N is from num_directions. Throw an error if x doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.get_directions-326e10fbe4341527.html#tuple-medyan.context--medyan.tag--fedde092ce150cde",
    "href": "docstrings/medyan.get_directions-326e10fbe4341527.html#tuple-medyan.context--medyan.tag--fedde092ce150cde",
    "title": "MEDYAN.get_directions",
    "section": "",
    "text": "get_directions(c::Context, x::Union{Tag, Place})::SVector{N, SVector{3, Float64}}\nReturn the directions of x. N is from num_directions. Throw an error if x doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.fila_num_nodes-a3efee39b1440945.html",
    "href": "docstrings/medyan.fila_num_nodes-a3efee39b1440945.html",
    "title": "MEDYAN.fila_num_nodes",
    "section": "",
    "text": "fila_num_nodes(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Int64\nReturn the number of mechanical node positions of a filament."
  },
  {
    "objectID": "docstrings/medyan.fila_num_nodes-a3efee39b1440945.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "href": "docstrings/medyan.fila_num_nodes-a3efee39b1440945.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "title": "MEDYAN.fila_num_nodes",
    "section": "",
    "text": "fila_num_nodes(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Int64\nReturn the number of mechanical node positions of a filament."
  },
  {
    "objectID": "docstrings/medyan.fila_mono_ids-946d70c3169126dd.html",
    "href": "docstrings/medyan.fila_mono_ids-946d70c3169126dd.html",
    "title": "MEDYAN.fila_mono_ids",
    "section": "",
    "text": "fila_mono_ids(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; UnitRange{Int64}\nReturn a UnitRange{Int64} of monomer IDs on a filament."
  },
  {
    "objectID": "docstrings/medyan.fila_mono_ids-946d70c3169126dd.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "href": "docstrings/medyan.fila_mono_ids-946d70c3169126dd.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "title": "MEDYAN.fila_mono_ids",
    "section": "",
    "text": "fila_mono_ids(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; UnitRange{Int64}\nReturn a UnitRange{Int64} of monomer IDs on a filament."
  },
  {
    "objectID": "docstrings/medyan.tag--518214eeb95e748e.html",
    "href": "docstrings/medyan.tag--518214eeb95e748e.html",
    "title": "MEDYAN.tag!",
    "section": "",
    "text": "tag!(c::Context, p::Place)::Tag\nReturn the tag of the place. Throw an error if !place_exists(p). Create a new tag if !has_tag(p)."
  },
  {
    "objectID": "docstrings/medyan.tag--518214eeb95e748e.html#union-tuple-p---tuple-medyan.context--p---where-p--medyan.place-316eaf4f0092762b",
    "href": "docstrings/medyan.tag--518214eeb95e748e.html#union-tuple-p---tuple-medyan.context--p---where-p--medyan.place-316eaf4f0092762b",
    "title": "MEDYAN.tag!",
    "section": "",
    "text": "tag!(c::Context, p::Place)::Tag\nReturn the tag of the place. Throw an error if !place_exists(p). Create a new tag if !has_tag(p)."
  },
  {
    "objectID": "docstrings/base.delete--56ef520341df3c06.html",
    "href": "docstrings/base.delete--56ef520341df3c06.html",
    "title": "Base.delete!",
    "section": "",
    "text": "Remove a recorded index at ID."
  },
  {
    "objectID": "docstrings/base.delete--56ef520341df3c06.html#tuple-medyan.stableindex--integer--14e9a5b3c446a8fc",
    "href": "docstrings/base.delete--56ef520341df3c06.html#tuple-medyan.stableindex--integer--14e9a5b3c446a8fc",
    "title": "Base.delete!",
    "section": "",
    "text": "Remove a recorded index at ID."
  },
  {
    "objectID": "docstrings/medyan.fila_type_name-6e5acc13d811899b.html",
    "href": "docstrings/medyan.fila_type_name-6e5acc13d811899b.html",
    "title": "MEDYAN.fila_type_name",
    "section": "",
    "text": "fila_type_name(c::Context, f::Union{Tag, FilaIdx})::Symbol\nfila_type_name(c::Context; type::Union{Symbol, Integer})::Symbol\nReturn the name of the f’s type, or the name associated with type"
  },
  {
    "objectID": "docstrings/medyan.fila_type_name-6e5acc13d811899b.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.fila_type_name-6e5acc13d811899b.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.fila_type_name",
    "section": "",
    "text": "fila_type_name(c::Context, f::Union{Tag, FilaIdx})::Symbol\nfila_type_name(c::Context; type::Union{Symbol, Integer})::Symbol\nReturn the name of the f’s type, or the name associated with type"
  },
  {
    "objectID": "docstrings/medyan.is_inside_chem_boundary--1f7c8bf2ac4afb38.html",
    "href": "docstrings/medyan.is_inside_chem_boundary--1f7c8bf2ac4afb38.html",
    "title": "MEDYAN.is_inside_chem_boundary!",
    "section": "",
    "text": "is_inside_chem_boundary!(\n    c::MEDYAN.Context,\n    position::StaticArraysCore.SVector{3, Float64},\n    min_distance::Float64\n) -&gt; Bool\nConservatively check if a position is inside the chem boundary by at least min_distance nm.\nUses the cached TSDF to provide a conservative (never false-positive) estimate. Returns true only if we can guarantee the point is inside by at least min_distance. Returns false if the point might be outside or within min_distance of the boundary.\nThe algorithm uses the TSDF values at the 8 vertices of the containing voxel. For each vertex with TSDF value t_v (negative = inside), and distance r from the query point to that vertex, the boundary is between t_v + r and t_v - r away from the point.\nIf the point is outside the TSDF grid, returns false (conservative).\nThe TSDF grid spacing defaults to the chem voxel spacing / 4. The oversampling factor can be increased with set_chem_boundary_oversampling_factor!. The TSDF max distance can be increased with set_chem_boundary_tsdf_max_distance!. If min_distance &gt; max_distance - sqrt(3)*grid_spacing an error is thrown."
  },
  {
    "objectID": "docstrings/medyan.is_inside_chem_boundary--1f7c8bf2ac4afb38.html#tuple-medyan.context--staticarrayscore.svector-3--float64---float64--03ad5f15c1907d7f",
    "href": "docstrings/medyan.is_inside_chem_boundary--1f7c8bf2ac4afb38.html#tuple-medyan.context--staticarrayscore.svector-3--float64---float64--03ad5f15c1907d7f",
    "title": "MEDYAN.is_inside_chem_boundary!",
    "section": "",
    "text": "is_inside_chem_boundary!(\n    c::MEDYAN.Context,\n    position::StaticArraysCore.SVector{3, Float64},\n    min_distance::Float64\n) -&gt; Bool\nConservatively check if a position is inside the chem boundary by at least min_distance nm.\nUses the cached TSDF to provide a conservative (never false-positive) estimate. Returns true only if we can guarantee the point is inside by at least min_distance. Returns false if the point might be outside or within min_distance of the boundary.\nThe algorithm uses the TSDF values at the 8 vertices of the containing voxel. For each vertex with TSDF value t_v (negative = inside), and distance r from the query point to that vertex, the boundary is between t_v + r and t_v - r away from the point.\nIf the point is outside the TSDF grid, returns false (conservative).\nThe TSDF grid spacing defaults to the chem voxel spacing / 4. The oversampling factor can be increased with set_chem_boundary_oversampling_factor!. The TSDF max distance can be increased with set_chem_boundary_tsdf_max_distance!. If min_distance &gt; max_distance - sqrt(3)*grid_spacing an error is thrown."
  },
  {
    "objectID": "docstrings/base.getindex-f593dde852851bc8.html",
    "href": "docstrings/base.getindex-f593dde852851bc8.html",
    "title": "Base.getindex",
    "section": "",
    "text": "Get index at ID."
  },
  {
    "objectID": "docstrings/base.getindex-f593dde852851bc8.html#tuple-medyan.stableindex--integer--14e9a5b3c446a8fc",
    "href": "docstrings/base.getindex-f593dde852851bc8.html#tuple-medyan.stableindex--integer--14e9a5b3c446a8fc",
    "title": "Base.getindex",
    "section": "",
    "text": "Get index at ID."
  },
  {
    "objectID": "docstrings/medyan.add_diffusing_count--78fc5fd22c94a7fa.html",
    "href": "docstrings/medyan.add_diffusing_count--78fc5fd22c94a7fa.html",
    "title": "MEDYAN.add_diffusing_count!",
    "section": "",
    "text": "add_diffusing_count!(c::Context; species, chem_voxel, inccount)\nAdd inccount to diffusing species id sid in chem_voxel"
  },
  {
    "objectID": "docstrings/medyan.add_diffusing_count--78fc5fd22c94a7fa.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.add_diffusing_count--78fc5fd22c94a7fa.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.add_diffusing_count!",
    "section": "",
    "text": "add_diffusing_count!(c::Context; species, chem_voxel, inccount)\nAdd inccount to diffusing species id sid in chem_voxel"
  },
  {
    "objectID": "docstrings/medyan.boundary_box-060d4c56df40146a.html",
    "href": "docstrings/medyan.boundary_box-060d4c56df40146a.html",
    "title": "MEDYAN.boundary_box",
    "section": "",
    "text": "boundary_box(\n    grid::MEDYAN.CubicGrid;\n    offset,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a box boundary at the edge of a grid.\noffset(nm): How far the bounding planes should be moved in from the edge of the grid. Positive is inside the grid, negative is outside the grid.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/medyan.boundary_box-060d4c56df40146a.html#tuple-medyan.cubicgrid--0971be2da0774049",
    "href": "docstrings/medyan.boundary_box-060d4c56df40146a.html#tuple-medyan.cubicgrid--0971be2da0774049",
    "title": "MEDYAN.boundary_box",
    "section": "",
    "text": "boundary_box(\n    grid::MEDYAN.CubicGrid;\n    offset,\n    stiffness\n) -&gt; MEDYAN.Boundary\nReturn a box boundary at the edge of a grid.\noffset(nm): How far the bounding planes should be moved in from the edge of the grid. Positive is inside the grid, negative is outside the grid.\nstiffness(pN/nm): How strong the boundary is."
  },
  {
    "objectID": "docstrings/medyan.get_material_frame-33a63ae3a3b9c211.html",
    "href": "docstrings/medyan.get_material_frame-33a63ae3a3b9c211.html",
    "title": "MEDYAN.get_material_frame",
    "section": "",
    "text": "get_material_frame(c::Context, x::Union{Tag, Place})::RotMatrix3{Float64}\nReturn the material frame of x. Throw an error if x doesn’t exist.\nThe first column is the first direction. The second column is the second direction. The third column is cross(dirs[1], dirs[2]) to complete the right handed frame."
  },
  {
    "objectID": "docstrings/medyan.get_material_frame-33a63ae3a3b9c211.html#tuple-medyan.context--union-medyan.place--medyan.tag---9d0ef5f8f90063c2",
    "href": "docstrings/medyan.get_material_frame-33a63ae3a3b9c211.html#tuple-medyan.context--union-medyan.place--medyan.tag---9d0ef5f8f90063c2",
    "title": "MEDYAN.get_material_frame",
    "section": "",
    "text": "get_material_frame(c::Context, x::Union{Tag, Place})::RotMatrix3{Float64}\nReturn the material frame of x. Throw an error if x doesn’t exist.\nThe first column is the first direction. The second column is the second direction. The third column is cross(dirs[1], dirs[2]) to complete the right handed frame."
  },
  {
    "objectID": "docstrings/medyan.resolve_all_filament_mesh_crossing--a8be83a7d2ad65c7.html",
    "href": "docstrings/medyan.resolve_all_filament_mesh_crossing--a8be83a7d2ad65c7.html",
    "title": "MEDYAN.resolve_all_filament_mesh_crossing!",
    "section": "",
    "text": "Given an AABB tree corresponding to up-to-date membrane mesh triangles, resolve all filament-membrane intersections.\nRequires\n\nup-to-date unit normals of all triangles in the meshes.\nup-to-date AABB tree corresponding to all membrane meshes."
  },
  {
    "objectID": "docstrings/medyan.resolve_all_filament_mesh_crossing--a8be83a7d2ad65c7.html#tuple-medyan.context--medyan.binaryaabbtree--169a754d8e383ec5",
    "href": "docstrings/medyan.resolve_all_filament_mesh_crossing--a8be83a7d2ad65c7.html#tuple-medyan.context--medyan.binaryaabbtree--169a754d8e383ec5",
    "title": "MEDYAN.resolve_all_filament_mesh_crossing!",
    "section": "",
    "text": "Given an AABB tree corresponding to up-to-date membrane mesh triangles, resolve all filament-membrane intersections.\nRequires\n\nup-to-date unit normals of all triangles in the meshes.\nup-to-date AABB tree corresponding to all membrane meshes."
  },
  {
    "objectID": "docstrings/medyan.update_link--67d413cca6fe82eb.html",
    "href": "docstrings/medyan.update_link--67d413cca6fe82eb.html",
    "title": "MEDYAN.update_link!",
    "section": "",
    "text": "update_link!(c::Context, link::Link; kwargs...)::Nothing\nUpdate the link.\n\n\n\nplaces=(): places or tags to attach to the link.\nSet an element to nothing not change the attached place. Set an element to a null place or tag to detach that place.\nstate=(;): state properties to change.\nA NamedTuple of changes. For example, state = (;k1 = 3.6, k7 = 2.0,) to change state.k1 to 3.6 and state.k7 to 2.0.\nbond_states=(): bond state properties to change.\nA Tuple of changes. If an element in the tuple is nothing, the corresponding bond state isn’t changed. For example, bond_states = (nothing, (;L0 = 3.6,)) to change bond_states[2].L0 to 3.6.\nbond_enabled=(): bond enable flags to change.\nA Tuple of Union{Bool, Nothing}. If an element in the tuple isnothing, the corresponding bond enable flag isn't changed. For example,bond_enabled = (nothing, true, false)` to not change bond 1, enable bond 2, and disable bond 3.\nreaction_enabled=(): reaction enable flags to change.\nA Tuple of NamedTuple of changes. If an element in the tuple is nothing, the corresponding reaction enable flags aren’t changed. For example, reaction_enabled = (nothing, (;a=true, b=false)) to not change any reactions on place 1, enable reaction a on place 2, and disable reaction b on place 2.\nis_minimized::Bool=false: is the link marked as minimized.\nBy default links are marked as minimized at the end of mechanics when updated."
  },
  {
    "objectID": "docstrings/medyan.update_link--67d413cca6fe82eb.html#tuple-medyan.context--medyan.link--d37b229d2ebf6962",
    "href": "docstrings/medyan.update_link--67d413cca6fe82eb.html#tuple-medyan.context--medyan.link--d37b229d2ebf6962",
    "title": "MEDYAN.update_link!",
    "section": "",
    "text": "update_link!(c::Context, link::Link; kwargs...)::Nothing\nUpdate the link.\n\n\n\nplaces=(): places or tags to attach to the link.\nSet an element to nothing not change the attached place. Set an element to a null place or tag to detach that place.\nstate=(;): state properties to change.\nA NamedTuple of changes. For example, state = (;k1 = 3.6, k7 = 2.0,) to change state.k1 to 3.6 and state.k7 to 2.0.\nbond_states=(): bond state properties to change.\nA Tuple of changes. If an element in the tuple is nothing, the corresponding bond state isn’t changed. For example, bond_states = (nothing, (;L0 = 3.6,)) to change bond_states[2].L0 to 3.6.\nbond_enabled=(): bond enable flags to change.\nA Tuple of Union{Bool, Nothing}. If an element in the tuple isnothing, the corresponding bond enable flag isn't changed. For example,bond_enabled = (nothing, true, false)` to not change bond 1, enable bond 2, and disable bond 3.\nreaction_enabled=(): reaction enable flags to change.\nA Tuple of NamedTuple of changes. If an element in the tuple is nothing, the corresponding reaction enable flags aren’t changed. For example, reaction_enabled = (nothing, (;a=true, b=false)) to not change any reactions on place 1, enable reaction a on place 2, and disable reaction b on place 2.\nis_minimized::Bool=false: is the link marked as minimized.\nBy default links are marked as minimized at the end of mechanics when updated."
  },
  {
    "objectID": "docstrings/medyan.make_anchor--5895a6f222d457ad.html",
    "href": "docstrings/medyan.make_anchor--5895a6f222d457ad.html",
    "title": "MEDYAN.make_anchor!",
    "section": "",
    "text": "make_anchor!(c::Context, p::Anchor)::Tag{Anchor}\nReturn the new tagged anchor.\nThis represents a fixed position and frame in the simulation."
  },
  {
    "objectID": "docstrings/medyan.make_anchor--5895a6f222d457ad.html#tuple-medyan.context--medyan.anchor--d87b2d0c5fce340d",
    "href": "docstrings/medyan.make_anchor--5895a6f222d457ad.html#tuple-medyan.context--medyan.anchor--d87b2d0c5fce340d",
    "title": "MEDYAN.make_anchor!",
    "section": "",
    "text": "make_anchor!(c::Context, p::Anchor)::Tag{Anchor}\nReturn the new tagged anchor.\nThis represents a fixed position and frame in the simulation."
  },
  {
    "objectID": "docstrings/medyan.make_fila--f2346a40b4792de5.html",
    "href": "docstrings/medyan.make_fila--f2346a40b4792de5.html",
    "title": "MEDYAN.make_fila!",
    "section": "",
    "text": "make_fila!(c::Context;\n    type=1,\n    mono_states,\n    node_mids,\n    node_positions,\n)::Tag{FilaTipIdx}\nReturn the tag of the plus tip of the new filament. Error if the filament isn’t initially over 2 monomers long. Newly added filaments can’t be selected from nearby monomers until after minimization.\n\n\n\ntype=1: filament type id or symbol.\nmono_states: Collection of the MonomerState or Symbol of the monomers in the new filament. In order from minus end to plus end. length(mono_states)&gt;1\nnode_positions: Collection of SVector{3,Float64}. The positions of the nodes, monomers are between nodes.\nnode_mids: Collection of Integer. The monomer ids at (slightly plus side of) the node_positions | ––-+––-|––-+––- minus end &lt;–– M | M | (M) | M ––&gt; plus end ––-+––-|––-+––- | ^ A node_position is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids length(node_mids) == length(node_positions) - 1\nminus_end_mat_dir=nothing: SVector{3,Float64}. The mat direction of the minus end node.\njoint_twists=nothing: Collection ofFloat64`. The extra material frame axial rotation at the joints between the cylinders.\ntip_load_forces=(0.0=&gt;0.0): tip load forces, usually don’t use this, because load forces will automatically get updated at the next minimization."
  },
  {
    "objectID": "docstrings/medyan.make_fila--f2346a40b4792de5.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.make_fila--f2346a40b4792de5.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.make_fila!",
    "section": "",
    "text": "make_fila!(c::Context;\n    type=1,\n    mono_states,\n    node_mids,\n    node_positions,\n)::Tag{FilaTipIdx}\nReturn the tag of the plus tip of the new filament. Error if the filament isn’t initially over 2 monomers long. Newly added filaments can’t be selected from nearby monomers until after minimization.\n\n\n\ntype=1: filament type id or symbol.\nmono_states: Collection of the MonomerState or Symbol of the monomers in the new filament. In order from minus end to plus end. length(mono_states)&gt;1\nnode_positions: Collection of SVector{3,Float64}. The positions of the nodes, monomers are between nodes.\nnode_mids: Collection of Integer. The monomer ids at (slightly plus side of) the node_positions | ––-+––-|––-+––- minus end &lt;–– M | M | (M) | M ––&gt; plus end ––-+––-|––-+––- | ^ A node_position is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids length(node_mids) == length(node_positions) - 1\nminus_end_mat_dir=nothing: SVector{3,Float64}. The mat direction of the minus end node.\njoint_twists=nothing: Collection ofFloat64`. The extra material frame axial rotation at the joints between the cylinders.\ntip_load_forces=(0.0=&gt;0.0): tip load forces, usually don’t use this, because load forces will automatically get updated at the next minimization."
  },
  {
    "objectID": "docstrings/medyan.make_ball--ae25720dbd2acec6.html",
    "href": "docstrings/medyan.make_ball--ae25720dbd2acec6.html",
    "title": "MEDYAN.make_ball!",
    "section": "",
    "text": "make_ball!(c::Context; position, radius, stiffness=1.0f0, state=SA[0,0,0], is_minimized=false) -&gt; Tag{BallIdx}\nCreate a new ball in c and return a tag for it.\n\n\n\nposition::SVector{3, Float64}: 3D position of the ball center (nm)\nradius::Float32: Radius of the ball (nm)\nstiffness::Float32=1.0: Mechanical stiffness coefficient (pN/nm)\nstate::SVector{3, Int64}=SA[0,0,0]: Three-component state vector for chemical reactions\nis_minimized::Bool=false: Whether the ball is marked as minimized. By default balls are not minimized when created. Set to true to create a ball that is already marked as minimized.\n\nSee also: remove_ball!, update_ball!, get_position, is_minimized"
  },
  {
    "objectID": "docstrings/medyan.make_ball--ae25720dbd2acec6.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.make_ball--ae25720dbd2acec6.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.make_ball!",
    "section": "",
    "text": "make_ball!(c::Context; position, radius, stiffness=1.0f0, state=SA[0,0,0], is_minimized=false) -&gt; Tag{BallIdx}\nCreate a new ball in c and return a tag for it.\n\n\n\nposition::SVector{3, Float64}: 3D position of the ball center (nm)\nradius::Float32: Radius of the ball (nm)\nstiffness::Float32=1.0: Mechanical stiffness coefficient (pN/nm)\nstate::SVector{3, Int64}=SA[0,0,0]: Three-component state vector for chemical reactions\nis_minimized::Bool=false: Whether the ball is marked as minimized. By default balls are not minimized when created. Set to true to create a ball that is already marked as minimized.\n\nSee also: remove_ball!, update_ball!, get_position, is_minimized"
  },
  {
    "objectID": "docstrings/medyan.def_diffusing_species--e07d4f4fa5062c57.html",
    "href": "docstrings/medyan.def_diffusing_species--e07d4f4fa5062c57.html",
    "title": "MEDYAN.def_diffusing_species!",
    "section": "",
    "text": "def_diffusing_species!(s::SysDef, name::Symbol; coeff::Float64)\nDynamically add a new diffusing species to the system definition.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new diffusing species.\ncoeff::Float64: The diffusion coefficient in units of (nm²/s).\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if a diffusing species with the given name already exists."
  },
  {
    "objectID": "docstrings/medyan.def_diffusing_species--e07d4f4fa5062c57.html#tuple-medyan.sysdef--symbol--772937de98b04e8b",
    "href": "docstrings/medyan.def_diffusing_species--e07d4f4fa5062c57.html#tuple-medyan.sysdef--symbol--772937de98b04e8b",
    "title": "MEDYAN.def_diffusing_species!",
    "section": "",
    "text": "def_diffusing_species!(s::SysDef, name::Symbol; coeff::Float64)\nDynamically add a new diffusing species to the system definition.\n\n\n\ns::SysDef: The system definition to modify.\nname::Symbol: The name of the new diffusing species.\ncoeff::Float64: The diffusion coefficient in units of (nm²/s).\n\n\n\n\nThe modified SysDef.\n\n\n\n\nError if a diffusing species with the given name already exists."
  },
  {
    "objectID": "docstrings/medyan.set_mechboundary--b5e26b6b690256aa.html",
    "href": "docstrings/medyan.set_mechboundary--b5e26b6b690256aa.html",
    "title": "MEDYAN.set_mechboundary!",
    "section": "",
    "text": "set_mechboundary!(\n    c::MEDYAN.Context;\n    kwargs...\n) -&gt; MEDYAN.Boundary\nSee also Boundary"
  },
  {
    "objectID": "docstrings/medyan.set_mechboundary--b5e26b6b690256aa.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.set_mechboundary--b5e26b6b690256aa.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.set_mechboundary!",
    "section": "",
    "text": "set_mechboundary!(\n    c::MEDYAN.Context;\n    kwargs...\n) -&gt; MEDYAN.Boundary\nSee also Boundary"
  },
  {
    "objectID": "docstrings/medyan.get_chem_state-a69539a7b114572a.html",
    "href": "docstrings/medyan.get_chem_state-a69539a7b114572a.html",
    "title": "MEDYAN.get_chem_state",
    "section": "",
    "text": "get_chem_state(c::Context, x::Union{Tag, Place})\nReturn the chemical state of x. Each type of place has a different type of chemical state. If the chemical state of a place changes, any attached links will have their reaction rates recalculated. Throw an error if x doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.get_chem_state-a69539a7b114572a.html#tuple-medyan.context--medyan.tag--fedde092ce150cde",
    "href": "docstrings/medyan.get_chem_state-a69539a7b114572a.html#tuple-medyan.context--medyan.tag--fedde092ce150cde",
    "title": "MEDYAN.get_chem_state",
    "section": "",
    "text": "get_chem_state(c::Context, x::Union{Tag, Place})\nReturn the chemical state of x. Each type of place has a different type of chemical state. If the chemical state of a place changes, any attached links will have their reaction rates recalculated. Throw an error if x doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.get_all_links-fe0d12c0df825f7e.html",
    "href": "docstrings/medyan.get_all_links-fe0d12c0df825f7e.html",
    "title": "MEDYAN.get_all_links",
    "section": "",
    "text": "get_all_links(c::Context; type::Union{Symbol,Integer}) -&gt; Link iterator\nReturn an iterator of all Links of type type."
  },
  {
    "objectID": "docstrings/medyan.get_all_links-fe0d12c0df825f7e.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.get_all_links-fe0d12c0df825f7e.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.get_all_links",
    "section": "",
    "text": "get_all_links(c::Context; type::Union{Symbol,Integer}) -&gt; Link iterator\nReturn an iterator of all Links of type type."
  },
  {
    "objectID": "docstrings/medyan.is_minimized-ff3858ada5447c46.html",
    "href": "docstrings/medyan.is_minimized-ff3858ada5447c46.html",
    "title": "MEDYAN.is_minimized",
    "section": "",
    "text": "is_minimized(c::Context, link::Link, [d::LinkData])::Bool\nReturn the is_minimized flag of the link. Throw an error if link doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\nis_minimized(c::Context, ball::Union{BallIdx, Tag{BallIdx}})::Bool\nReturn true if the ball has been minimized (i.e. its position has been updated by minimize_energy! since it was last created or modified).\nBalls are marked as not minimized when created with make_ball! or when their position or radius is changed via update_ball!. All balls are marked as minimized at the end of minimize_energy!.\nSee also: make_ball!, update_ball!, minimize_energy!\n\n\n\n\n\n\n\n\n\n\n\n\nis_minimized(c::Context, p::Union{FilaMonoIdx, FilaTipIdx, Tag})::Bool\nReturn true iff the monomer or tip has been minimized. Throw an error if p doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.is_minimized-ff3858ada5447c46.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--any---03b671600f22589f",
    "href": "docstrings/medyan.is_minimized-ff3858ada5447c46.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--any---03b671600f22589f",
    "title": "MEDYAN.is_minimized",
    "section": "",
    "text": "is_minimized(c::Context, link::Link, [d::LinkData])::Bool\nReturn the is_minimized flag of the link. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.is_minimized-ff3858ada5447c46.html#tuple-medyan.context--medyan.ballidx--277715bc057ae4e8",
    "href": "docstrings/medyan.is_minimized-ff3858ada5447c46.html#tuple-medyan.context--medyan.ballidx--277715bc057ae4e8",
    "title": "MEDYAN.is_minimized",
    "section": "",
    "text": "is_minimized(c::Context, ball::Union{BallIdx, Tag{BallIdx}})::Bool\nReturn true if the ball has been minimized (i.e. its position has been updated by minimize_energy! since it was last created or modified).\nBalls are marked as not minimized when created with make_ball! or when their position or radius is changed via update_ball!. All balls are marked as minimized at the end of minimize_energy!.\nSee also: make_ball!, update_ball!, minimize_energy!"
  },
  {
    "objectID": "docstrings/medyan.is_minimized-ff3858ada5447c46.html#tuple-medyan.context--medyan.filamonoidx--be3f97f8041f5bf1",
    "href": "docstrings/medyan.is_minimized-ff3858ada5447c46.html#tuple-medyan.context--medyan.filamonoidx--be3f97f8041f5bf1",
    "title": "MEDYAN.is_minimized",
    "section": "",
    "text": "is_minimized(c::Context, p::Union{FilaMonoIdx, FilaTipIdx, Tag})::Bool\nReturn true iff the monomer or tip has been minimized. Throw an error if p doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.place2links-0b74317627f4b920.html",
    "href": "docstrings/medyan.place2links-0b74317627f4b920.html",
    "title": "MEDYAN.place2links",
    "section": "",
    "text": "place2links(c::Context, p::Place) -&gt; Link iterator\nReturn an iterator of Links attached to p. If !place_exists(c, p) return an empty iterator."
  },
  {
    "objectID": "docstrings/medyan.place2links-0b74317627f4b920.html#tuple-medyan.context--medyan.place--5f4876ae276f10cb",
    "href": "docstrings/medyan.place2links-0b74317627f4b920.html#tuple-medyan.context--medyan.place--5f4876ae276f10cb",
    "title": "MEDYAN.place2links",
    "section": "",
    "text": "place2links(c::Context, p::Place) -&gt; Link iterator\nReturn an iterator of Links attached to p. If !place_exists(c, p) return an empty iterator."
  },
  {
    "objectID": "docstrings/medyan.minimize_energy--84c4aeab5457d3ee.html",
    "href": "docstrings/medyan.minimize_energy--84c4aeab5457d3ee.html",
    "title": "MEDYAN.minimize_energy!",
    "section": "",
    "text": "minimize_energy!(c::Context)::MinimizeEnergyResults\nMinimize mechanical energy of the context.\n\n\n\ncheck_closest::Bool=true:\n\nIf true, the function will warn if two objects get too close during minimization.\n\nbrownian_motion_time::Float64=Inf: This parameter is used to simulate the effect\n\nof Brownian motion over a certain period of time in seconds. It is currently experimental. By default, the effect of Brownian motion is ignored.\n\ng_tol::Float64=c.g_tol: The acceptable maximum residual force on any degree of freedom in pN.\niter_max::Int=c.iter_max_cg_minimization: The maximum number of congugate gradient iterations to do before exiting."
  },
  {
    "objectID": "docstrings/medyan.minimize_energy--84c4aeab5457d3ee.html#tuple-medyan.context--4896731d1a77eb1c",
    "href": "docstrings/medyan.minimize_energy--84c4aeab5457d3ee.html#tuple-medyan.context--4896731d1a77eb1c",
    "title": "MEDYAN.minimize_energy!",
    "section": "",
    "text": "minimize_energy!(c::Context)::MinimizeEnergyResults\nMinimize mechanical energy of the context.\n\n\n\ncheck_closest::Bool=true:\n\nIf true, the function will warn if two objects get too close during minimization.\n\nbrownian_motion_time::Float64=Inf: This parameter is used to simulate the effect\n\nof Brownian motion over a certain period of time in seconds. It is currently experimental. By default, the effect of Brownian motion is ignored.\n\ng_tol::Float64=c.g_tol: The acceptable maximum residual force on any degree of freedom in pN.\niter_max::Int=c.iter_max_cg_minimization: The maximum number of congugate gradient iterations to do before exiting."
  },
  {
    "objectID": "docstrings/medyan.filatipidx-460debd2fef11ad4.html",
    "href": "docstrings/medyan.filatipidx-460debd2fef11ad4.html",
    "title": "MEDYAN.FilaTipIdx",
    "section": "",
    "text": "FilaTipIdx &lt;: Place\nAn index identifying a specific filament tip (either the minus end or plus end).\nThis index may be invalidated by mutations (e.g., filament removal or severing). Use a Tag{FilaTipIdx} for a long-term reference that remains valid across mutations.\n\n\n\nFilaTipIdx(): Creates a null tip index\nFilaTipIdx(fila_idx::FilaIdx, is_minus_end::Bool): Creates a tip index for the specified filament and end\nFilaTipIdx(c::Context, x, ::typeof(-)): Get the minus-end tip\nFilaTipIdx(c::Context, x, ::typeof(+)): Get the plus-end tip\nFilaTipIdx(c::Context, f::FilaTipIdx): Re-resolve a tip index\nFilaTipIdx(c::Context, t::Tag{FilaTipIdx}): Construct from a tag\nFilaTipIdx(c::Context, x::Union{FilaIdx, FilaMonoIdx, FilaTipIdx, Tag}, is_minus_end::Bool): Construct from various filament references\n\n\n\n\n\nfila_idx::FilaIdx: The filament this tip belongs to\nis_minus_end::Bool: true for minus end, false for plus end\n\n\n\n\nSee fila_tip_tags, make_fila!."
  },
  {
    "objectID": "docstrings/medyan.filatipidx-460debd2fef11ad4.html#union---b2cfd89fb0d1b9c6",
    "href": "docstrings/medyan.filatipidx-460debd2fef11ad4.html#union---b2cfd89fb0d1b9c6",
    "title": "MEDYAN.FilaTipIdx",
    "section": "",
    "text": "FilaTipIdx &lt;: Place\nAn index identifying a specific filament tip (either the minus end or plus end).\nThis index may be invalidated by mutations (e.g., filament removal or severing). Use a Tag{FilaTipIdx} for a long-term reference that remains valid across mutations.\n\n\n\nFilaTipIdx(): Creates a null tip index\nFilaTipIdx(fila_idx::FilaIdx, is_minus_end::Bool): Creates a tip index for the specified filament and end\nFilaTipIdx(c::Context, x, ::typeof(-)): Get the minus-end tip\nFilaTipIdx(c::Context, x, ::typeof(+)): Get the plus-end tip\nFilaTipIdx(c::Context, f::FilaTipIdx): Re-resolve a tip index\nFilaTipIdx(c::Context, t::Tag{FilaTipIdx}): Construct from a tag\nFilaTipIdx(c::Context, x::Union{FilaIdx, FilaMonoIdx, FilaTipIdx, Tag}, is_minus_end::Bool): Construct from various filament references\n\n\n\n\n\nfila_idx::FilaIdx: The filament this tip belongs to\nis_minus_end::Bool: true for minus end, false for plus end\n\n\n\n\nSee fila_tip_tags, make_fila!."
  },
  {
    "objectID": "docstrings/medyan.def_reaction--60ae13f69a537c68.html",
    "href": "docstrings/medyan.def_reaction--60ae13f69a537c68.html",
    "title": "MEDYAN.def_reaction!",
    "section": "",
    "text": "def_reaction!(s::SysDef, reaction_expr::AbstractString; base_rate, invvolumepower=0, affect!=nothing)\nAdd a chem_voxel reaction to the system definition. Returns s.\nreaction_expr is a string describing the reaction. The format depends on whether affect! is provided:\n\nWithout affect!: reaction_expr must contain \"--&gt;\" to separate reactants from products. Stoichiometry is computed automatically.\nWith affect!: reaction_expr lists only the reactants (no \"--&gt;\"). Net stoichiometry is zero; the callback handles all state changes.\n\nreaction_expr is comprised of reactant and product parts separated by \"--&gt;\". All whitespace is ignored. Each side is split by \"+\" to get species names. Repeated or extra \"+\" are ignored. A species name can be prepended by a positive integer to represent multiple copies (e.g., \"2diffusing.A\").\nSpecies name prefixes:\n\ndiffusing.X — diffusing species\nfixedspecies.X — fixed (non-diffusing) species\nfilamentsite.T.N — filament monomer site\nfilamentendsite.T.N — filament end site\ndecimated_2mon_site.N — decimated two-monomer site\n\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s. Rate constants are stochastic rate constants in the sense of Gillespie (1976).\ninvvolumepower::Int = 0: volumefactor = (1/volume)^invvolumepower where volume is the chem_voxel volume in nm³. Typically 0 for unimolecular, 1 for bimolecular, 2 for trimolecular.\n\n\n\n\n\naffect!: Callback fired when the reaction occurs. Signature: (c::Context; chem_voxel::Int, kwargs...) -&gt; Any. When provided, reaction_expr must not contain \"--&gt;\".\n\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_diffusing_species!(s, :A; coeff=2.5e7)\ndef_diffusing_species!(s, :B; coeff=2.5e7)\ndef_diffusing_species!(s, :C; coeff=2.5e7)\n\n# Bimolecular: A + B → C\ndef_reaction!(s, \"diffusing.A + diffusing.B --&gt; diffusing.C\";\n    base_rate = 1.5e6,\n    invvolumepower = 1,\n)\n\n# Unimolecular: C → A + B\ndef_reaction!(s, \"diffusing.C --&gt; diffusing.A + diffusing.B\";\n    base_rate = 1.75,\n)\n\n# Zero-order creation\ndef_reaction!(s, \" --&gt; diffusing.A + diffusing.B\";\n    base_rate = 1.75,\n)\n\n# With a callback (reactants only, no \"--&gt;\")\ndef_reaction!(s, \"diffusing.A + diffusing.B\";\n    base_rate = 1e8,\n    invvolumepower = 1,\n    affect! = (c; chem_voxel, kwargs...) -&gt; begin\n        # custom logic here\n        nothing\n    end,\n)"
  },
  {
    "objectID": "docstrings/medyan.def_reaction--60ae13f69a537c68.html#tuple-medyan.sysdef--abstractstring--33fb2da203ce5d75",
    "href": "docstrings/medyan.def_reaction--60ae13f69a537c68.html#tuple-medyan.sysdef--abstractstring--33fb2da203ce5d75",
    "title": "MEDYAN.def_reaction!",
    "section": "",
    "text": "def_reaction!(s::SysDef, reaction_expr::AbstractString; base_rate, invvolumepower=0, affect!=nothing)\nAdd a chem_voxel reaction to the system definition. Returns s.\nreaction_expr is a string describing the reaction. The format depends on whether affect! is provided:\n\nWithout affect!: reaction_expr must contain \"--&gt;\" to separate reactants from products. Stoichiometry is computed automatically.\nWith affect!: reaction_expr lists only the reactants (no \"--&gt;\"). Net stoichiometry is zero; the callback handles all state changes.\n\nreaction_expr is comprised of reactant and product parts separated by \"--&gt;\". All whitespace is ignored. Each side is split by \"+\" to get species names. Repeated or extra \"+\" are ignored. A species name can be prepended by a positive integer to represent multiple copies (e.g., \"2diffusing.A\").\nSpecies name prefixes:\n\ndiffusing.X — diffusing species\nfixedspecies.X — fixed (non-diffusing) species\nfilamentsite.T.N — filament monomer site\nfilamentendsite.T.N — filament end site\ndecimated_2mon_site.N — decimated two-monomer site\n\n\n\n\n\n\nbase_rate::Float64: Rate constant. Units: (nm³)^invvolumepower / s. Rate constants are stochastic rate constants in the sense of Gillespie (1976).\ninvvolumepower::Int = 0: volumefactor = (1/volume)^invvolumepower where volume is the chem_voxel volume in nm³. Typically 0 for unimolecular, 1 for bimolecular, 2 for trimolecular.\n\n\n\n\n\naffect!: Callback fired when the reaction occurs. Signature: (c::Context; chem_voxel::Int, kwargs...) -&gt; Any. When provided, reaction_expr must not contain \"--&gt;\".\n\n\n\n\n\nusing MEDYAN\ns = MEDYAN.SysDef()\ndef_diffusing_species!(s, :A; coeff=2.5e7)\ndef_diffusing_species!(s, :B; coeff=2.5e7)\ndef_diffusing_species!(s, :C; coeff=2.5e7)\n\n# Bimolecular: A + B → C\ndef_reaction!(s, \"diffusing.A + diffusing.B --&gt; diffusing.C\";\n    base_rate = 1.5e6,\n    invvolumepower = 1,\n)\n\n# Unimolecular: C → A + B\ndef_reaction!(s, \"diffusing.C --&gt; diffusing.A + diffusing.B\";\n    base_rate = 1.75,\n)\n\n# Zero-order creation\ndef_reaction!(s, \" --&gt; diffusing.A + diffusing.B\";\n    base_rate = 1.75,\n)\n\n# With a callback (reactants only, no \"--&gt;\")\ndef_reaction!(s, \"diffusing.A + diffusing.B\";\n    base_rate = 1e8,\n    invvolumepower = 1,\n    affect! = (c; chem_voxel, kwargs...) -&gt; begin\n        # custom logic here\n        nothing\n    end,\n)"
  },
  {
    "objectID": "docstrings/medyan.link2tags-645330bedbf54254.html",
    "href": "docstrings/medyan.link2tags-645330bedbf54254.html",
    "title": "MEDYAN.link2tags",
    "section": "",
    "text": "link2tags(c::Context, link::Link, [d::LinkData]) -&gt; Tag tuple\nReturn a tuple of tags of places that link is attached to. If one of the places of link is not attached that tag will be null. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.link2tags-645330bedbf54254.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--medyan.linkdata---c8d94eda9cfd0bb4",
    "href": "docstrings/medyan.link2tags-645330bedbf54254.html#union-tuple-medyan.context--medyan.link---tuple-medyan.context--medyan.link--medyan.linkdata---c8d94eda9cfd0bb4",
    "title": "MEDYAN.link2tags",
    "section": "",
    "text": "link2tags(c::Context, link::Link, [d::LinkData]) -&gt; Tag tuple\nReturn a tuple of tags of places that link is attached to. If one of the places of link is not attached that tag will be null. Throw an error if link doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.fila_mono_states-bf83d6c80fc4d691.html",
    "href": "docstrings/medyan.fila_mono_states-bf83d6c80fc4d691.html",
    "title": "MEDYAN.fila_mono_states",
    "section": "",
    "text": "fila_mono_states(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{UInt8}\nReturn a read only Vector of monomer states on a filament.\nThis can be invalid after any mutations to context, so copy if needed."
  },
  {
    "objectID": "docstrings/medyan.fila_mono_states-bf83d6c80fc4d691.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "href": "docstrings/medyan.fila_mono_states-bf83d6c80fc4d691.html#tuple-medyan.context--medyan.filaidx--5b8fb92ab95a2b00",
    "title": "MEDYAN.fila_mono_states",
    "section": "",
    "text": "fila_mono_states(\n    c::MEDYAN.Context,\n    f::MEDYAN.FilaIdx\n) -&gt; Vector{UInt8}\nReturn a read only Vector of monomer states on a filament.\nThis can be invalid after any mutations to context, so copy if needed."
  },
  {
    "objectID": "docstrings/medyan.sever_fila--161c869bc5d06d6a.html",
    "href": "docstrings/medyan.sever_fila--161c869bc5d06d6a.html",
    "title": "MEDYAN.sever_fila!",
    "section": "",
    "text": "sever_fila!(c::Context, place::FilaMonoIdx)::Tag{FilaTipIdx}\nReturn the tag of the new filament plus end.\nThe split will happen between place and the monomer slightly towards the minus end.\nThe split cannot create a filament with less than 2 monomers."
  },
  {
    "objectID": "docstrings/medyan.sever_fila--161c869bc5d06d6a.html#tuple-medyan.context--medyan.filamonoidx--be3f97f8041f5bf1",
    "href": "docstrings/medyan.sever_fila--161c869bc5d06d6a.html#tuple-medyan.context--medyan.filamonoidx--be3f97f8041f5bf1",
    "title": "MEDYAN.sever_fila!",
    "section": "",
    "text": "sever_fila!(c::Context, place::FilaMonoIdx)::Tag{FilaTipIdx}\nReturn the tag of the new filament plus end.\nThe split will happen between place and the monomer slightly towards the minus end.\nThe split cannot create a filament with less than 2 monomers."
  },
  {
    "objectID": "docstrings/medyan.tag2links-e8376daf0b29e2fd.html",
    "href": "docstrings/medyan.tag2links-e8376daf0b29e2fd.html",
    "title": "MEDYAN.tag2links",
    "section": "",
    "text": "tag2links(c::Context, t::Tag) -&gt; Link iterator\nReturn an iterator of Links attached to t. If !tag_exists(c, t) return an empty iterator."
  },
  {
    "objectID": "docstrings/medyan.tag2links-e8376daf0b29e2fd.html#union-tuple-p---tuple-medyan.context--medyan.tag-p----where-p-f3255fd0d268d21a",
    "href": "docstrings/medyan.tag2links-e8376daf0b29e2fd.html#union-tuple-p---tuple-medyan.context--medyan.tag-p----where-p-f3255fd0d268d21a",
    "title": "MEDYAN.tag2links",
    "section": "",
    "text": "tag2links(c::Context, t::Tag) -&gt; Link iterator\nReturn an iterator of Links attached to t. If !tag_exists(c, t) return an empty iterator."
  }
]