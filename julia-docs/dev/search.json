[
  {
    "objectID": "docstrings/fe4b7cc2dceb0431.html",
    "href": "docstrings/fe4b7cc2dceb0431.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "n::StaticArraysCore.SVector{3, Int64}\ncompartmentsize::Float64"
  },
  {
    "objectID": "docstrings/0cd5353e58a90ec2.html",
    "href": "docstrings/0cd5353e58a90ec2.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "There is one instance of this per cadherin.\n\nchemstate::NamedTuple\n\n: Other state.\n\nmechstate::NamedTuple\n\n: Used in linker force calculation.\n\nis_minimized::Bool\n\n: Set to true after minimization"
  },
  {
    "objectID": "docstrings/b1d3d66a81296343.html",
    "href": "docstrings/b1d3d66a81296343.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "fil_node_mon_ids(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> Vector{Int64}\nReturn the node monomer ids of the filament.\nThe fil_node_mon_ids are the monomer ids at (slightly plus side of) the fil_node_positions\n                                 |\n                      -----+-----|-----+-----\n  minus end <----       M  |  M  | (M) |  M        ----> plus end\n                      -----+-----|-----+-----\n                                 |\n                                 ^ A node position is indicated by the line.\n\nThe monomer id with parenthesis (M) will in `fil_node_mon_ids`\nThe first monomer id is the first monomer id on the filament. The last monomer id is the last monomer id on the filament + 1"
  },
  {
    "objectID": "docstrings/83ec3db37b4e2130.html",
    "href": "docstrings/83ec3db37b4e2130.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add filament end reaction. Return s. Add a filamentendsite and reaction with callback to change the filaments. This can be used for polymerization, depolymeriation, and changing end state.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentendsitename::Symbol: the new name of the filamentendsite added. This can be used as a catalyst in other reactions.\nisminusend::Bool: true if changing the minus end, false if changing the plus end.\nchangedendstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the end monomer states, the first is the states to match. The second is the new monomer states after the reaction. If the second has more states than the first, new monomers will be added, if the second has less, monomers will be removed. Ordered minus end first.\nspacing::Float64: Space needed at the filament end for this reaction. (nm) ratefactor= exp(-β*spacing*loadforce) where β is 1/kT, loadforce is the external force pushing axially on the end of the filament. and ratefactor affects this reaction propensity and any others using filamentendsitename\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentendsite.$(filamenttypename).$(filamentendsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentendsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nstatedef = StateDef(\n    diffusingspeciesnames= [:a,],\n    filamentnames= [(:filname,[\n                            :plus,\n                            :mid,\n                            :minus,\n                        ]),\n    ],\n)\ns= SysDef(statedef)\nmonomerspacing= 2.7\n#minus end polymerization\naddfilamentend_reaction!(s, :filname, :pm, true,\n    [:minus]=>[:minus,:mid], monomerspacing,\n    \"diffusing.a -->\", 10E3, 1,\n)\n#plus end depolymerization\naddfilamentend_reaction!(s, :filname, :dpp, false,\n    [:mid,:plus]=>[:plus], 0.0,\n    \"--> diffusing.a\", 1.75E-3, 0,\n)"
  },
  {
    "objectID": "docstrings/e34a7f650637c5cf.html",
    "href": "docstrings/e34a7f650637c5cf.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Returns 1.0 if the monomer states match, otherwise, returns 0.0.\n\nminusstate::Tuple{UInt8, UInt8, UInt8}\n\n: minus end monomer state\n\nplusstate::Tuple{UInt8, UInt8, UInt8}\n\n: plus end monomer state"
  },
  {
    "objectID": "docstrings/c7e61a0098220c5d.html",
    "href": "docstrings/c7e61a0098220c5d.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_removelinker!(c::Context, ltid, endnames::Pair{MonomerName,MonomerName})\nRemove a linker of type id ltid between monemers endnames.\nError if there is no linker there.\nDon’t modify monomer states."
  },
  {
    "objectID": "docstrings/dda22fac5c555b9e.html",
    "href": "docstrings/dda22fac5c555b9e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "run_chemistry!(c::Context, Δt)\nRun chemistry for Δt time.\nUpdate c.time."
  },
  {
    "objectID": "docstrings/b78927c847f31f1c.html",
    "href": "docstrings/b78927c847f31f1c.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Always returns 1.0"
  },
  {
    "objectID": "docstrings/1d26092defd0f4fa.html",
    "href": "docstrings/1d26092defd0f4fa.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Remesh all membrane meshes."
  },
  {
    "objectID": "docstrings/2d87a6a86cabc4f5.html",
    "href": "docstrings/2d87a6a86cabc4f5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "membraneindex::Int64\n\n: membrane index\n\nvid::Int64\n\n: vertex id"
  },
  {
    "objectID": "docstrings/95612d72d1fda05f.html",
    "href": "docstrings/95612d72d1fda05f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addfilamentendsite!(s::SysDef,filamenttypename::Symbol,filamentendsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/a3cfa3bff223743d.html",
    "href": "docstrings/a3cfa3bff223743d.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Returns linkerstate.chemstate.sitecount"
  },
  {
    "objectID": "docstrings/892875b2c079002d.html",
    "href": "docstrings/892875b2c079002d.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addmembranesite!(\n    s::MEDYAN.SysDef,\n    membranesitename::Symbol,\n    site\n) -> MEDYAN.SysDef\nAdd a new site with a specified name. During this process, a new fixed species is created suffixed with “membranesite.”."
  },
  {
    "objectID": "docstrings/618a66637eb50781.html",
    "href": "docstrings/618a66637eb50781.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "fil_node_positions(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> Vector{StaticArraysCore.SVector{3, Float64}}\nReturn the node positions of the filament"
  },
  {
    "objectID": "docstrings/754f6bce456bc62b.html",
    "href": "docstrings/754f6bce456bc62b.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "There is one instance of this per linker.\n\nchemstate::NamedTuple\n\n: Other state.\n\nmechstate::NamedTuple\n\n: Used in linker force calculation.\n\nis_minimized::Bool\n\n: Set to true after minimization"
  },
  {
    "objectID": "docstrings/bb517706cb60c4f5.html",
    "href": "docstrings/bb517706cb60c4f5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "ftid::Int64\n\n: filament type id\n\nfid::Int64\n\n: filament id\n\nmid::Int64\n\n: monomer id"
  },
  {
    "objectID": "docstrings/83983d8916347411.html",
    "href": "docstrings/83983d8916347411.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_position(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> StaticArraysCore.SVector{3, Float64}\nReturn the monomer position."
  },
  {
    "objectID": "docstrings/ae8586daa0b5454a.html",
    "href": "docstrings/ae8586daa0b5454a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addpossiblecadherinsite!(s::SysDef,possiblecadherinsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/7ea31a421de7d258.html",
    "href": "docstrings/7ea31a421de7d258.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Total number of IDs in use.\n\n\n\n\n\n\n\n\n\n\n\n\nTotal number of compartments in the grid"
  },
  {
    "objectID": "docstrings/src/minimize_energy.html",
    "href": "docstrings/src/minimize_energy.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Force (re-)evaluation of the objective value at x. Returns f(x) and stores the value in obj.F also calculates the gradient and stores it in obj.DF\n\n\n\n\n\n\n\n\n\n\n\n\nminimize_energy!(c::Context)\nMinimize mechanical energy of the context."
  },
  {
    "objectID": "docstrings/src/trajectory-io/snapshot.html",
    "href": "docstrings/src/trajectory-io/snapshot.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "load_snapshot!(c::Context,group::Union{HDF5.File, HDF5.Group})\nEmpty the context and load the state saved in the snapshot group.\nc should be constructed with the same SysDef and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nSee Snapshot group for more details."
  },
  {
    "objectID": "docstrings/src/linkersites.html",
    "href": "docstrings/src/linkersites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Always returns 1.0\n\n\n\n\n\n\n\n\n\n\n\n\nReturns linkerstate.chemstate.sitecount\n\n\n\n\n\n\n\n\n\n\n\n\nReturns 1.0 if the monomer states match, otherwise, returns 0.0.\n\nminusstate::Tuple{UInt8, UInt8, UInt8}\n\n: minus end monomer state\n\nplusstate::Tuple{UInt8, UInt8, UInt8}\n\n: plus end monomer state\n\n\n\n\n\n\n\n\n\n\n\n\nModels unbinding rates based on the following exponential form of Bell et al, 1978: k0*exp(f/f0) Where f is the magnitude of the force. So as to exponetially increase the unbinding with more force.\nlinkersitecount returns the unbinding rate in units of 1/s It returns k0 if the linker hasn’t been minimized yet.\n\nf0::Float64\n\n: The charicteristic force magnitude. Units of pN\n\nk0::Float64\n\n: Unbinding rate at zero force. Units of 1/s\n\n\n\n\n\n\n\n\n\n\n\n\nThe catch-bond nature of myosin unbinding with multiple heads. Adopted from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the force increases, the motor unbinding rate decreases to a minimum of k0/10\nlinkersitecount returns the unbinding rate in units of 1/s It returns k0 if the linker hasn’t been minimized yet. It assumes linkerstate.chemstate.numHeads exists for the linker.\n\nf0::Float64\n\n: single head characteristic unbinding force, units of pN/head\n\nonRate::Float64\n\n: single head binding rate, units of 1/s\n\noffRate::Float64\n\n: single head unbinding rate, units of 1/s\n\nβ::Float64\n\n: slope of head binding, units of (head)/(pN/head)\n\n\n\n\n\n\n\n\n\n\n\n\nModels myosin walking rates from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the motor work per step increases, its walking rate goes to zero.\nReturns the walking rate of one end. The callback can then sample which end to move, or reject the move.\n\nfs::Float64\n\n: The stall force magnitude. Units of pN\n\nk0::Float64\n\n: Walking rate of one end at zero force. Units of 1/s\n\nα::Float64\n\n: Positive dimensionless parameter defining the steepness of the curve, smaller is more steep, if α is inf, the curve is linear\n\nwalking_direction::Int32\n\n: Motor walking direction, +1 is towards plus end, -1 is towards minus end\n\nisminusend::Bool\n\n: which motor end does this represent"
  },
  {
    "objectID": "docstrings/src/filamentsites.html",
    "href": "docstrings/src/filamentsites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "General filament site just matches monomer states\n\ncenter::Int64\n\n: index of center monomer in states\n\nstates::Vector{UInt8}\n\n: monomer states to match"
  },
  {
    "objectID": "docstrings/src/grids.html",
    "href": "docstrings/src/grids.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "n::StaticArraysCore.SVector{3, Int64}\ncompartmentsize::Float64\n\n\n\n\n\n\n\n\n\n\n\n\n\nTotal number of compartments in the grid"
  },
  {
    "objectID": "docstrings/src/membrane/membranesites.html",
    "href": "docstrings/src/membrane/membranesites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Allows up to 1 membrane diffusing species as reactants. Also stores net stoich of membrane diffusing species.\n\nid_membranediffusing_reactant::Int64\n\n: Set to 0 if no membrane diffusing species is involved.\n\ncanchangerate_bypotentialenergy::Bool\n\n: Whether the reaction rate depends on reactant species potential energy.\n\nmembranediffusingnet_stoich::Vector{Pair{Int64, Int64}}\n\n: Pairs of membrane diffusing species index => Δcount"
  },
  {
    "objectID": "docstrings/src/context.html",
    "href": "docstrings/src/context.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Membrane protein physical parameters.\n\ndiffusion_coeff::Float64\n\n: Membrane diffusion coefficients (nm^2/s).\n\narea::Float64\n\n: Protein area projected onto the surface (nm^2).\n\n\n\n\n\n\n\n\n\n\n\n\nShallow copy, https://stackoverflow.com/questions/51956958/how-to-copy-a-struct-in-julia\n\n\n\n\n\n\n\n\n\n\n\n\nnum_filtypes(c::MEDYAN.Context) -> Int64\nReturn the number of filament types.\n\n\n\n\n\n\n\n\n\n\n\n\nfiltype_fil_ids(\n    c::MEDYAN.Context,\n    ftid::Int64\n) -> Vector{Int64}\nReturn a read only iterable of all filament ids of filament type ftid.\nThis can be invalid after any mutations to context, so collect if needed.\n\n\n\n\n\n\n\n\n\n\n\n\nfil_node_positions(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> Vector{StaticArraysCore.SVector{3, Float64}}\nReturn the node positions of the filament\n\n\n\n\n\n\n\n\n\n\n\n\nfil_node_mon_ids(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> Vector{Int64}\nReturn the node monomer ids of the filament.\nThe fil_node_mon_ids are the monomer ids at (slightly plus side of) the fil_node_positions\n                                 |\n                      -----+-----|-----+-----\n  minus end <----       M  |  M  | (M) |  M        ----> plus end\n                      -----+-----|-----+-----\n                                 |\n                                 ^ A node position is indicated by the line.\n\nThe monomer id with parenthesis (M) will in `fil_node_mon_ids`\nThe first monomer id is the first monomer id on the filament. The last monomer id is the last monomer id on the filament + 1\n\n\n\n\n\n\n\n\n\n\n\n\nfil_mon_states(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> OffsetArrays.OffsetVector{UInt8, Vector{UInt8}}\nReturn a read only OffsetVector of monomer states on a filament.\nThis can be invalid after any mutations to context, so copy if needed.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_exists(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Bool\nReturn true iff the filament and monomer exists\n\n\n\n\n\n\n\n\n\n\n\n\nmon_minimized(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Bool\nReturn true iff the monomer has been minimized\n\n\n\n\n\n\n\n\n\n\n\n\nmon_3states(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Tuple{UInt8, UInt8, UInt8}\nReturn a tuple of three monomer states centered at a monomer.\nIf a monomer doesn’t exist, its state will be zero. The filament must exist.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_position(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> StaticArraysCore.SVector{3, Float64}\nReturn the monomer position.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_plusvector(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> StaticArraysCore.SVector{3, Float64}\nReturn the unit vector toward the plus end of the filament.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_position_plusvector(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}\nReturn a tuple of position and plusvector at a monomer.\n\n\n\n\n\n\n\n\n\n\n\n\nset_time!(c::MEDYAN.Context, x::Float64) -> Float64\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\nset_enable_cylinder_volume_exclusion!(\n    c::MEDYAN.Context,\n    x::Bool\n) -> Bool\nAre cylinder volume exclusion forces calculated.\n\n\n\n\n\n\n\n\n\n\n\n\nset_chemboundary!(\n    c::MEDYAN.Context;\n    kwargs...\n) -> MEDYAN.Boundary\nSet chemical boundary and update compartment volumes and diffusion rates. Note, the chemboundary should be outside the mechboundary so that it is rare for filaments to go outside the chemboundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the chemical boundary of the simulation\ninside = signbit(pos ⋅ planes[bi][1:3] - planes[bi][4])\nFor example, a plane [1,0,0,3] is inside if x < 3 nm.\n2.0*[1,0,0,3] is also inside if x < 3 nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the chemical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is ignored.\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_mechboundary!(\n    c::MEDYAN.Context;\n    kwargs...\n) -> MEDYAN.Boundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the mechanical boundary of the simulation\nE = 1//2 * relu(pos ⋅ planes[bi][1:3] - planes[bi][4])^2\nFor example, a mech bounding plane [1,0,0,3] would try and make x < 3 nm with a spring constant of 1 pN/nm.\n2.0*[1,0,0,3] would try and make x < 3 nm with a spring constant of 4 pN/nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the mechanical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is the spring constant (pN/nm).\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\nE = 1//2*k*relu(d - r0)^2 where:\n\nd is the distance of the point to the spine line segment described by capsules[bi][1:6].\nr0 is capsules[bi][7]\nk is capsules[bi][8]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchem_adddiffusingcount!(c::Context, sid, cid, inccount)\nAdd inccount to diffusing species id sid in compartment id cid\n\n\n\n\n\n\n\n\n\n\n\n\nchem_addfixedcount!(c::Context, sid, cid, inccount)\nAdd inccount to fixed species id sid in compartment id cid\n\n\n\n\n\n\n\n\n\n\n\n\nadddiffusingcount_rand!(c::Context, dsid, inccount)\nDistribute the added diffusing species count randomly to compartments weighted by volume.\n\ndsid: diffusing species id.\ninccount: amount to add.\n\n\n\n\n\n\n\n\n\n\n\n\n\naddmembranediffusingcount_rand!(\n    c::MEDYAN.Context,\n    membraneindex::Int64,\n    speciesindex::Int64,\n    addcount::Int64\n)\nDistribute the added membrane species count randomly to membrane cells, ignoring cell area difference. Does NOT update propensity.\n\n\n\n\n\n\n\n\n\n\n\n\nnewfilament_rand!(c::Context, monomerstates; iterations = 10^9, ftid = 1)\nAdd a filament with type id ftid to the Context with random center position and direction.\nReturn the filament id of a new filament.\nmonomerstates is a collection of the MonomerState of the monomers in the new filament.\nThe filament will be inside the mech boundary.\nErrors if it fails to add a filament.\nThe monomer are spaced by the value in the filament type’s mechanical parameters.\n\n\n\n\n\n\n\n\n\n\n\n\nrun_chemistry!(c::Context, Δt)\nRun chemistry for Δt time.\nUpdate c.time.\n\n\n\n\n\n\n\n\n\n\n\n\nempty!(c::Context)\nRemove all filaments, membranes, linkers, diffusing species, fixed species, chemboundary, and mechboundary.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_setmonomerstate!(c::Context, name::MonomerName, state::MonomerState)\nUpdate a monomer state.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_polymerize!(c::Context, ftid, fid, isminusend::Bool, newstate::MonomerState)\nAdd a monomer with state newstate to the end of the filament with type id ftid and id fid.\nIf isminusend is true add the monomer to the minus end of the filament, if false add it to the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked linkers, or change any of the monomer names. New monomers are not linkable until after minimization.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_depolymerize!(c::Context, ftid, fid, isminusend::Bool)\nRemove a monomer from the end of the filament with type id ftid and id fid.\nIf isminusend is true remove the monomer from the minus end of the filament, if false remove it from the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked linkers, or change any of the monomer names.\nError if the filament isn’t initially over 2 monomers long.\nWarn if the old end monomer is referenced in a linker, and remove the linker.\nThe warning can be disabled by passing keyword argument warniflinkerremoved=false\n\n\n\n\n\n\n\n\n\n\n\n\nchem_newlinker!(c::Context, ltid, endnames::Pair{MonomerName,MonomerName}, linkerstate::LinkerState)\n\nchem_newlinker!(c::Context, ltid, endnames::Pair{MonomerName,MonomerName};\n    changedchemstate = (;),\n    changedmechstate = (;),\n    is_minimized = c.linkerdata[ltid].params.defaultstate.is_minimized,\n)\nAdd a new linker with type id ltid between monemers endnames.\nError if a linker of the same type links the same monomers in the same order.\nIf the linker state isn’t provided, c.linkerdata[ltid].params.defaultstate is new linker’s state, optionally modified by the changedchemstate, changedmechstate, and is_minimized keyword arguments.\nKeyword arguments changedchemstate and changedmechstate are namedtuples that shadow fields from the default chemstate and mechstate for the new linker.\nKeyword argument is_minimized can be used to set the new linker’s is_minimized state.\n\n\nchem_newlinker!(c, g.ltid, minusname=>plusname;\n        changedmechstate = (L0 = dist,),\n        changedchemstate = (numHeads = rand(g.numHeadsMin:g.numHeadsMax),),\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nchem_removelinker!(c::Context, ltid, endnames::Pair{MonomerName,MonomerName})\nRemove a linker of type id ltid between monemers endnames.\nError if there is no linker there.\nDon’t modify monomer states.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_setlinkerstate!(c::Context, ltid, endnames::Pair{MonomerName,MonomerName}, linkerstate::LinkerState)\nSet linkerstate of the linker of type id ltid with endnames.\nError if there is no linker there.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_newfilament!(c::Context; ftid=1, monomerstates, node_mids, nodepositions)\nReturn the filament id of a new filament.\nError if the filament isn’t initially over 2 monomers long.\nNewly added filaments don’t have linkable sites, until after minimization.\n\n\n\nftid=1: filament type id.\nmonomerstates: Collection of the MonomerState of the monomers in the new filament. In order from minus end to plus end.\nlength(monomerstates)>1\nnodepositions: Collection of SVector{3,Float64}. The positions of the nodes, monomers are between nodes.\nnode_mids: Collection of Integer. The monomer ids at (slightly plus side of) the nodepositions\n                               |\n                    -----+-----|-----+-----\nminus end <----       M  |  M  | (M) |  M        ----> plus end\n                    -----+-----|-----+-----\n                               |\n                               ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\nlength(node_mids) == length(nodepositions) - 1\nendloadforces=(0.0=>0.0): end load forces, usually don’t use this, because load forces will automatically get updated at the next minimization.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchem_removefilament!(c::Context; ftid=1, fid=maximum(filtype_fil_ids(c, ftid)))\nRemove the filament with type id ftid and id fid.\nBy default the last added filament with type id ftid is removed.\nWarn if any monomers on the filament are referenced by any linkers, and remove those linkers.\nThe warning can be disabled by passing keyword argument warniflinkerremoved=false\n\n\n\n\n\n\n\n\n\n\n\n\nnewmembrane!(c::MEDYAN.Context; type, meshinit)\nAdd a new membrane to the system.\n\n\n\nmeshinit is structure containing mesh shape initialization information, such as a named tuple (vertlist, trilist) containing vertex coordinates and triangle list, MeshInitEllipsoid, MeshInitPlane or a general MeshInitSurfaceFunc."
  },
  {
    "objectID": "docstrings/src/filamentendsites.html",
    "href": "docstrings/src/filamentendsites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Filament end site that matches with a vector of monomer states.\n\nisminusend::Bool\nendstates::Vector{UInt8}\nspacing::Float64"
  },
  {
    "objectID": "docstrings/src/sysdefs.html",
    "href": "docstrings/src/sysdefs.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "ftid::Int64\n\n: filament type id\n\nfid::Int64\n\n: filament id\n\nmid::Int64\n\n: monomer id\n\n\n\n\n\n\n\n\n\n\n\n\n\nmembraneindex::Int64\n\n: membrane index\n\nvid::Int64\n\n: vertex id\n\n\n\n\n\n\n\n\n\n\n\n\nThere is one instance of this per linker.\n\nchemstate::NamedTuple\n\n: Other state.\n\nmechstate::NamedTuple\n\n: Used in linker force calculation.\n\nis_minimized::Bool\n\n: Set to true after minimization\n\n\n\n\n\n\n\n\n\n\n\n\nLinker Parameters, there is one instance of this per linker type\n\ndefaultstate::MEDYAN.LinkerState\nmechparams::Any\nno_collide::Bool\n\n: if true, allows cylinders this linker type connects and adjacent cylinders to clip\n\n\n\n\n\n\n\n\n\n\n\n\nThere is one instance of this per cadherin.\n\nchemstate::NamedTuple\n\n: Other state.\n\nmechstate::NamedTuple\n\n: Used in linker force calculation.\n\nis_minimized::Bool\n\n: Set to true after minimization\n\n\n\n\n\n\n\n\n\n\n\n\nCadherin Parameters, there is one instance of this per cadherin type\n\ndefaultstate::MEDYAN.CadherinState\nmechparams::Any\n\n\n\n\n\n\n\n\n\n\n\n\n\naddlinker!(s::SysDef,linkertypename::Symbol,defaultstate::LinkerState,mechparams;no_collide=false)\nAdd the linker to the system. Return s.\nSetting no_collide to true allows cylinders this linker type connects and adjacent cylinders to clip.\n\n:::\n\n## [`` MEDYAN.addfilamentsite! ``](/docstrings/eb6bfd871a21b6f4.qmd) {#eb6bfd871a21b6f4}\n:::{.callout-note appearance=\"minimal\"}\n```julia\naddfilamentsite!(s::SysDef,filamenttypename::Symbol,filamentsitename::Symbol,site)\n\n\n\n\n\n\n\n\n\n\n\n\naddfilamentendsite!(s::SysDef,filamenttypename::Symbol,filamentendsitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddlinkersite!(s::SysDef,linkertypename::Symbol,linkersitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddlinkablesite!(s::SysDef,linkablesitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddcadherin!(s::SysDef,cadherintypename::Symbol,defaultstate::CadherinState,mechparams). Add the cadherin to the system. Return s.\n\n\n\n\n\n\n\n\n\n\n\n\naddcadherinsite!(s::SysDef,cadherintypename::Symbol,cadherinsitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddpossiblecadherinsite!(s::SysDef,possiblecadherinsitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddmembranesite!(\n    s::MEDYAN.SysDef,\n    membranesitename::Symbol,\n    site\n) -> MEDYAN.SysDef\nAdd a new site with a specified name. During this process, a new fixed species is created suffixed with “membranesite.”.\n\n\n\n\n\n\n\n\n\n\n\n\naddreaction!(s::SysDef,reaction::CompartmentReaction)::SysDef\n\n\n\n\n\n\n\n\n\naddreaction!(s::SysDef,reactionexpr::AbstractString,rate::Float64,invvolumepower::Int)::SysDef\nAdd a reaction to the system. Return s\nreactionexpr is a string describing the reaction stoichiometry\nreactionexpr is comprised of reactant and product parts seperated by a \"-->\"\nAll whitespace characters are ignored.\nEach side is then split by \"+\" to get the species names.\nRepeated or extra \"+\" are ignored.\nA species name can be prepended by a positive integer to represent multiple copies.\n\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s) rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)).\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\"diffusing.a + diffusing.b --> diffusing.c\"\n\"diffusing.c --> diffusing.a + diffusing.b\"\n\"+ + diffusing.c + --> + diffusing.a + + diffusing.b + +\"\n\" --> diffusing.a + diffusing.b\"\n\"diffusing.a + diffusing.b --> \"\n\"diffusing.a + diffusing.a --> \"\n\"2diffusing.a --> \"\n\"2diffusing.a --> 20diffusing.a\"\n\"diffusing.c + diffusing.b --> diffusing.c + diffusing.b\"\n\"fixedspecies.rate1b --> fixedspecies.g\"\n\"fixedspecies.rate1b + fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.rate1b + 23fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.g --> fixedspecies.rate1b + 23fixedspecies.g\"\n\"fixedspecies.g + fixedspecies.rate1b--> 2fixedspecies.rate1b + 23fixedspecies.g\"\n\"filamentsite.MT.d --> filamentsite.MT.d\"\n\"filamentsite.MT.d + diffusing.a --> filamentsite.MT.d\"\n\"fixedspecies.g --> diffusing.a\"\n\"diffusing.a --> fixedspecies.g\"\n\"filamentsite.actin.pm + diffusing.a --> filamentsite.actin.pm\"\n\n\n\n\n\n\n\n\n\n\n\n\n\naddreactioncallback!(s::SysDef, reaction::CompartmentReaction, callback)::SysDef\naddreactioncallback!(s::SysDef, reactantexpr::AbstractString, rate::Float64, invvolumepower::Int, callback)::SysDef\nLike addreaction! but also adds callback. callback is called when the reaction happens with input of MEDYAN.Context and Int the compartment id where the reaction happened.\nThe reaction should normally have no net stoichiometry because the callback should handle updating species counts. If an AbstractString is passed instead of a CompartmentReaction for the reaction, that string will be parsed to determine the reactants. The net stoichiometry will be zero.\nMEDYAN.errorcheck_addcallback(callback,s::SysDef) can optionally be overloaded to add errorchecking when the callback is added.\n\n\n\n\n\n\n\n\n\nCallback for bulk reactions: Context -> Nothing.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd filament reaction. Return s. Add a filamentsite and reaction with callback to change the monomer state. This can be used for filament aging, filament catalyzed reactions, or simple binding reactions.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentsitename::Symbol: the new name of the filamentsite added. This can be used as a catalyst in other reactions.\nchangedstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the monomer states, the first is the states to match. The second is the new monomer states after the reaction. both should be the same length. Ordered minus end first.\ncenter::Int: Which index of changedstatenames.first is the actual location of the filamentsite. Used for determining what compartment the reaction goes in.\nreactantexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentsite.$(filamenttypename).$(filamentsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nstatedef = StateDef(\n    filamentnames= [(:filname,[\n                            :a,\n                            :b,\n                            :c,\n                        ]),\n    ],\n)\ns= SysDef(statedef)\naddfilament_reaction!(s, :filname, :ab,\n    [:a]=>[:b], 1,\n    \"-->\", 1.75E-3, 0,\n)\naddfilament_reaction!(s, :filname, :aabc,\n    [:a,:a]=>[:b,:c], 2,\n    \"-->\", 1.75E-3, 0,\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd filament end reaction. Return s. Add a filamentendsite and reaction with callback to change the filaments. This can be used for polymerization, depolymeriation, and changing end state.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentendsitename::Symbol: the new name of the filamentendsite added. This can be used as a catalyst in other reactions.\nisminusend::Bool: true if changing the minus end, false if changing the plus end.\nchangedendstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the end monomer states, the first is the states to match. The second is the new monomer states after the reaction. If the second has more states than the first, new monomers will be added, if the second has less, monomers will be removed. Ordered minus end first.\nspacing::Float64: Space needed at the filament end for this reaction. (nm) ratefactor= exp(-β*spacing*loadforce) where β is 1/kT, loadforce is the external force pushing axially on the end of the filament. and ratefactor affects this reaction propensity and any others using filamentendsitename\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentendsite.$(filamenttypename).$(filamentendsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentendsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nstatedef = StateDef(\n    diffusingspeciesnames= [:a,],\n    filamentnames= [(:filname,[\n                            :plus,\n                            :mid,\n                            :minus,\n                        ]),\n    ],\n)\ns= SysDef(statedef)\nmonomerspacing= 2.7\n#minus end polymerization\naddfilamentend_reaction!(s, :filname, :pm, true,\n    [:minus]=>[:minus,:mid], monomerspacing,\n    \"diffusing.a -->\", 10E3, 1,\n)\n#plus end depolymerization\naddfilamentend_reaction!(s, :filname, :dpp, false,\n    [:mid,:plus]=>[:plus], 0.0,\n    \"--> diffusing.a\", 1.75E-3, 0,\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd unbinding site, callback, and reaction. Return s.\n\n\n\ns::SysDef: the system to add to.\nlinkertypename::Symbol: the linker type name.\nlinkersitename::Symbol: the new name of the linkersite added. This can be used as a catalyst in other reactions.\nlinkersite: the linker site to add.\nplusfilamenttypename::Symbol: the filament type name of the plus end.\nplusnewmonomerstatename::Symbol: the new name of the monomer state of the plus end.\nminusfilamenttypename::Symbol: the filament type name of the minus end.\nminusnewmonomerstatename::Symbol: the new name of the monomer state of the minus end.\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + linkersite.$(linkertypename).$(linkersitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using linkersitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd a membrane site with the corresponding reaction with callback.\nKeyword arguments:\n\ns: SysDef.\nname_newmembranesite: Symbol.\nmembranediffusingreactants: Vector of symbols as membrane reactants. 0 or 1 reactant is currently supported.\nmembranediffusingproducts: Vector of symbols as membrane products.\nreactionexpr_extra: Reaction expression for other species involved.\nrate: Float.\nchangerage_bypotentialenergy: Whether the rate is affected by potential energy.\ninvvolumepower: rate scaling with compartment volume.\n\nNotes:\n\nIf error occurs, this function does not ensure that s is unchanged."
  },
  {
    "objectID": "docstrings/src/linkablesites.html",
    "href": "docstrings/src/linkablesites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Any pair within max to min range are linkable if they have matching state with minusstate and plusstate.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64\n\n\n\n\n\n\n\n\n\n\n\n\n\nAny pair within max to min range are linkable if they have matching state with minusstate and plusstate and if both the angles between the filaments and line between the pair are greater than acos(cosminangle) for example if cosminangle is 1, all angles are ok, if cosminangle is sqrt(2)/2, and the line between the pair of monomers is parallel or anti parallel to either filament, it won’t be linkable.\nThis can be used to prevent linkers from binding both ends to the same filament.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64\ncosminangle::Float64"
  },
  {
    "objectID": "docstrings/src/auxprocs.html",
    "href": "docstrings/src/auxprocs.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Remesh all membrane meshes."
  },
  {
    "objectID": "docstrings/src/util/math/cuboidslicing.html",
    "href": "docstrings/src/util/math/cuboidslicing.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "scale the volume and area\n\n\n\n\n\n\n\n\n\nscale the volume and area by different amounts in each direction"
  },
  {
    "objectID": "docstrings/src/util/stableindex.html",
    "href": "docstrings/src/util/stableindex.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Whether an ID is in use.\n\n\n\n\n\n\n\n\n\n\n\n\nTotal number of IDs in use.\n\n\n\n\n\n\n\n\n\n\n\n\nGet index at ID.\n\n\n\n\n\n\n\n\n\n\n\n\nMap ID to a new index. The ID must be in use.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd a new index. Returns its ID.\n\n\n\n\n\n\n\n\n\n\n\n\nRemove a recorded index at ID.\n\n\n\n\n\n\n\n\n\n\n\n\nClear all index records.\n\n\n\n\n\n\n\n\n\n\n\n\nIterates through valid IDs in the StableIndex."
  },
  {
    "objectID": "docstrings/9c9d46adeded2d88.html",
    "href": "docstrings/9c9d46adeded2d88.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addreactioncallback!(s::SysDef, reaction::CompartmentReaction, callback)::SysDef\naddreactioncallback!(s::SysDef, reactantexpr::AbstractString, rate::Float64, invvolumepower::Int, callback)::SysDef\nLike addreaction! but also adds callback. callback is called when the reaction happens with input of MEDYAN.Context and Int the compartment id where the reaction happened.\nThe reaction should normally have no net stoichiometry because the callback should handle updating species counts. If an AbstractString is passed instead of a CompartmentReaction for the reaction, that string will be parsed to determine the reactants. The net stoichiometry will be zero.\nMEDYAN.errorcheck_addcallback(callback,s::SysDef) can optionally be overloaded to add errorchecking when the callback is added.\n\n\n\n\n\n\n\n\n\n\n\n\nCallback for bulk reactions: Context -> Nothing."
  },
  {
    "objectID": "docstrings/f36888837f14bad7.html",
    "href": "docstrings/f36888837f14bad7.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_removefilament!(c::Context; ftid=1, fid=maximum(filtype_fil_ids(c, ftid)))\nRemove the filament with type id ftid and id fid.\nBy default the last added filament with type id ftid is removed.\nWarn if any monomers on the filament are referenced by any linkers, and remove those linkers.\nThe warning can be disabled by passing keyword argument warniflinkerremoved=false"
  },
  {
    "objectID": "docstrings/7b719dca63a36b1b.html",
    "href": "docstrings/7b719dca63a36b1b.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addmembranediffusingcount_rand!(\n    c::MEDYAN.Context,\n    membraneindex::Int64,\n    speciesindex::Int64,\n    addcount::Int64\n)\nDistribute the added membrane species count randomly to membrane cells, ignoring cell area difference. Does NOT update propensity."
  },
  {
    "objectID": "docstrings/eb6bfd871a21b6f4.html",
    "href": "docstrings/eb6bfd871a21b6f4.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addfilamentsite!(s::SysDef,filamenttypename::Symbol,filamentsitename::Symbol,site)"
  },
  {
    "objectID": "docstrings/927d0affbbdfef6f.html",
    "href": "docstrings/927d0affbbdfef6f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_position_plusvector(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}\nReturn a tuple of position and plusvector at a monomer."
  },
  {
    "objectID": "docstrings/2264be341b81a600.html",
    "href": "docstrings/2264be341b81a600.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_adddiffusingcount!(c::Context, sid, cid, inccount)\nAdd inccount to diffusing species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/0286edfebf8ea5e6.html",
    "href": "docstrings/0286edfebf8ea5e6.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_addfixedcount!(c::Context, sid, cid, inccount)\nAdd inccount to fixed species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/8715d52e2302aaeb.html",
    "href": "docstrings/8715d52e2302aaeb.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add a new index. Returns its ID."
  },
  {
    "objectID": "docstrings/38c20ab68ab8bf1a.html",
    "href": "docstrings/38c20ab68ab8bf1a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_enable_cylinder_volume_exclusion!(\n    c::MEDYAN.Context,\n    x::Bool\n) -> Bool\nAre cylinder volume exclusion forces calculated."
  },
  {
    "objectID": "docstrings/70f38be9b44ff894.html",
    "href": "docstrings/70f38be9b44ff894.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addlinker!(s::SysDef,linkertypename::Symbol,defaultstate::LinkerState,mechparams;no_collide=false)\nAdd the linker to the system. Return s.\nSetting no_collide to true allows cylinders this linker type connects and adjacent cylinders to clip.\n```julia"
  },
  {
    "objectID": "docstrings/548fecb643fc2599.html",
    "href": "docstrings/548fecb643fc2599.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Membrane protein physical parameters.\n\ndiffusion_coeff::Float64\n\n: Membrane diffusion coefficients (nm^2/s).\n\narea::Float64\n\n: Protein area projected onto the surface (nm^2)."
  },
  {
    "objectID": "docstrings/7a5e88ac36e4ccbf.html",
    "href": "docstrings/7a5e88ac36e4ccbf.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_polymerize!(c::Context, ftid, fid, isminusend::Bool, newstate::MonomerState)\nAdd a monomer with state newstate to the end of the filament with type id ftid and id fid.\nIf isminusend is true add the monomer to the minus end of the filament, if false add it to the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked linkers, or change any of the monomer names. New monomers are not linkable until after minimization."
  },
  {
    "objectID": "docstrings/e7d3f961991e2663.html",
    "href": "docstrings/e7d3f961991e2663.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Whether an ID is in use."
  },
  {
    "objectID": "docstrings/a6dd8f73f68a3759.html",
    "href": "docstrings/a6dd8f73f68a3759.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_time!(c::MEDYAN.Context, x::Float64) -> Float64\nTime (s)"
  },
  {
    "objectID": "docstrings/2a8e1a84324de0b3.html",
    "href": "docstrings/2a8e1a84324de0b3.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add unbinding site, callback, and reaction. Return s.\n\n\n\ns::SysDef: the system to add to.\nlinkertypename::Symbol: the linker type name.\nlinkersitename::Symbol: the new name of the linkersite added. This can be used as a catalyst in other reactions.\nlinkersite: the linker site to add.\nplusfilamenttypename::Symbol: the filament type name of the plus end.\nplusnewmonomerstatename::Symbol: the new name of the monomer state of the plus end.\nminusfilamenttypename::Symbol: the filament type name of the minus end.\nminusnewmonomerstatename::Symbol: the new name of the monomer state of the minus end.\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + linkersite.$(linkertypename).$(linkersitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using linkersitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant."
  },
  {
    "objectID": "docstrings/56ef520341df3c06.html",
    "href": "docstrings/56ef520341df3c06.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Remove a recorded index at ID."
  },
  {
    "objectID": "docstrings/66734014eb12ddb1.html",
    "href": "docstrings/66734014eb12ddb1.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Allows up to 1 membrane diffusing species as reactants. Also stores net stoich of membrane diffusing species.\n\nid_membranediffusing_reactant::Int64\n\n: Set to 0 if no membrane diffusing species is involved.\n\ncanchangerate_bypotentialenergy::Bool\n\n: Whether the reaction rate depends on reactant species potential energy.\n\nmembranediffusingnet_stoich::Vector{Pair{Int64, Int64}}\n\n: Pairs of membrane diffusing species index => Δcount"
  },
  {
    "objectID": "docstrings/7a45f2860949bee3.html",
    "href": "docstrings/7a45f2860949bee3.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_newfilament!(c::Context; ftid=1, monomerstates, node_mids, nodepositions)\nReturn the filament id of a new filament.\nError if the filament isn’t initially over 2 monomers long.\nNewly added filaments don’t have linkable sites, until after minimization.\n\n\n\nftid=1: filament type id.\nmonomerstates: Collection of the MonomerState of the monomers in the new filament. In order from minus end to plus end.\nlength(monomerstates)>1\nnodepositions: Collection of SVector{3,Float64}. The positions of the nodes, monomers are between nodes.\nnode_mids: Collection of Integer. The monomer ids at (slightly plus side of) the nodepositions\n                               |\n                    -----+-----|-----+-----\nminus end <----       M  |  M  | (M) |  M        ----> plus end\n                    -----+-----|-----+-----\n                               |\n                               ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\nlength(node_mids) == length(nodepositions) - 1\nendloadforces=(0.0=>0.0): end load forces, usually don’t use this, because load forces will automatically get updated at the next minimization."
  },
  {
    "objectID": "docstrings/b70febdaf4c8fba5.html",
    "href": "docstrings/b70febdaf4c8fba5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Cadherin Parameters, there is one instance of this per cadherin type\n\ndefaultstate::MEDYAN.CadherinState\nmechparams::Any"
  },
  {
    "objectID": "docstrings/65101c73983f0beb.html",
    "href": "docstrings/65101c73983f0beb.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Models myosin walking rates from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the motor work per step increases, its walking rate goes to zero.\nReturns the walking rate of one end. The callback can then sample which end to move, or reject the move.\n\nfs::Float64\n\n: The stall force magnitude. Units of pN\n\nk0::Float64\n\n: Walking rate of one end at zero force. Units of 1/s\n\nα::Float64\n\n: Positive dimensionless parameter defining the steepness of the curve, smaller is more steep, if α is inf, the curve is linear\n\nwalking_direction::Int32\n\n: Motor walking direction, +1 is towards plus end, -1 is towards minus end\n\nisminusend::Bool\n\n: which motor end does this represent"
  },
  {
    "objectID": "docstrings/418304748816268d.html",
    "href": "docstrings/418304748816268d.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Clear all index records.\n\n\n\n\n\n\n\n\n\n\n\n\nempty!(c::Context)\nRemove all filaments, membranes, linkers, diffusing species, fixed species, chemboundary, and mechboundary."
  },
  {
    "objectID": "docstrings/7a32ac96fb4364ea.html",
    "href": "docstrings/7a32ac96fb4364ea.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Filament end site that matches with a vector of monomer states.\n\nisminusend::Bool\nendstates::Vector{UInt8}\nspacing::Float64"
  },
  {
    "objectID": "docstrings/9ffc8c8377769414.html",
    "href": "docstrings/9ffc8c8377769414.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addlinkablesite!(s::SysDef,linkablesitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/a5f262191e484dd4.html",
    "href": "docstrings/a5f262191e484dd4.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_depolymerize!(c::Context, ftid, fid, isminusend::Bool)\nRemove a monomer from the end of the filament with type id ftid and id fid.\nIf isminusend is true remove the monomer from the minus end of the filament, if false remove it from the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked linkers, or change any of the monomer names.\nError if the filament isn’t initially over 2 monomers long.\nWarn if the old end monomer is referenced in a linker, and remove the linker.\nThe warning can be disabled by passing keyword argument warniflinkerremoved=false"
  },
  {
    "objectID": "docstrings/da9bd35e7d1df7c3.html",
    "href": "docstrings/da9bd35e7d1df7c3.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addreaction!(s::SysDef,reaction::CompartmentReaction)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddreaction!(s::SysDef,reactionexpr::AbstractString,rate::Float64,invvolumepower::Int)::SysDef\nAdd a reaction to the system. Return s\nreactionexpr is a string describing the reaction stoichiometry\nreactionexpr is comprised of reactant and product parts seperated by a \"-->\"\nAll whitespace characters are ignored.\nEach side is then split by \"+\" to get the species names.\nRepeated or extra \"+\" are ignored.\nA species name can be prepended by a positive integer to represent multiple copies.\n\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s) rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)).\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\"diffusing.a + diffusing.b --> diffusing.c\"\n\"diffusing.c --> diffusing.a + diffusing.b\"\n\"+ + diffusing.c + --> + diffusing.a + + diffusing.b + +\"\n\" --> diffusing.a + diffusing.b\"\n\"diffusing.a + diffusing.b --> \"\n\"diffusing.a + diffusing.a --> \"\n\"2diffusing.a --> \"\n\"2diffusing.a --> 20diffusing.a\"\n\"diffusing.c + diffusing.b --> diffusing.c + diffusing.b\"\n\"fixedspecies.rate1b --> fixedspecies.g\"\n\"fixedspecies.rate1b + fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.rate1b + 23fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.g --> fixedspecies.rate1b + 23fixedspecies.g\"\n\"fixedspecies.g + fixedspecies.rate1b--> 2fixedspecies.rate1b + 23fixedspecies.g\"\n\"filamentsite.MT.d --> filamentsite.MT.d\"\n\"filamentsite.MT.d + diffusing.a --> filamentsite.MT.d\"\n\"fixedspecies.g --> diffusing.a\"\n\"diffusing.a --> fixedspecies.g\"\n\"filamentsite.actin.pm + diffusing.a --> filamentsite.actin.pm\""
  },
  {
    "objectID": "docstrings/898c415a5eddc619.html",
    "href": "docstrings/898c415a5eddc619.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_exists(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Bool\nReturn true iff the filament and monomer exists"
  },
  {
    "objectID": "docstrings/b9943bbf7a9c7781.html",
    "href": "docstrings/b9943bbf7a9c7781.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "num_filtypes(c::MEDYAN.Context) -> Int64\nReturn the number of filament types."
  },
  {
    "objectID": "docstrings/03b215fd47085105.html",
    "href": "docstrings/03b215fd47085105.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Linker Parameters, there is one instance of this per linker type\n\ndefaultstate::MEDYAN.LinkerState\nmechparams::Any\nno_collide::Bool\n\n: if true, allows cylinders this linker type connects and adjacent cylinders to clip"
  },
  {
    "objectID": "docstrings/fb2b6cfdc0e13e58.html",
    "href": "docstrings/fb2b6cfdc0e13e58.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Any pair within max to min range are linkable if they have matching state with minusstate and plusstate and if both the angles between the filaments and line between the pair are greater than acos(cosminangle) for example if cosminangle is 1, all angles are ok, if cosminangle is sqrt(2)/2, and the line between the pair of monomers is parallel or anti parallel to either filament, it won’t be linkable.\nThis can be used to prevent linkers from binding both ends to the same filament.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64\ncosminangle::Float64"
  },
  {
    "objectID": "docstrings/d333c38b9f9b3584.html",
    "href": "docstrings/d333c38b9f9b3584.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "filtype_fil_ids(\n    c::MEDYAN.Context,\n    ftid::Int64\n) -> Vector{Int64}\nReturn a read only iterable of all filament ids of filament type ftid.\nThis can be invalid after any mutations to context, so collect if needed."
  },
  {
    "objectID": "docstrings/a714b4a1c87062be.html",
    "href": "docstrings/a714b4a1c87062be.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "newmembrane!(c::MEDYAN.Context; type, meshinit)\nAdd a new membrane to the system.\n\n\n\nmeshinit is structure containing mesh shape initialization information, such as a named tuple (vertlist, trilist) containing vertex coordinates and triangle list, MeshInitEllipsoid, MeshInitPlane or a general MeshInitSurfaceFunc."
  },
  {
    "objectID": "docstrings/5b17adaf7d8a4f62.html",
    "href": "docstrings/5b17adaf7d8a4f62.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_minimized(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Bool\nReturn true iff the monomer has been minimized"
  },
  {
    "objectID": "docstrings/5228367cd62c0bf2.html",
    "href": "docstrings/5228367cd62c0bf2.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Iterates through valid IDs in the StableIndex."
  },
  {
    "objectID": "docstrings/9e21ac42968d0196.html",
    "href": "docstrings/9e21ac42968d0196.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addcadherinsite!(s::SysDef,cadherintypename::Symbol,cadherinsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/63195cbff2ab4237.html",
    "href": "docstrings/63195cbff2ab4237.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add filament reaction. Return s. Add a filamentsite and reaction with callback to change the monomer state. This can be used for filament aging, filament catalyzed reactions, or simple binding reactions.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentsitename::Symbol: the new name of the filamentsite added. This can be used as a catalyst in other reactions.\nchangedstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the monomer states, the first is the states to match. The second is the new monomer states after the reaction. both should be the same length. Ordered minus end first.\ncenter::Int: Which index of changedstatenames.first is the actual location of the filamentsite. Used for determining what compartment the reaction goes in.\nreactantexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentsite.$(filamenttypename).$(filamentsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nstatedef = StateDef(\n    filamentnames= [(:filname,[\n                            :a,\n                            :b,\n                            :c,\n                        ]),\n    ],\n)\ns= SysDef(statedef)\naddfilament_reaction!(s, :filname, :ab,\n    [:a]=>[:b], 1,\n    \"-->\", 1.75E-3, 0,\n)\naddfilament_reaction!(s, :filname, :aabc,\n    [:a,:a]=>[:b,:c], 2,\n    \"-->\", 1.75E-3, 0,\n)"
  },
  {
    "objectID": "docstrings/3db9714621903b78.html",
    "href": "docstrings/3db9714621903b78.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "fil_mon_states(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> OffsetArrays.OffsetVector{UInt8, Vector{UInt8}}\nReturn a read only OffsetVector of monomer states on a filament.\nThis can be invalid after any mutations to context, so copy if needed."
  },
  {
    "objectID": "docstrings/5d2d78f0a619d47e.html",
    "href": "docstrings/5d2d78f0a619d47e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_setlinkerstate!(c::Context, ltid, endnames::Pair{MonomerName,MonomerName}, linkerstate::LinkerState)\nSet linkerstate of the linker of type id ltid with endnames.\nError if there is no linker there."
  },
  {
    "objectID": "docstrings/6e12ca754f13e601.html",
    "href": "docstrings/6e12ca754f13e601.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Models unbinding rates based on the following exponential form of Bell et al, 1978: k0*exp(f/f0) Where f is the magnitude of the force. So as to exponetially increase the unbinding with more force.\nlinkersitecount returns the unbinding rate in units of 1/s It returns k0 if the linker hasn’t been minimized yet.\n\nf0::Float64\n\n: The charicteristic force magnitude. Units of pN\n\nk0::Float64\n\n: Unbinding rate at zero force. Units of 1/s"
  },
  {
    "objectID": "docstrings/ed756af0de4db0ca.html",
    "href": "docstrings/ed756af0de4db0ca.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_setmonomerstate!(c::Context, name::MonomerName, state::MonomerState)\nUpdate a monomer state."
  },
  {
    "objectID": "docstrings/f593dde852851bc8.html",
    "href": "docstrings/f593dde852851bc8.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Get index at ID."
  },
  {
    "objectID": "docstrings/3c757785fa097c75.html",
    "href": "docstrings/3c757785fa097c75.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addcadherin!(s::SysDef,cadherintypename::Symbol,defaultstate::CadherinState,mechparams). Add the cadherin to the system. Return s."
  },
  {
    "objectID": "docstrings/e534be293ce74465.html",
    "href": "docstrings/e534be293ce74465.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "load_snapshot!(c::Context,group::Union{HDF5.File, HDF5.Group})\nEmpty the context and load the state saved in the snapshot group.\nc should be constructed with the same SysDef and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nSee Snapshot group for more details."
  },
  {
    "objectID": "docstrings/d4fdd3b317023c0e.html",
    "href": "docstrings/d4fdd3b317023c0e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Force (re-)evaluation of the objective value at x. Returns f(x) and stores the value in obj.F also calculates the gradient and stores it in obj.DF"
  },
  {
    "objectID": "docstrings/725f722fff4cfa6d.html",
    "href": "docstrings/725f722fff4cfa6d.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Map ID to a new index. The ID must be in use."
  },
  {
    "objectID": "docstrings/475f8052be7cf4cb.html",
    "href": "docstrings/475f8052be7cf4cb.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_newlinker!(c::Context, ltid, endnames::Pair{MonomerName,MonomerName}, linkerstate::LinkerState)\n\nchem_newlinker!(c::Context, ltid, endnames::Pair{MonomerName,MonomerName};\n    changedchemstate = (;),\n    changedmechstate = (;),\n    is_minimized = c.linkerdata[ltid].params.defaultstate.is_minimized,\n)\nAdd a new linker with type id ltid between monemers endnames.\nError if a linker of the same type links the same monomers in the same order.\nIf the linker state isn’t provided, c.linkerdata[ltid].params.defaultstate is new linker’s state, optionally modified by the changedchemstate, changedmechstate, and is_minimized keyword arguments.\nKeyword arguments changedchemstate and changedmechstate are namedtuples that shadow fields from the default chemstate and mechstate for the new linker.\nKeyword argument is_minimized can be used to set the new linker’s is_minimized state.\n\n\nchem_newlinker!(c, g.ltid, minusname=>plusname;\n        changedmechstate = (L0 = dist,),\n        changedchemstate = (numHeads = rand(g.numHeadsMin:g.numHeadsMax),),\n    )"
  },
  {
    "objectID": "docstrings/8facd8a85195dbd0.html",
    "href": "docstrings/8facd8a85195dbd0.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Any pair within max to min range are linkable if they have matching state with minusstate and plusstate.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64"
  },
  {
    "objectID": "docstrings/b5e26b6b690256aa.html",
    "href": "docstrings/b5e26b6b690256aa.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_mechboundary!(\n    c::MEDYAN.Context;\n    kwargs...\n) -> MEDYAN.Boundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the mechanical boundary of the simulation\nE = 1//2 * relu(pos ⋅ planes[bi][1:3] - planes[bi][4])^2\nFor example, a mech bounding plane [1,0,0,3] would try and make x < 3 nm with a spring constant of 1 pN/nm.\n2.0*[1,0,0,3] would try and make x < 3 nm with a spring constant of 4 pN/nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the mechanical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is the spring constant (pN/nm).\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\nE = 1//2*k*relu(d - r0)^2 where:\n\nd is the distance of the point to the spine line segment described by capsules[bi][1:6].\nr0 is capsules[bi][7]\nk is capsules[bi][8]"
  },
  {
    "objectID": "docstrings/4ca5eb8401ab10b2.html",
    "href": "docstrings/4ca5eb8401ab10b2.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Shallow copy, https://stackoverflow.com/questions/51956958/how-to-copy-a-struct-in-julia"
  },
  {
    "objectID": "docstrings/432ec27232aad41e.html",
    "href": "docstrings/432ec27232aad41e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "newfilament_rand!(c::Context, monomerstates; iterations = 10^9, ftid = 1)\nAdd a filament with type id ftid to the Context with random center position and direction.\nReturn the filament id of a new filament.\nmonomerstates is a collection of the MonomerState of the monomers in the new filament.\nThe filament will be inside the mech boundary.\nErrors if it fails to add a filament.\nThe monomer are spaced by the value in the filament type’s mechanical parameters."
  },
  {
    "objectID": "docstrings/0aa6e4e95c60f9f7.html",
    "href": "docstrings/0aa6e4e95c60f9f7.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_chemboundary!(\n    c::MEDYAN.Context;\n    kwargs...\n) -> MEDYAN.Boundary\nSet chemical boundary and update compartment volumes and diffusion rates. Note, the chemboundary should be outside the mechboundary so that it is rare for filaments to go outside the chemboundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the chemical boundary of the simulation\ninside = signbit(pos ⋅ planes[bi][1:3] - planes[bi][4])\nFor example, a plane [1,0,0,3] is inside if x < 3 nm.\n2.0*[1,0,0,3] is also inside if x < 3 nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the chemical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is ignored.\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries."
  },
  {
    "objectID": "docstrings/84c4aeab5457d3ee.html",
    "href": "docstrings/84c4aeab5457d3ee.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "minimize_energy!(c::Context)\nMinimize mechanical energy of the context."
  },
  {
    "objectID": "docstrings/8344ea3a27bb217f.html",
    "href": "docstrings/8344ea3a27bb217f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "The catch-bond nature of myosin unbinding with multiple heads. Adopted from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the force increases, the motor unbinding rate decreases to a minimum of k0/10\nlinkersitecount returns the unbinding rate in units of 1/s It returns k0 if the linker hasn’t been minimized yet. It assumes linkerstate.chemstate.numHeads exists for the linker.\n\nf0::Float64\n\n: single head characteristic unbinding force, units of pN/head\n\nonRate::Float64\n\n: single head binding rate, units of 1/s\n\noffRate::Float64\n\n: single head unbinding rate, units of 1/s\n\nβ::Float64\n\n: slope of head binding, units of (head)/(pN/head)"
  },
  {
    "objectID": "docstrings/59d1fe245302e071.html",
    "href": "docstrings/59d1fe245302e071.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add a membrane site with the corresponding reaction with callback.\nKeyword arguments:\n\ns: SysDef.\nname_newmembranesite: Symbol.\nmembranediffusingreactants: Vector of symbols as membrane reactants. 0 or 1 reactant is currently supported.\nmembranediffusingproducts: Vector of symbols as membrane products.\nreactionexpr_extra: Reaction expression for other species involved.\nrate: Float.\nchangerage_bypotentialenergy: Whether the rate is affected by potential energy.\ninvvolumepower: rate scaling with compartment volume.\n\nNotes:\n\nIf error occurs, this function does not ensure that s is unchanged."
  },
  {
    "objectID": "docstrings/6c16efb303a60058.html",
    "href": "docstrings/6c16efb303a60058.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_3states(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Tuple{UInt8, UInt8, UInt8}\nReturn a tuple of three monomer states centered at a monomer.\nIf a monomer doesn’t exist, its state will be zero. The filament must exist."
  },
  {
    "objectID": "docstrings/0d87ce44fed17b2c.html",
    "href": "docstrings/0d87ce44fed17b2c.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "General filament site just matches monomer states\n\ncenter::Int64\n\n: index of center monomer in states\n\nstates::Vector{UInt8}\n\n: monomer states to match"
  },
  {
    "objectID": "docstrings/c298c8d740eb51b1.html",
    "href": "docstrings/c298c8d740eb51b1.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addlinkersite!(s::SysDef,linkertypename::Symbol,linkersitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/9d3ddfabbceeef92.html",
    "href": "docstrings/9d3ddfabbceeef92.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "adddiffusingcount_rand!(c::Context, dsid, inccount)\nDistribute the added diffusing species count randomly to compartments weighted by volume.\n\ndsid: diffusing species id.\ninccount: amount to add."
  },
  {
    "objectID": "docstrings/b7271c7721602813.html",
    "href": "docstrings/b7271c7721602813.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_plusvector(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> StaticArraysCore.SVector{3, Float64}\nReturn the unit vector toward the plus end of the filament."
  },
  {
    "objectID": "docstrings/a21e771ed8ea7d6f.html",
    "href": "docstrings/a21e771ed8ea7d6f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "scale the volume and area\n\n\n\n\n\n\n\n\n\n\n\n\nscale the volume and area by different amounts in each direction"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Documentation for MEDYAN."
  },
  {
    "objectID": "index.html#warning-the-api-is-very-unstable-and-this-package-is-not-released-yet.",
    "href": "index.html#warning-the-api-is-very-unstable-and-this-package-is-not-released-yet.",
    "title": "MEDYAN.jl",
    "section": "Warning, the API is very unstable, and this package is not released yet.",
    "text": "Warning, the API is very unstable, and this package is not released yet.\nWelcome to Papoian Lab’s Mechanochemical Dynamics of Active Networks Julia package.\nThis is based on the C++ medyan command line tool also developed by the Papoian Lab.\nCopyright 2022, Papoian lab at the University of Maryland.\nThis code is distributed under the license found in this directory, license.txt."
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "MEDYAN.jl",
    "section": "Usage",
    "text": "Usage\nFirst install and run Julia https://julialang.org/downloads/\nThen if you haven’t yet, set up ssh keys with github.\nAlso, currently you may have to install git and ensure you have a .julia/config/startup.jl with\nENV[\"JULIA_PKG_USE_CLI_GIT\"]= \"true\"\nFinally, to add the current MEDYAN.jl, in Julia run:\n] add git@github.com:medyan-dev/MEDYAN.jl.git\nTo add a specific commit id, for example 2d31e2a, in Julia run:\n] add \"git@github.com:medyan-dev/MEDYAN.jl.git\"#2d31e2a\nSee the docs for tutorials and more information."
  },
  {
    "objectID": "index.html#authors",
    "href": "index.html#authors",
    "title": "MEDYAN.jl",
    "section": "Authors",
    "text": "Authors\nActive developers:\n\n\n\nName\nEmail\n\n\n\n\nHaoran Ni\nhaoranni@umd.edu\n\n\nNathan Zimmerberg\nnzimmerb@umd.edu\n\n\n\nAll developers including developers of C++ medyan:\nGaregin Papoian (gpapoian@umd.edu), Konstantin Popov, James Komianos, Aravind Chandrasekaran, Qin Ni, Carlos Floyd, Haoran Ni, Nathan Zimmerberg, Joshua Lucker.\nAll general correspondence about the code and its applications should be directed to Garegin Papoian. All developer and more specific code, installation, and usage correspondence should be directed to Active developers via email or the issue tracker."
  },
  {
    "objectID": "index.html#running-tests",
    "href": "index.html#running-tests",
    "title": "MEDYAN.jl",
    "section": "Running tests",
    "text": "Running tests\nIn shell:\ncd test\njulia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=dirname(pwd()))); Pkg.instantiate()'\njulia --project\nIn julia repl:\ninclude(\"runtests.jl\")\nYou can also include individual test files to run just those tests."
  },
  {
    "objectID": "index.html#running-notebooks",
    "href": "index.html#running-notebooks",
    "title": "MEDYAN.jl",
    "section": "Running notebooks",
    "text": "Running notebooks\nTo run interactively in a Pluto Notebook, run the following shell commands:\ncd notebooks\njulia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=dirname(pwd()))); Pkg.instantiate()'\njulia --project -e 'import Pluto; Pluto.run()'\nTo generate static html files, run the following shell commands:\ncd notebooks\njulia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=dirname(pwd()))); Pkg.instantiate()'\njulia --project runnotebooks.jl"
  },
  {
    "objectID": "index.html#editing-documentation",
    "href": "index.html#editing-documentation",
    "title": "MEDYAN.jl",
    "section": "Editing Documentation",
    "text": "Editing Documentation\nFirst, if you haven’t yet, install quarto\nRun the following to check your quarto installation has the julia kernel.\nquarto check jupyter\nYou may have to run the following after updating julia if jupyter doesn’t have the latest kernel.\nusing Pkg\nPkg.build(\"IJulia\")\nRun the following to set up the environment.\njulia --project=quartodocs -e '\n            using Pkg\n            Pkg.develop([PackageSpec(path=pwd()), PackageSpec(url=\"https://github.com/medyan-dev/QMDDocTools.jl.git\")])\n            Pkg.instantiate()'\nRun the following to generate or refresh the docstrings for the site.\njulia --project=quartodocs quartodocs/make-docstrings.jl\nFinally run the following to view the site. Any changes to files in quartodocs should auto update.\nquarto preview quartodocs"
  },
  {
    "objectID": "reference/fileformats.html",
    "href": "reference/fileformats.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "MEDYAN.jl uses HDF5 with Blosc compression for saving snapshots.\nIn HDF5.jl Blosc sometimes needs to be installed by running import H5Zblosc before reading a compressed dataset.\n\n\n\n\n\n\nOther Languages\n\n\n\nTo open these files with h5py you must also install the blosc plugin\nhttps://pypi.org/project/hdf5plugin/\nFor other HDF5 tools see\nhttps://github.com/Blosc/hdf5-blosc\nIn addition, HDF5.jl transposes all arrays on load and store.\nSo any column described below is a row, and vice versa, in the HDF5 file and when read with h5py.\n\n\n\n\nTrajectory outputs are stored in a folder.\nThe folder contains a header.json file, a list.csv file, and a snapshots subfolder containing many $(NUMBER).h5 files where NUMBER is the frame number of the snapshot.\n\n\n\nheader.json contains static metadata about the simulation that is constant over time.\n\n\n\nusing MEDYAN\ncinit, s = MEDYAN.example_all_sites_context()\nMEDYAN.header(cinit)\n\n{\n    \n\n\n\"version\": \"0.1.0\",\n    \"medyanInfo\": {\n\n\n        \"title\": \"MEDYAN.jl\",\n        \"version\": \"0.1.0\",\n        \"sourceCodeUrl\": \"https://github.com/medyan-dev/MEDYAN.jl\"\n    },\n    \"size\": {\n        \"x(nm)\": 2000,\n        \"y(nm)\": 500,\n        \"z(nm)\": 500\n    },\n    \"chem_grid_size\": {\n        \"nx\": 4,\n        \"ny\": 1,\n        \"nz\": 1,\n        \"voxel_x(nm)\": 500,\n        \"voxel_y(nm)\": 500,\n        \"voxel_z(nm)\": 500\n    },\n    \"diffusing_species\": [\n\n\n        {\n            \"name\": \"b\"\n        },\n        {\n            \"name\": \"c\"\n        }\n    ],\n    \"membrane_diffusing_species\": [\n        {\n            \"name\": \"ma\"\n        },\n        {\n            \"name\": \"mb\"\n        },\n        {\n            \"name\": \"mc\"\n        }\n    ],\n    \"fixed_species\": [\n        {\n            \"name\": \"d\"\n        },\n        {\n            \"name\": \"a\"\n        }\n    ],\n    \"filaments\": \n\n\n[\n        {\n            \"name\": \"a\",\n            \"radius(nm)\": 3,\n            \"monomerstates\": [\n                \"me\",\n                \"a\",\n                \"b\",\n                \"c\",\n                \"pe\"\n            ]\n        },\n        {\n            \"name\": \"b\",\n            \"radius(nm)\": 3,\n            \"monomerstates\": [\n                \"me\",\n                \"a\",\n                \"b\",\n                \"c\",\n                \"pe\"\n            ]\n        }\n    ],\n    \"fil_linkers\": [\n        {\n            \"name\": \"a\"\n        },\n        {\n            \"name\": \"b\"\n        },\n        {\n            \"name\": \"c\"\n        },\n        {\n            \"name\": \"d\"\n        }\n    ]\n}\n\n\n\n\n\n\nA snapshot describes the state of a Context at a single point in time.\nA snapshot can be used to set the state of a Context if it was constructed with the same system and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nThe snapshot doesn’t hold the exact full state of a Context, simulations restarted from a snapshot may not have the exact same results because:\n\nThe snapshot doesn’t store the state of the random number generator.\nCoordinates may be rounded to save disk space.\nDictionaries and other internal data structures may get reordered and or resorted when the snapshot is loaded.\nMultithreading may be non deterministic.\n\nBut if rounding isn’t too extreme, the reloaded Context should have the same statistics.\n\n\nThe snapshot format is versioned by the “version” attribute. The current snapshot version is:\n\nusing MEDYAN\nusing HDF5\nMEDYAN.SNAPSHOT_VERSION\n\nv\"0.4.0\"\n\n\nCurrently before snapshot version 1.0.0 anything goes.\nAfter snapshot version 1.0.0 is released.\nSnapshots written with a previous snapshot version above v\"1\" should be readable. Snapshots written with a newer snapshot version are generally not readable.\nIf new agent types are added to MEDYAN.jl, usually only the minor version needs to be updated, as nothing special needs to be done to read older snapshot versions without that added agent type.\nIf new data is added to an existing agent type, also usually only the minor version needs to be increment, though the case of the new data not existing must be handled with some default.\nIf the way an existing agent type is stored significantly changes, such that external code analyzing the snapshot would need to be modified, the major version must be incremented. Also if possible there should be a function to update a snapshot from the old version to the new version.\n\n\nAny group, dataset, or attribute name prefixed with with “#” can change format or be removed without changing the snapshot version.\n“#experimental” is used for saving new types of agents or other data that doesn’t have a stable format yet.\n“#comment” is used for saving human readable comments that could change in format or wording.\n\n\n\n\n\nusing MEDYAN\nusing HDF5\nfname = tempname()\nfid = h5open(fname, \"w\")\ncinit, s = MEDYAN.example_all_sites_context()\nMEDYAN.snapshot(cinit,fid)\n\n\n\n\n\n\n\nSnapshot 📂\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\ntime (s)\n\n\nattrs(fid)[\"time (s)\"]\n\n0.0\n\n\nDefault: No change\nSee MEDYAN.set_time!\n\n\n\nversion\n\n\nattrs(fid)[\"version\"]\n\n\"0.4.0\"\n\n\nDefault: No change\nSee Snapshot Versioning\n\n\n\n\n\n\n\n\n\n\n\n\n🔢\n\n\n\n\n\n\n\ndiffusingcounts\n\n\nread(fid[\"diffusingcounts\"])\n\n2×4 Matrix{Int32}:\n 0   100  0   40\n 0  1000  0  400\n\n\nDefault: Empty\nIndexed by [species id, compartment id] to give count.\nSee MEDYAN.chem_adddiffusingcount!\n\n\n\nfixedcounts\n\n\nread(fid[\"fixedcounts\"])\n\n2×4 Matrix{Float64}:\n 10.25  0.0  0.0   0.0\n  0.0   0.0  0.0  20.25\n\n\nDefault: Empty\nIndexed by [species id, compartment id] to give count.\nSee MEDYAN.chem_addfixedcount!\n\n\n\n\n\n\n\n\n\n\n\n\n📂\n\n\n\n\n\n\n\n\n\n\n\n\nchemboundary\n\n\n\n\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.set_chemboundary!\n\n\n🔢 capsules\n\n\nread(fid[\"chemboundary/capsules\"])\n\n8×1 Matrix{Float64}:\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n 10000.0\n     1.0\n\n\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 planes\n\n\nread(fid[\"chemboundary/planes\"])\n\n4×6 Matrix{Float64}:\n -10.0     10.0    0.0     0.0    0.0     0.0\n   0.0      0.0  -10.0    10.0    0.0     0.0\n   0.0      0.0    0.0     0.0  -10.0    10.0\n   0.0  20000.0    0.0  5000.0    0.0  5000.0\n\n\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nfilaments\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nposition_scale\n\n\nattrs(fid[\"filaments\"])[\"position_scale\"]\n\n3\n\n\nDefault: No effect\nFilament positions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\nThere is a subgroup for each filament type with at least one filament. The subgroups are named by their filament type id. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n🔢 endloadforces\n\n\nread(fid[\"filaments/1/endloadforces\"])\n\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\n\nFilament end load forces (pN).\nEach row is the load force on the minus and plus ends of a filament.\n\n\n\n🔢 fids\n\n\nread(fid[\"filaments/1/fids\"])\n\n2-element Vector{Int32}:\n 1\n 2\n\n\nFilament ids.\n\n\n\n🔢 minusend_num_notminimized\n\n\nread(fid[\"filaments/1/minusend_num_notminimized\"])\n\n2-element Vector{Int32}:\n 0\n 0\n\n\nNumber of newly added monomers to the filament minus ends since last minimization.\n\n\n\n🔢 plusend_num_notminimized\n\n\nread(fid[\"filaments/1/plusend_num_notminimized\"])\n\n2-element Vector{Int32}:\n 0\n 0\n\n\nNumber of newly added monomers to the filament plus ends since last minimization.\n\n\n\n🔢 num_cylinders\n\n\nread(fid[\"filaments/1/num_cylinders\"])\n\n2-element Vector{Int32}:\n 1\n 1\n\n\nNumber of cylinders per filament.\n\n\n\n🔢 num_monomers\n\n\nread(fid[\"filaments/1/num_monomers\"])\n\n2-element Vector{Int32}:\n 9\n 9\n\n\nNumber of monomers per filament.\n\n\n\n🔢 node_mids\n\n\nread(fid[\"filaments/1/node_mids\"])\n\n2-element Vector{Int32}:\n 1\n 1\n\n\nThe monomer ids at the minus ends of the cylinders.\n                                   |\n                        -----+-----|-----+-----\n    minus end <----       M  |  M  | (M) |  M        ----> plus end\n                        -----+-----|-----+-----\n                                   |\n                                   ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\n\n\n\n🔢 nodepositions\n\n\nread(fid[\"filaments/1/nodepositions\"])\n\n4×3 Matrix{Float64}:\n 470.0  200.0  200.0\n 560.0  200.0  200.0\n 480.0  201.0  200.0\n 570.0  201.0  200.0\n\n\nEach row is a node position in nm.\n\n\n\n🔢 monomerstates\n\n\nread(fid[\"filaments/1/monomerstates\"])\n\n18-element Vector{UInt8}:\n 0x01\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x05\n 0x01\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x05\n\n\nMonomer states.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlinkers\n\n\n\n\n\nThere is a subgroup for each linker type with at least one linker. The subgroups are named by their linker type id. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nnum_linkers\n\n\nattrs(fid[\"linkers/1\"])[\"num_linkers\"]\n\n2\n\n\nNumber of linkers of this type.\n\n\n\n\n\n\n\n\n\n\n\n\n📂 endnames\n\n\n\n\n\nThe pairs of monomers that the linkers are linked between. The monomer pairs are directed and unique.\n\n\n🔢 minusend/ftid\n\n\nread(fid[\"linkers/1/endnames/minusend/ftid\"])\n\n2-element Vector{Int64}:\n 1\n 1\n\n\nMinus end filament type id.\n\n\n\n🔢 minusend/fid\n\n\nread(fid[\"linkers/1/endnames/minusend/fid\"])\n\n2-element Vector{Int64}:\n 1\n 1\n\n\nMinus end filament id.\n\n\n\n🔢 minusend/mid\n\n\nread(fid[\"linkers/1/endnames/minusend/mid\"])\n\n2-element Vector{Int64}:\n 2\n 2\n\n\nMinus end monomer id.\n\n\n\n🔢 plusend/ftid\n\n\nread(fid[\"linkers/1/endnames/plusend/ftid\"])\n\n2-element Vector{Int64}:\n 1\n 1\n\n\nPlus end filament type id.\n\n\n\n🔢 plusend/fid\n\n\nread(fid[\"linkers/1/endnames/plusend/fid\"])\n\n2-element Vector{Int64}:\n 1\n 2\n\n\nPlus end filament id.\n\n\n\n🔢 plusend/mid\n\n\nread(fid[\"linkers/1/endnames/plusend/mid\"])\n\n2-element Vector{Int64}:\n 2\n 2\n\n\nPlus end monomer id.\n\n\n\n\n\n\n\n📂 state\n\nDefault: default linkerstate\nSee MEDYAN.chem_setlinkerstate! and MEDYAN.LinkerState\nThe state of a linker, organized in a nested struct of vector like form. Any static arrays will be unwrapped into a tuple of vectors, in column major order. The “name” attribute of each subgroup and dataset is the corresponding property name in the StructArray Any property in the default state that isn’t in the snapshot will stay at its default value.\n\nfid[\"linkers/1/state\"]\n\n📂 HDF5.Group: /linkers/1/state (file: /tmp/jl_TMzG72XWlU)\n├─ 📂 1\n│  ├─ 🏷️ name\n│  ├─ 🔢 1\n│  │  └─ 🏷️ name\n│  └─ 🔢 2\n│     └─ 🏷️ name\n├─ 📂 2\n│  ├─ 🏷️ name\n│  └─ 📂 1\n│     ├─ 🏷️ name\n│     ├─ 🔢 1\n│     │  └─ 🏷️ name\n│     ├─ 🔢 2\n│     │  └─ 🏷️ name\n│     └─ 🔢 3\n│        └─ 🏷️ name\n└─ 🔢 3\n   └─ 🏷️ name\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmechboundary\n\n\n\n\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.set_mechboundary!\n\n\n🔢 capsules\n\n\nread(fid[\"mechboundary/capsules\"])\n\n8×1 Matrix{Float64}:\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n 10000.0\n     1.0\n\n\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 planes\n\n\nread(fid[\"mechboundary/planes\"])\n\n4×6 Matrix{Float64}:\n -10.0     10.0    0.0     0.0    0.0     0.0\n   0.0      0.0  -10.0    10.0    0.0     0.0\n   0.0      0.0    0.0     0.0  -10.0    10.0\n   0.0  20000.0    0.0  5000.0    0.0  5000.0\n\n\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nmembranes\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nnum_membranes\n\n\nattrs(fid[\"membranes\"])[\"num_membranes\"]\n\n1\n\n\nTotal number of membranes.\n\n\n\nposition_scale\n\n\nattrs(fid[\"membranes\"])[\"position_scale\"]\n\n3\n\n\nDefault: No effect\nPositions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\nThere is a subgroup for each membrane. The subgroups are named by the membrane index. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\ntype_id\n\n\nattrs(fid[\"membranes/1\"])[\"type_id\"]\n\n1\n\n\nThis membrane’s type id.\n\n\n\n\n\n\n\n🔢 trilist\n\n\nread(fid[\"membranes/1/trilist\"])\n\n3×404 Matrix{Int64}:\n  46   52  139   23  75   47  92  133  …   99  154   62   20   17  130  109\n 103  200  178  170  51   53  15  180      38   34   28   36  135  164  164\n  31  121   67  125  60  145  65    3     163  124  138  175   57   80  162\n\n\nEach column is the 3 vertex indexes of a triangle. Indexes are one based, and follow the right hand rule. Looking at the triangle from the outside in, they have counterclockwise winding.\n\n\n\n🔢 vertlist\n\n\nread(fid[\"membranes/1/vertlist\"])\n\n3×204 Matrix{Float64}:\n 1335.88  1429.25  1688.25  1664.0   …  1522.25  1343.62  1418.25  1314.88\n 1572.12  1588.75  1450.88  1476.5      1675.62  1453.0   1562.62  1474.25\n 1580.62  1341.25  1484.88  1395.62     1582.75  1607.25  1666.38  1441.62\n\n\nEach column is a vertex coordinate in nm.\n\n\n\n🔢 id\n\n\nread(fid[\"membranes/1/id\"])\n\n204-element Vector{Int64}:\n 12443\n  4955\n  9000\n   923\n  9968\n  6259\n  3241\n  8395\n 11372\n 10072\n  4342\n  3403\n 12414\n     ⋮\n   340\n  5714\n  4879\n  2298\n  6004\n  4560\n  2196\n 12571\n  7160\n 12884\n  3266\n  7764\n\n\nArray of vertex IDs. Each vertex has an id which is assigned upon initialization and persists throughout its lifetime."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "src/sysdefs.jl\n\nMEDYAN.StateDef\nMEDYAN.SysDef\naddreaction!\naddreactioncallback!\naddfilamentsite!\naddfilament_reaction!\naddfilamentendsite!\naddfilamentend_reaction!\naddlinker!\n\n\n\n\n\nMEDYAN.Context\ndeepcopy, note: rng is shared\n\n\n\n\n\nBase.empty!\nload_snapshot!\nchem_newfilament!\nchem_removefilament!\nchem_polymerize!\nchem_depolymerize!\nchem_setmonomerstate!\nchem_newlinker!\nchem_removelinker!\nchem_setlinkerstate!\nchem_adddiffusingcount!\nchem_addfixedcount!\nadddiffusingcount_rand!\nnewfilament_rand!\nset_time!\nset_enable_cylinder_volume_exclusion!\nset_chemboundary!\nset_mechboundary!\n\n\n\n\n\nnum_filtypes\nfiltype_fil_ids\nfil_node_positions\nfil_node_mon_ids\nfil_mon_states\nmon_exists\nmon_minimized\nmon_position\nmon_plusvector\nmon_position_plusvector\nmon_3states\n\n\n\n\n\nrun_chemistry!\nminimize_energy!\n\n\n\n\n\n\n\n\n\n\nfilament sites\nfilament end sites\nlinker sites\nlinkable sites"
  },
  {
    "objectID": "reference/sitesinfo.html",
    "href": "reference/sitesinfo.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Abstractly, sites are an interface that allow more complex structures like filaments to interact with diffusing species and compartment reaction propensities.\nEach site type has an associated fixed species. During chemistry that fixed species count will always be the total counts of the site in the compartment.\nChemistry callbacks can try and pick a random site in a compartment to get specific information about exactly where in a compartment some event should happen.\nThese are the groups of sites currently in MEDYAN.jl:\n\n\nFilament sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament site.\n\n\nHow many monomer states in the plus direction this site looks at.\n\n\n\nHow many monomer states in the minus direction this site looks at.\n\n\n\nReturn site count at a monomer given states, A vector of MonomerState with length length(states) == getminusrange(filamentsite) + 1 + getplusrange(filamentsite)\nThe site count gets put in the compartment of the center monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomfilamentsite function\nMEDYAN.Context#filamentsites field\n\n\n\nMEDYAN.SysDef#filamentsite field\nMEDYAN.addfilamentsite! function\nMEDYAN.addfilament_reaction! function\n\n\n\n\n\nFilament end sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament end site.\n\n\nHow many monomer states this site looks at.\n\n\n\nTrue if the filament end site is on the minus end, false if on the plus end.\n\n\n\nReturn spacing needed for the filament end site reaction to happen, units of nm.\n\n\n\nReturn the filament end site count at the end of a filament with monomer states vector states The rate of filament end reaction will be modified by the brownian ratchet model:\nexp(-β*F*L) where F is the compression force on the filament end, and L is spacing(site).\nlength(states) == getrange(filamentendsite)\nThe site count gets put in the compartment of the end monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomfilamentendsite\nMEDYAN.Context#filamentendsites field\n\n\n\nMEDYAN.SysDef#filamentendsite field\nMEDYAN.addfilamentendsite!\nMEDYAN.addfilamentend_reaction!\n\n\n\n\n\nLinker sites can only be associated with one linker type. They can represent propensities for reactions to happen to a linker attached to two monomers, like unbinding or motor walking, or a site for a diffusing species to interact with a bound linker.\n\n\nA type T must implement the following functions to be a linker site.\n\n\nReturn the site count given the state of the linker, the minusftid, plusftid filament type ids, the minusmonomerstates, plusmonomerstates monomer states, and the positions and orientations of the two monomers.\nminusmonomerstates and plusmonomerstates should be collections of 3 MonomerState ordered from minus to plus end, with the linker attached to the center monomer.\nIf a monomer doesn’t exist, its state should be input as zero.\nThe site count gets put in the compartment of the minus end of the linker.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomlinkersite\nMEDYAN.Context#linkersites field\n\n\n\nMEDYAN.SysDef#linkersite field\nMEDYAN.addlinkersite!\n\n\n\n\n\nLinkable sites represent a potential link between two monomers, potentially on two different filaments. The site count is added to the compartment of the potential monomer that could attach to the minus end of the linker.\n\n\nA type T must implement the following functions to be a linkable site.\n\n\nReturn the maximum distance in nm of a linkable site.\n\n\n\nReturn the maximum linkablesitecount will return given a pair of monomers in linkable range.\n\n\n\nReturn if two monomers are in range to possibly link in the forward direction, and if they are in range to possibly link in the reverse direction.\n\n\n\nReturn the filament types of the minus and plus monomers.\n\n\n\nReturn the monomer step size starting with mid 0 in the search for potential linkable sites on the minus and plus ends respectively.\n1 searches every monomer. 2 searches every monomer with even mid …\nIf the plus and minus filament types are the same, then getmidsteps(site)[1] == getmidsteps(site)[2]\n\n\n\nReturn the site count of two monomers getting linked given their states, their positions, and their plus vectors. The monomers can be assumed to be in linkable range, from the correct filament types, and at the correct step.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomlinkablesite\nMEDYAN.Context#linkablesites field\n\n\n\nMEDYAN.SysDef#linkablesite field\nMEDYAN.addlinkablesite!"
  },
  {
    "objectID": "docstrings.html",
    "href": "docstrings.html",
    "title": "Docstrings",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\n\n\n\n\nBase.:*\n\n\n\n\nBase.copy\n\n\n\n\nBase.delete!\n\n\n\n\nBase.empty!\n\n\n\n\nBase.getindex\n\n\n\n\nBase.haskey\n\n\n\n\nBase.iterate\n\n\n\n\nBase.length\n\n\n\n\nBase.push!\n\n\n\n\nBase.setindex!\n\n\n\n\nMEDYAN.CadherinParams\n\n\n\n\nMEDYAN.CadherinState\n\n\n\n\nMEDYAN.CubicGrid\n\n\n\n\nMEDYAN.FilamentEndSiteGeneral\n\n\n\n\nMEDYAN.FilamentSiteGeneral\n\n\n\n\nMEDYAN.LinkableSiteMinAngleRange\n\n\n\n\nMEDYAN.LinkableSiteRange\n\n\n\n\nMEDYAN.LinkerParams\n\n\n\n\nMEDYAN.LinkerSiteCount\n\n\n\n\nMEDYAN.LinkerSiteMonomerStateMatch\n\n\n\n\nMEDYAN.LinkerSiteMotorCatch\n\n\n\n\nMEDYAN.LinkerSiteMotorStall\n\n\n\n\nMEDYAN.LinkerSiteOne\n\n\n\n\nMEDYAN.LinkerSiteSlipBond\n\n\n\n\nMEDYAN.LinkerState\n\n\n\n\nMEDYAN.MembraneSiteDiffusing\n\n\n\n\nMEDYAN.MembraneSpeciesParams\n\n\n\n\nMEDYAN.MonomerName\n\n\n\n\nMEDYAN.VertexName\n\n\n\n\nMEDYAN.adapt_membranes!\n\n\n\n\nMEDYAN.add_membranesitereaction!\n\n\n\n\nMEDYAN.addcadherin!\n\n\n\n\nMEDYAN.addcadherinsite!\n\n\n\n\nMEDYAN.adddiffusingcount_rand!\n\n\n\n\nMEDYAN.addfilament_reaction!\n\n\n\n\nMEDYAN.addfilamentend_reaction!\n\n\n\n\nMEDYAN.addfilamentendsite!\n\n\n\n\nMEDYAN.addfilamentsite!\n\n\n\n\nMEDYAN.addlinkablesite!\n\n\n\n\nMEDYAN.addlinker!\n\n\n\n\nMEDYAN.addlinkersite!\n\n\n\n\nMEDYAN.addmembranediffusingcount_rand!\n\n\n\n\nMEDYAN.addmembranesite!\n\n\n\n\nMEDYAN.addpossiblecadherinsite!\n\n\n\n\nMEDYAN.addreaction!\n\n\n\n\nMEDYAN.addreactioncallback!\n\n\n\n\nMEDYAN.addunbindinglinkersite!\n\n\n\n\nMEDYAN.chem_adddiffusingcount!\n\n\n\n\nMEDYAN.chem_addfixedcount!\n\n\n\n\nMEDYAN.chem_depolymerize!\n\n\n\n\nMEDYAN.chem_newfilament!\n\n\n\n\nMEDYAN.chem_newlinker!\n\n\n\n\nMEDYAN.chem_polymerize!\n\n\n\n\nMEDYAN.chem_removefilament!\n\n\n\n\nMEDYAN.chem_removelinker!\n\n\n\n\nMEDYAN.chem_setlinkerstate!\n\n\n\n\nMEDYAN.chem_setmonomerstate!\n\n\n\n\nMEDYAN.fil_mon_states\n\n\n\n\nMEDYAN.fil_node_mon_ids\n\n\n\n\nMEDYAN.fil_node_positions\n\n\n\n\nMEDYAN.filtype_fil_ids\n\n\n\n\nMEDYAN.load_snapshot!\n\n\n\n\nMEDYAN.minimize_energy!\n\n\n\n\nMEDYAN.mon_3states\n\n\n\n\nMEDYAN.mon_exists\n\n\n\n\nMEDYAN.mon_minimized\n\n\n\n\nMEDYAN.mon_plusvector\n\n\n\n\nMEDYAN.mon_position\n\n\n\n\nMEDYAN.mon_position_plusvector\n\n\n\n\nMEDYAN.newfilament_rand!\n\n\n\n\nMEDYAN.newmembrane!\n\n\n\n\nMEDYAN.num_filtypes\n\n\n\n\nMEDYAN.run_chemistry!\n\n\n\n\nMEDYAN.set_chemboundary!\n\n\n\n\nMEDYAN.set_enable_cylinder_volume_exclusion!\n\n\n\n\nMEDYAN.set_mechboundary!\n\n\n\n\nMEDYAN.set_time!\n\n\n\n\nNLSolversBase.value!!\n\n\n\n\nsrc/auxprocs.jl\n\n\n\n\nsrc/context.jl\n\n\n\n\nsrc/filamentendsites.jl\n\n\n\n\nsrc/filamentsites.jl\n\n\n\n\nsrc/grids.jl\n\n\n\n\nsrc/linkablesites.jl\n\n\n\n\nsrc/linkersites.jl\n\n\n\n\nsrc/membrane/membranesites.jl\n\n\n\n\nsrc/minimize_energy.jl\n\n\n\n\nsrc/sysdefs.jl\n\n\n\n\nsrc/trajectory-io/snapshot.jl\n\n\n\n\nsrc/util/math/cuboidslicing.jl\n\n\n\n\n\nsrc/util/stableindex.jl\n\n\n\n\n\n\nNo matching items"
  }
]