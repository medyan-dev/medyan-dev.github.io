[
  {
    "objectID": "tutorials/2rdme.html",
    "href": "tutorials/2rdme.html",
    "title": "2. Rock Paper Scissors Stochastic Reaction Diffusion",
    "section": "",
    "text": "Inspired by:\nhttps://www.youtube.com/watch?v=TORwMc2AaRE&t=0s\n\n\nOpen a julia REPL or jupyter notebook using the medyan-tutorial environment you created in tutorial 1.\nLoad MEDYAN with MeshCat for visualization\n\nusing MEDYAN\nusing MeshCat\nusing CairoMakie\nusing Random\nusing StorageTrees\nRandom.seed!(1234);\n\n\n\n\nThe first step is declaring the names of agents in the system.\nThis system will contain three diffusing species.\n\nagent_names = MEDYAN.AgentNames(;\n    diffusingspeciesnames=[\n        :R, # Rock\n        :P, # Paper\n        :S, # Scissors\n    ],\n)\n\nMEDYAN.AgentNames([:R, :P, :S], Symbol[], Symbol[], Symbol[], Tuple{Symbol, Vector{Symbol}}[], Symbol[], Symbol[], Symbol[])\n\n\n\n\n\nAfter the agent names are declared, the system can be defined.\nThis is done by constructing a MEDYAN.SysDef object from the agent_names and then mutating it to add parameters, reactions, and callbacks.\n\ns = MEDYAN.SysDef(agent_names)\n\nMEDYAN.SysDef\n Diffusing species:\n  R: 0.0 nm²/s\n  P: 0.0 nm²/s\n  S: 0.0 nm²/s\n\n\nAdd a diffusion coefficient of 1E6 nm²/s to all species. All units are based on nm, s, pN\nadd_diffusion_coeff!\n\nD = 1E6\nadd_diffusion_coeff!(s, :R, D) # nm²/s\nadd_diffusion_coeff!(s, :P, D) # nm²/s\nadd_diffusion_coeff!(s, :S, D) # nm²/s\n\nMEDYAN.SysDef\n Diffusing species:\n  R: 1.0e6 nm²/s\n  P: 1.0e6 nm²/s\n  S: 1.0e6 nm²/s\n\n\nAdd reactions, paper “beats” rock, scissors “beats” paper, rock “beats” scissors. In this simulation “beats” means convert to self type.\nIn this case because the reaction is between two diffusing species, it has units of nm³/s. You can think of this as the volume where if exactly one of each each reactant existed the rate would be 1 per second.\naddreaction!\n\nrate = 50.0*(500.0^3) # nm³/s\naddreaction!(s,\n    \"diffusing.P + diffusing.R --> 2diffusing.P\",\n    rate,\n    1,\n)\naddreaction!(s,\n    \"diffusing.S + diffusing.P --> 2diffusing.S\",\n    rate,\n    1,\n)\naddreaction!(s,\n    \"diffusing.R + diffusing.S --> 2diffusing.R\",\n    rate,\n    1,\n)\n\nMEDYAN.SysDef\n Diffusing species:\n  R: 1.0e6 nm²/s\n  P: 1.0e6 nm²/s\n  S: 1.0e6 nm²/s\n Compartment reactions without callbacks:\n  \"diffusing.P + diffusing.R --> 2diffusing.P\" 6.25e9 nm³/s\n  \"diffusing.S + diffusing.P --> 2diffusing.S\" 6.25e9 nm³/s\n  \"diffusing.R + diffusing.S --> 2diffusing.R\" 6.25e9 nm³/s\n\n\n\n\n\nAll simulations run in a grid.\nThis is a box that contains the simulation.\nThe grid is composed of chemistry voxels, small cubes that can have different counts of the various diffusing species.\nCreate a 50 by 50 by 1 grid of 500 nm side length voxels.\n\nL = 50\ngrid = CubicGrid((L,L,1),500.0)\n\nCubicGrid([50, 50, 1], 500.0)\n\n\n\n\n\nThe Context is the object the handles the state of a running simulation.\nCreate a Context using s and grid\n\nc = MEDYAN.Context(s, grid)\n\nMEDYAN.Context at time 0.0s in CubicGrid([50, 50, 1], 500.0)\n\n\n\n\n\nThe context starts empty.\nDistribute 2000 of each species randomly to the chem voxels by mutating the context.\nadddiffusingcount_rand!\n\nadddiffusingcount_rand!(c, s.diffusing.R, 2000)\nadddiffusingcount_rand!(c, s.diffusing.P, 2000)\nadddiffusingcount_rand!(c, s.diffusing.S, 2000)\n\n\n\n\nRun chemistry for 1.0s and visualize the results.\n\nvis = Visualizer()\nsetvisible!(vis[\"/Grid\"], false)\nsetvisible!(vis[\"/Axes\"], false)\nsetvisible!(vis[\"/Background\"], false)\n\nIf you open the visualizer in a browser and run the following you should get an animated version of below.\n\nfor i in 1:100\n    run_chemistry!(c, 0.01)\n    MEDYAN.drawdiffusing!(vis[\"diffusing\"], c.grid, c.chemistryengine, s; size = 0.8)\n    sleep(0.02)\nend\n\n\n\n\n    \n    \n    \n    \n\n\n\n\n\nNext we will see how to plot quantities from the simulation.\nIf you want to analyze a trajectory in detail, or load a system state, one method is to use snapshots. For details see snapshot group reference\nMEDYAN.load_snapshot! can be used to reload snapshots, this is very useful for restarting simulations, or changing the simulation state in a different programming language, but not needed in this tutorial.\nStorageTrees.jl can be used to save/load snapshot groups to/from disk, in zip files, or in directories.\nRun chemistry for another 1.0s and store a snapshot every 0.01s in a vector.\n\nusing StorageTrees\nsnapshots = ZGroup[]\nfor i in 1:100\n    run_chemistry!(c, 0.01)\n    push!(snapshots, MEDYAN.snapshot(c))\nend\n\nNow that the simulation is done the results can be analyzed. For longer simulations, these snapshots should be saved to disk with for example:\nStorageTrees.save_dir(\"snapshot$i.zarr.zip\",MEDYAN.snapshot(c))\nto avoid needed to rerun the simulation and to avoid using too much RAM.\n\ntotal_rocks = Int[]\ntotal_papers = Int[]\ntotal_scissors = Int[]\ntimes = Float64[]\nfor group in snapshots\n    totals = sum(collect(group[\"diffusingcounts\"]);dims=2)\n    push!(times, attrs(group)[\"time (s)\"])\n    push!(total_rocks, totals[s.diffusing.R])\n    push!(total_papers, totals[s.diffusing.P])\n    push!(total_scissors, totals[s.diffusing.S])\nend\n\n\nfigure, axis, lineplot = lines(times, total_rocks; label=\"rock\")\nlines!(times, total_papers; label=\"paper\")\nlines!(times, total_scissors; label=\"scissors\")\nlines!(\n    times,\n    total_scissors.+total_papers.+total_rocks;\n    label=\"combined\")\naxislegend()\ncurrent_figure()\n\n\n\n\nIf you are using VSCode or Jupyter the figure will be displayed.\nIf you are using the REPL, save the figure as a PDF to view it.\nsave(\"tutorial2-plot.pdf\", current_figure())"
  },
  {
    "objectID": "tutorials/1install.html",
    "href": "tutorials/1install.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "MEDYAN.jl is a julia package so first install the julia programming language.\nThis tutorial was generated using:\n\n\nJulia Version 1.8.5\nCommit 17cfb8e65ea (2023-01-08 06:45 UTC)\nPlatform Info:\n  OS: Linux (x86_64-linux-gnu)\n  CPU: 2 × Intel(R) Xeon(R) Platinum 8272CL CPU @ 2.60GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-13.0.1 (ORCJIT, skylake-avx512)\n  Threads: 1 on 2 virtual cores\n\n\nThe tutorials should work on newer versions of julia, and on MacOS and Windows, please create an issue if you have a problem or question.\nJulia can be installed with juliaup.\nYou can also download julia here.\nDo not install julia using apt install julia or module load julia, as these don’t have a recent version of julia.\nAfter installing julia, open the REPL with the julia command in terminal.\nThen type ] to enter pkg mode.\nNext type add Revise and press enter to add the Revise package from the general registry.\nYou can also run:\nusing Pkg; pkg\"add Revise\"\nNext setup your startup.jl file. This file runs when you start julia.\nconfigpath = mkpath(joinpath(DEPOT_PATH[1], \"config\"))\nopen(joinpath(configpath, \"startup.jl\"), \"a\") do f\n    print(f, \"\"\"\n    try\n        using Revise\n    catch e\n        @warn \"Error initializing Revise\" exception=(e, catch_backtrace())\n    end\n\n    ENV[\"JULIA_PKG_USE_CLI_GIT\"]= \"true\"\n    \"\"\")\nend\nFinally close and restart the julia REPL for the next section.\n\n\n\nFirst add the required registries in julia\nusing Pkg\npkg\"registry add https://github.com/medyan-dev/MEDYANRegistry.git\"\npkg\"registry add https://github.com/JuliaRegistries/General\"\nIf you don’t have ssh keys set up with GitHub, follow these directions:\nhttps://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\nYou will also need read access to https://github.com/medyan-dev/MEDYAN.jl because it is currently a private repository.\n\n\n\nDownload the exact julia environment used to generate the tutorials.\nClick to Download\nNext extract this zip file and cd into the extracted directory.\nNow run\njulia --project -e 'import Pkg; Pkg.instantiate()'\nTo start the julia REPL in the correct environment to run the tutorials, use:\njulia --project\nFrom inside the medyan-tutorial directory.\nYou can also save julia files in this directory and use the VSCode julia extension to set the environment, and run code blocks, if you prefer that over the REPL.\nIf you have issues installing:\n\nMake sure your ssh key has been added to the ssh agent.\nMake sure you can git clone git@github.com:medyan-dev/MEDYAN.jl.git\nTry ENV[\"JULIA_PKG_USE_CLI_GIT\"]= \"false\" instead of \"true\" in your startup.jl\n\n\n\n\nThese tests may take a few minutes to run.\nusing Pkg\npkg\"test MEDYAN\"\nIf you have any errors or failing tests create an issue\n\n\n\nIt may be convenient to run these tutorials in VSCode with the julia extension.\nhttps://code.visualstudio.com/docs/languages/julia"
  },
  {
    "objectID": "docstrings/medyan.mon_plusvector-b7271c7721602813.html",
    "href": "docstrings/medyan.mon_plusvector-b7271c7721602813.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_plusvector(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> StaticArraysCore.SVector{3, Float64}\nReturn the unit vector toward the plus end of the filament."
  },
  {
    "objectID": "docstrings/medyan.sever_filament--a0475617dc0fbf93.html",
    "href": "docstrings/medyan.sever_filament--a0475617dc0fbf93.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "sever_filament!(c::Context, mon_name::MonomerName)::Int\nReturn the new filament id of the minus end filament.\nCalling this will invalidate the chem cache.\nThe split will happen between mon_name and the monomer slightly towards the minus end.\nThe plus end will keep the same fil_id, the minus end will get a new fil_id.\nThe split cannot create a filament with less than 2 monomers."
  },
  {
    "objectID": "docstrings/medyan.set_chemboundary--0aa6e4e95c60f9f7.html",
    "href": "docstrings/medyan.set_chemboundary--0aa6e4e95c60f9f7.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_chemboundary!(c::MEDYAN.Context; meshindex_as_chemboundary, kwargs...) -> MEDYAN.Boundary\nSet chemical boundary and update compartment volumes and diffusion rates. Note, the chemboundary should be outside the mechboundary so that it is rare for filaments to go outside the chemboundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the chemical boundary of the simulation\ninside = signbit(pos ⋅ planes[bi][1:3] - planes[bi][4])\nFor example, a plane [1,0,0,3] is inside if x < 3 nm.\n2.0*[1,0,0,3] is also inside if x < 3 nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the chemical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is ignored.\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\n\nmeshindex_as_chemboundary::Int = 0: Index of membrane mesh that further restricts the chem boundary. 0 for none.\n\nThe system geometry information must be up-to-date. This mesh index is not stored in the boundary object, but is directly set in the context."
  },
  {
    "objectID": "docstrings/base.delete--56ef520341df3c06.html",
    "href": "docstrings/base.delete--56ef520341df3c06.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Remove a recorded index at ID."
  },
  {
    "objectID": "docstrings/medyan.compute_all_membrane_geometry-_system-05b4d2a32e31560c.html",
    "href": "docstrings/medyan.compute_all_membrane_geometry-_system-05b4d2a32e31560c.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Updates all membrane geometries used across various parts of MEDYAN.\nThe list of all items can be found in the document for MEDYAN.compute_geometry!_system function.\nKeyword parameters:\n\ninclude_ff::Bool: If true, compute_geometry! used in energy computations will be applied as well, requiring vectorization of the membrane. This happens before system geometry computation in case some fields are overriden."
  },
  {
    "objectID": "docstrings/medyan.monomername-bb517706cb60c4f5.html",
    "href": "docstrings/medyan.monomername-bb517706cb60c4f5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "ftid::Int64\nfilament type id\nfid::Int64\nfilament id\nmid::Int64\nmonomer id"
  },
  {
    "objectID": "docstrings/medyan.defer_chem_caching--9538a1c449f3da93.html",
    "href": "docstrings/medyan.defer_chem_caching--9538a1c449f3da93.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "defer_chem_caching!(c::Context)::Nothing\nThis should only be used for advanced optimizations.\nDuring chemistry, the context mutating functions will typically try to avoid invalidating various cached data needed to quickly sample sites.\nHowever, if you want to mutate the context outside of chemistry, for example right before or after minimization, you may not want to pay the cost of revalidating all the caches because minimization will already invalidate the caches. Caching will be enabled again and caches will be made valid the next time chemistry is run. Caching can also be manually refreshed and reenabled with: refresh_chem_cache!"
  },
  {
    "objectID": "docstrings/medyan.membranesitediffusing-66734014eb12ddb1.html",
    "href": "docstrings/medyan.membranesitediffusing-66734014eb12ddb1.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Allows up to 1 membrane diffusing species as reactants. Also stores net stoich of membrane diffusing species.\n\nid_membranediffusing_reactant::Int64\nSet to 0 if no membrane diffusing species is involved.\ncanchangerate_bypotentialenergy::Bool\nWhether the reaction rate depends on reactant species potential energy.\nmembranediffusingnet_stoich::Vector{Pair{Int64, Int64}}\nPairs of membrane diffusing species index => Δcount"
  },
  {
    "objectID": "docstrings/medyan.adapt_membranes--1d26092defd0f4fa.html",
    "href": "docstrings/medyan.adapt_membranes--1d26092defd0f4fa.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Remesh all membrane meshes."
  },
  {
    "objectID": "docstrings/base.haskey-e7d3f961991e2663.html",
    "href": "docstrings/base.haskey-e7d3f961991e2663.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Whether an ID is in use."
  },
  {
    "objectID": "docstrings/medyan.chem_removelink_2mon--e25a3fd69f791cd0.html",
    "href": "docstrings/medyan.chem_removelink_2mon--e25a3fd69f791cd0.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_removelink_2mon!(c::Context, ltid::Int, lid::Int64)\nRemove a link_2mon of type id ltid with id lid.\nError if the specified link_2mon doesn’t exist.\nDon’t modify monomer states."
  },
  {
    "objectID": "docstrings/medyan.refresh_chem_cache--f90ebca1f896ad2c.html",
    "href": "docstrings/medyan.refresh_chem_cache--f90ebca1f896ad2c.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "refresh_chem_cache!(c::Context)::Nothing\nNormally this isn’t needed as it will happen automatically."
  },
  {
    "objectID": "docstrings/medyan.addfilament_reaction--63195cbff2ab4237.html",
    "href": "docstrings/medyan.addfilament_reaction--63195cbff2ab4237.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add filament reaction. Return s. Add a filamentsite and reaction with callback to change the monomer state. This can be used for filament aging, filament catalyzed reactions, or simple binding reactions.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentsitename::Symbol: the new name of the filamentsite added. This can be used as a catalyst in other reactions.\nchangedstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the monomer states, the first is the states to match. The second is the new monomer states after the reaction. both should be the same length. Ordered minus end first.\ncenter::Int: Which index of changedstatenames.first is the actual location of the filamentsite. Used for determining what compartment the reaction goes in.\nreactantexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentsite.$(filamenttypename).$(filamentsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nagentnames = AgentNames(\n    filamentnames= [(:filname,[\n                            :a,\n                            :b,\n                            :c,\n                        ]),\n    ],\n)\ns= SysDef(agentnames)\naddfilament_reaction!(s, :filname, :ab,\n    [:a]=>[:b], 1,\n    \"-->\", 1.75E-3, 0,\n)\naddfilament_reaction!(s, :filname, :aabc,\n    [:a,:a]=>[:b,:c], 2,\n    \"-->\", 1.75E-3, 0,\n)"
  },
  {
    "objectID": "docstrings/medyan.link2monsitemonomerstatematch-c495443de74016ce.html",
    "href": "docstrings/medyan.link2monsitemonomerstatematch-c495443de74016ce.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Returns 1.0 if the monomer states match, otherwise, returns 0.0.\n\nminusstate::Tuple{UInt8, UInt8, UInt8}\nminus end monomer state\nplusstate::Tuple{UInt8, UInt8, UInt8}\nplus end monomer state"
  },
  {
    "objectID": "docstrings/medyan.resolve_all_filament_mesh_crossing--a8be83a7d2ad65c7.html",
    "href": "docstrings/medyan.resolve_all_filament_mesh_crossing--a8be83a7d2ad65c7.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Given an AABB tree corresponding to up-to-date membrane mesh triangles, resolve all filament-membrane intersections.\nRequires\n\nup-to-date unit normals of all triangles in the meshes.\nup-to-date AABB tree corresponding to all membrane meshes."
  },
  {
    "objectID": "docstrings/medyan.cubicgrid-fe4b7cc2dceb0431.html",
    "href": "docstrings/medyan.cubicgrid-fe4b7cc2dceb0431.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "CubicGrid(num_voxels::SVector{3,Int}, compartmentsize::Float64)\n\nn::StaticArraysCore.SVector{3, Int64}\ncompartmentsize::Float64"
  },
  {
    "objectID": "docstrings/medyan.add_diffusion_coeff--a77d1ef833cfdedd.html",
    "href": "docstrings/medyan.add_diffusion_coeff--a77d1ef833cfdedd.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "add_diffusion_coeff!(s::SysDef, diffusing_name::Symbol, diffusing_coeff::Float64)\nAdd the diffusing species to the system with diffusion coefficent in units of (nm²/s). Return s."
  },
  {
    "objectID": "docstrings/base.length-7ea31a421de7d258.html",
    "href": "docstrings/base.length-7ea31a421de7d258.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Total number of IDs in use.\n\n\n\n\n\n\n\n\n\n\n\n\nBase.length(grid::CubicGrid)\nTotal number of compartments in the grid"
  },
  {
    "objectID": "docstrings/medyan.link_2mon_endnames-5d0bca4b8e2e3509.html",
    "href": "docstrings/medyan.link_2mon_endnames-5d0bca4b8e2e3509.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "link_2mon_endnames(c::MEDYAN.Context, ltid, lid) -> Pair{MEDYAN.MonomerName, MEDYAN.MonomerName}\nReturn the minusend name => plusend name of the link with type id ltid, and link id lid"
  },
  {
    "objectID": "docstrings/medyan.link2monsiteslipbond-2cec57cbea12864e.html",
    "href": "docstrings/medyan.link2monsiteslipbond-2cec57cbea12864e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Models unbinding rates based on the following exponential form of Bell et al, 1978: min(k0*exp(f/f0), kmax) Where f is the magnitude of the force. So as to exponetially increase the unbinding with more force.\nlink_2mon_sitecount returns the unbinding rate in units of 1/s It returns k0 if the link_2mon hasn’t been minimized yet.\n\nf0::Float64\nThe charicteristic force magnitude. Units of pN\nk0::Float64\nUnbinding rate at zero force. Units of 1/s\nkmax::Float64\nMaximum rate. Units of 1/s"
  },
  {
    "objectID": "docstrings/medyan.chem_newfilament--7a45f2860949bee3.html",
    "href": "docstrings/medyan.chem_newfilament--7a45f2860949bee3.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_newfilament!(c::Context; ftid=1, monomerstates, node_mids, nodepositions)\nReturn the filament id of a new filament.\nError if the filament isn’t initially over 2 monomers long.\nNewly added filaments don’t have linkable sites, until after minimization.\n\n\n\nftid=1: filament type id.\nmonomerstates: Collection of the MonomerState of the monomers in the new filament. In order from minus end to plus end.\nlength(monomerstates)>1\nnodepositions: Collection of SVector{3,Float64}. The positions of the nodes, monomers are between nodes.\nnode_mids: Collection of Integer. The monomer ids at (slightly plus side of) the nodepositions\n                               |\n                    -----+-----|-----+-----\nminus end <----       M  |  M  | (M) |  M        ----> plus end\n                    -----+-----|-----+-----\n                               |\n                               ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\nlength(node_mids) == length(nodepositions) - 1\nendloadforces=(0.0=>0.0): end load forces, usually don’t use this, because load forces will automatically get updated at the next minimization."
  },
  {
    "objectID": "docstrings/medyan.newfilament_rand--432ec27232aad41e.html",
    "href": "docstrings/medyan.newfilament_rand--432ec27232aad41e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "newfilament_rand!(c::Context, monomerstates; iterations = 10^9, ftid = 1)\nAdd a filament with type id ftid to the Context with random center position and direction.\nReturn the filament id of a new filament.\nmonomerstates is a collection of the MonomerState of the monomers in the new filament.\nThe filament will be inside the mech boundary.\nErrors if it fails to add a filament.\nThe monomer are spaced by the value in the filament type’s mechanical parameters."
  },
  {
    "objectID": "docstrings/nlsolversbase.value---d4fdd3b317023c0e.html",
    "href": "docstrings/nlsolversbase.value---d4fdd3b317023c0e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Force (re-)evaluation of the objective value at x. Returns f(x) and stores the value in obj.F also calculates the gradient and stores it in obj.DF"
  },
  {
    "objectID": "docstrings/medyan.filamentsitegeneral-0d87ce44fed17b2c.html",
    "href": "docstrings/medyan.filamentsitegeneral-0d87ce44fed17b2c.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "General filament site just matches monomer states\n\ncenter::Int64\nindex of center monomer in states\nstates::Vector{UInt8}\nmonomer states to match"
  },
  {
    "objectID": "docstrings/medyan.vertexname-2d87a6a86cabc4f5.html",
    "href": "docstrings/medyan.vertexname-2d87a6a86cabc4f5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "membraneindex::Int64\nmembrane index\nvid::Int64\nvertex id"
  },
  {
    "objectID": "docstrings/medyan.link2monsitemotorstall-deb10f7964d5bef9.html",
    "href": "docstrings/medyan.link2monsitemotorstall-deb10f7964d5bef9.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Models myosin walking rates from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the motor work per step increases, its walking rate goes to zero.\nReturns the walking rate of one end. The callback can then sample which end to move, or reject the move.\n\nfs::Float64\nThe stall force magnitude. Units of pN\nk0::Float64\nWalking rate of one end at zero force. Units of 1/s\nα::Float64\nPositive dimensionless parameter defining the steepness of the curve, smaller is more steep, if α is inf, the curve is linear\nwalking_direction::Int32\nMotor walking direction, +1 is towards plus end, -1 is towards minus end\nisminusend::Bool\nwhich motor end does this represent"
  },
  {
    "objectID": "docstrings/medyan.mon_position-83983d8916347411.html",
    "href": "docstrings/medyan.mon_position-83983d8916347411.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_position(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> StaticArraysCore.SVector{3, Float64}\nReturn the monomer position."
  },
  {
    "objectID": "docstrings/medyan.cadherinstate-0cd5353e58a90ec2.html",
    "href": "docstrings/medyan.cadherinstate-0cd5353e58a90ec2.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "There is one instance of this per cadherin.\n\nchemstate::NamedTuple\nOther state.\nmechstate::NamedTuple\nUsed in link_2mon force calculation.\nis_minimized::Bool\nSet to true after minimization"
  },
  {
    "objectID": "docstrings/medyan.addreactioncallback--9c9d46adeded2d88.html",
    "href": "docstrings/medyan.addreactioncallback--9c9d46adeded2d88.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addreactioncallback!(s::SysDef, reaction::CompartmentReaction, callback)::SysDef\naddreactioncallback!(s::SysDef, reactantexpr::AbstractString, rate::Float64, invvolumepower::Int, callback)::SysDef\nLike addreaction! but also adds callback. callback is called when the reaction happens with input of MEDYAN.Context and Int the compartment id where the reaction happened.\nThe reaction should normally have no net stoichiometry because the callback should handle updating species counts. If an AbstractString is passed instead of a CompartmentReaction for the reaction, that string will be parsed to determine the reactants. The net stoichiometry will be zero.\nMEDYAN.errorcheck_addcallback(callback,s::SysDef) can optionally be overloaded to add errorchecking when the callback is added.\n\n\n\n\n\n\n\n\n\n\n\n\nCallback for bulk reactions: Context -> Nothing."
  },
  {
    "objectID": "docstrings/medyan.randompoint-83e939bdee528294.html",
    "href": "docstrings/medyan.randompoint-83e939bdee528294.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "randompoint(grid::CubicGrid,cid)::SVector{3,Float64}\nReturn a random point in a compartment\n\n\n\n\n\n\n\n\n\n\n\n\nrandompoint(grid::CubicGrid)::SVector{3,Float64}\nReturn a random point in the grid"
  },
  {
    "objectID": "docstrings/base.getindex-f593dde852851bc8.html",
    "href": "docstrings/base.getindex-f593dde852851bc8.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Get index at ID."
  },
  {
    "objectID": "docstrings/medyan.cadherinparams-b70febdaf4c8fba5.html",
    "href": "docstrings/medyan.cadherinparams-b70febdaf4c8fba5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Cadherin Parameters, there is one instance of this per cadherin type\n\ndefaultstate::MEDYAN.CadherinState\nmechparams::Any"
  },
  {
    "objectID": "docstrings/medyan.chem_setmonomerstate--ed756af0de4db0ca.html",
    "href": "docstrings/medyan.chem_setmonomerstate--ed756af0de4db0ca.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_setmonomerstate!(c::Context, name::MonomerName, state::MonomerState)\nUpdate a monomer state."
  },
  {
    "objectID": "docstrings/medyan.set_mechboundary--b5e26b6b690256aa.html",
    "href": "docstrings/medyan.set_mechboundary--b5e26b6b690256aa.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_mechboundary!(c::MEDYAN.Context; kwargs...) -> MEDYAN.Boundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the mechanical boundary of the simulation\nE = 1//2 * relu(pos ⋅ planes[bi][1:3] - planes[bi][4])^2\nFor example, a mech bounding plane [1,0,0,3] would try and make x < 3 nm with a spring constant of 1 pN/nm.\n2.0*[1,0,0,3] would try and make x < 3 nm with a spring constant of 4 pN/nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the mechanical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is the spring constant (pN/nm).\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\nE = 1//2*k*relu(d - r0)^2 where:\n\nd is the distance of the point to the spine line segment described by capsules[bi][1:6].\nr0 is capsules[bi][7]\nk is capsules[bi][8]"
  },
  {
    "objectID": "docstrings/medyan.chem_adddiffusingcount--2264be341b81a600.html",
    "href": "docstrings/medyan.chem_adddiffusingcount--2264be341b81a600.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_adddiffusingcount!(c::Context, sid, cid, inccount)\nAdd inccount to diffusing species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/base.empty--418304748816268d.html",
    "href": "docstrings/base.empty--418304748816268d.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Clear all index records.\n\n\n\n\n\n\n\n\n\n\n\n\nempty!(c::Context)\nRemove all filaments, membranes, link_2mons, cadherins, diffusing species, fixed species, bulk species, chemboundary, and mechboundary."
  },
  {
    "objectID": "docstrings/medyan.chem_setlink_2mon_state--82213403237b28e5.html",
    "href": "docstrings/medyan.chem_setlink_2mon_state--82213403237b28e5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_setlink_2mon_state!(c::Context, ltid, lid, link_2mon_state::Link2MonState)\nSet link2monstate of the link_2mon of type id ltid with id lid.\nError if the specified link_2mon doesn’t exist."
  },
  {
    "objectID": "docstrings/medyan.chem_addfixedcount--0286edfebf8ea5e6.html",
    "href": "docstrings/medyan.chem_addfixedcount--0286edfebf8ea5e6.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_addfixedcount!(c::Context, sid, cid, inccount)\nAdd inccount to fixed species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/medyan.sysdef-c0c4da7a2b3d4fef.html",
    "href": "docstrings/medyan.sysdef-c0c4da7a2b3d4fef.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "SysDef(agentnames::AgentNames)\nA mutable struct mapping names to id numbers in a simulation\n\nagentnames::MEDYAN.AgentNames\ndiffusing::MEDYAN.PropDictionary\ndiffusing_coeff::MEDYAN.PropDictionary\nbulkspecies_indexmap::MEDYAN.PropDictionary\nmembranediffusing::MEDYAN.PropDictionary\nfixedspecies::MEDYAN.PropDictionary\nfilament::MEDYAN.PropDictionary\nfilament_params::MEDYAN.PropDictionary\nvertex::MEDYAN.PropDictionary\nstate::MEDYAN.PropDictionary\nlink_2mon::MEDYAN.PropDictionary\nlink_2mon_params::MEDYAN.PropDictionary\ncadherin::MEDYAN.PropDictionary\ncadherinparams::MEDYAN.PropDictionary\nfilamentsite::MEDYAN.PropDictionary\nfilamentendsite::MEDYAN.PropDictionary\nmembranesite::MEDYAN.PropDictionary\nEach membrane site represents the membrane patches in each compartment together with some membrane diffusing species.\nlink_2mon_site::MEDYAN.PropDictionary\nlinkablesite::MEDYAN.PropDictionary\ncadherinsite::MEDYAN.PropDictionary\npossiblecadherinsite::MEDYAN.PropDictionary\nallfixedspeciesnames::Vector{String}\ncompartmentreactions::Vector{MEDYAN.CompartmentReaction}\ncompartmentreactioncallbacks::Vector{Any}\nbulkreactions::Vector{MEDYAN.BulkReaction}\nbulkreactioncallbacks::Vector{Any}\nContext -> Nothing"
  },
  {
    "objectID": "docstrings/medyan.fil_mon_states-3db9714621903b78.html",
    "href": "docstrings/medyan.fil_mon_states-3db9714621903b78.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "fil_mon_states(c::MEDYAN.Context, ftid::Int64, fil_id::Int64) -> OffsetArrays.OffsetVector{UInt8, Vector{UInt8}}\nReturn a read only OffsetVector of monomer states on a filament.\nThis can be invalid after any mutations to context, so copy if needed."
  },
  {
    "objectID": "docstrings/base.---a21e771ed8ea7d6f.html",
    "href": "docstrings/base.---a21e771ed8ea7d6f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "scale the volume and area\n\n\n\n\n\n\n\n\n\n\n\n\nscale the volume and area by different amounts in each direction"
  },
  {
    "objectID": "docstrings/medyan.membranespeciesparams-548fecb643fc2599.html",
    "href": "docstrings/medyan.membranespeciesparams-548fecb643fc2599.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Membrane protein physical parameters.\n\ndiffusion_coeff::Float64\nMembrane diffusion coefficients (nm^2/s).\narea::Float64\nProtein area projected onto the surface (nm^2).\nkbend::Float64\nBending rigidity (pN nm).\neqcurv::Float64\nThe protein’s own spontaneous mean curvature (/nm). Can be used in bending energy computations with curvatures."
  },
  {
    "objectID": "docstrings/medyan.addunbindinglink_2mon_site--76d17dbe625169cd.html",
    "href": "docstrings/medyan.addunbindinglink_2mon_site--76d17dbe625169cd.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add unbinding site, callback, and reaction. Return s.\n\n\n\ns::SysDef: the system to add to.\nlink_2mon_typename::Symbol: the link_2mon type name.\nlink_2mon_sitename::Symbol: the new name of the link_2mon_site added. This can be used as a catalyst in other reactions.\nlink_2mon_site: the link_2mon site to add.\nplusfilamenttypename::Symbol: the filament type name of the plus end.\nplusnewmonomerstatename::Symbol: the new name of the monomer state of the plus end.\nminusfilamenttypename::Symbol: the filament type name of the minus end.\nminusnewmonomerstatename::Symbol: the new name of the monomer state of the minus end.\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + link_2mon_site.$(link_2mon_typename).$(link_2mon_sitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using link_2mon_sitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant."
  },
  {
    "objectID": "docstrings/base.push--8715d52e2302aaeb.html",
    "href": "docstrings/base.push--8715d52e2302aaeb.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add a new index. Returns its ID."
  },
  {
    "objectID": "docstrings/src/link_2mon_sites.html",
    "href": "docstrings/src/link_2mon_sites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Always returns 1.0\n\n\n\n\n\n\n\n\n\n\n\n\nReturns link_2mon_state.chemstate.sitecount\n\n\n\n\n\n\n\n\n\n\n\n\nReturns 1.0 if the monomer states match, otherwise, returns 0.0.\n\nminusstate::Tuple{UInt8, UInt8, UInt8}\nminus end monomer state\nplusstate::Tuple{UInt8, UInt8, UInt8}\nplus end monomer state\n\n\n\n\n\n\n\n\n\n\n\n\n\nModels unbinding rates based on the following exponential form of Bell et al, 1978: min(k0*exp(f/f0), kmax) Where f is the magnitude of the force. So as to exponetially increase the unbinding with more force.\nlink_2mon_sitecount returns the unbinding rate in units of 1/s It returns k0 if the link_2mon hasn’t been minimized yet.\n\nf0::Float64\nThe charicteristic force magnitude. Units of pN\nk0::Float64\nUnbinding rate at zero force. Units of 1/s\nkmax::Float64\nMaximum rate. Units of 1/s\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe catch-bond nature of myosin unbinding with multiple heads. Adopted from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the force increases, the motor unbinding rate decreases to a minimum of k0/10\nlink_2mon_sitecount returns the unbinding rate in units of 1/s It returns k0 if the link2mon hasn’t been minimized yet. It assumes link2monstate.chemstate.numHeads exists for the link2mon.\n\nf0::Float64\nsingle head characteristic unbinding force, units of pN/head\nonRate::Float64\nsingle head binding rate, units of 1/s\noffRate::Float64\nsingle head unbinding rate, units of 1/s\nβ::Float64\nslope of head binding, units of (head)/(pN/head)\n\n\n\n\n\n\n\n\n\n\n\n\n\nModels myosin walking rates from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the motor work per step increases, its walking rate goes to zero.\nReturns the walking rate of one end. The callback can then sample which end to move, or reject the move.\n\nfs::Float64\nThe stall force magnitude. Units of pN\nk0::Float64\nWalking rate of one end at zero force. Units of 1/s\nα::Float64\nPositive dimensionless parameter defining the steepness of the curve, smaller is more steep, if α is inf, the curve is linear\nwalking_direction::Int32\nMotor walking direction, +1 is towards plus end, -1 is towards minus end\nisminusend::Bool\nwhich motor end does this represent"
  },
  {
    "objectID": "docstrings/src/membrane/membranesites.html",
    "href": "docstrings/src/membrane/membranesites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Allows up to 1 membrane diffusing species as reactants. Also stores net stoich of membrane diffusing species.\n\nid_membranediffusing_reactant::Int64\nSet to 0 if no membrane diffusing species is involved.\ncanchangerate_bypotentialenergy::Bool\nWhether the reaction rate depends on reactant species potential energy.\nmembranediffusingnet_stoich::Vector{Pair{Int64, Int64}}\nPairs of membrane diffusing species index => Δcount"
  },
  {
    "objectID": "docstrings/src/grids.html",
    "href": "docstrings/src/grids.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "CubicGrid(num_voxels::SVector{3,Int}, compartmentsize::Float64)\n\nn::StaticArraysCore.SVector{3, Int64}\ncompartmentsize::Float64\n\n\n\n\n\n\n\n\n\n\n\n\n\nBase.length(grid::CubicGrid)\nTotal number of compartments in the grid\n\n\n\n\n\n\n\n\n\n\n\n\ngrididat(grid::CubicGrid,location)\nReturn the grid id of location The origin is in the corner. Returns a close by compartment if out of the grid\n\n\n\n\n\n\n\n\n\n\n\n\nfilter_grididat(f,grid::CubicGrid,location)\nReturn the nearest grid id of location where f(id) evaluates to true. The origin is in the corner. errors if there is no id that evaluates to true. Returns a close by compartment if out of the grid\n\n\n\n\n\n\n\n\n\n\n\n\ncenterof(grid::CubicGrid,cid)\nReturn the location of the center of a grid id The origin is in the corner.\n\n\n\n\n\n\n\n\n\ncenterof(grid::CubicGrid)\nReturn the location of the center the grid The origin is in the corner.\n\n\n\n\n\n\n\n\n\n\n\n\nrandompoint(grid::CubicGrid,cid)::SVector{3,Float64}\nReturn a random point in a compartment\n\n\n\n\n\n\n\n\n\nrandompoint(grid::CubicGrid)::SVector{3,Float64}\nReturn a random point in the grid"
  },
  {
    "objectID": "docstrings/src/minimize_energy.html",
    "href": "docstrings/src/minimize_energy.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Force (re-)evaluation of the objective value at x. Returns f(x) and stores the value in obj.F also calculates the gradient and stores it in obj.DF\n\n\n\n\n\n\n\n\n\n\n\n\nminimize_energy!(c::Context)\nMinimize mechanical energy of the context."
  },
  {
    "objectID": "docstrings/src/sysdefs.html",
    "href": "docstrings/src/sysdefs.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "The names of the agents in a simulation\n\ndiffusingspeciesnames::Vector{Symbol}\nbulkspeciesnames::Vector{Symbol}\nmembranediffusingspeciesnames::Vector{Symbol}\nfixedspeciesnames::Vector{Symbol}\nfilamentnames::Vector{Tuple{Symbol, Vector{Symbol}}}\nvertexnames::Vector{Symbol}\nlink_2mon_names::Vector{Symbol}\ncadherinnames::Vector{Symbol}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nftid::Int64\nfilament type id\nfid::Int64\nfilament id\nmid::Int64\nmonomer id\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmembraneindex::Int64\nmembrane index\nvid::Int64\nvertex id\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere is one instance of this per link_2mon.\n\nchemstate::NamedTuple\nOther state.\nmechstate::NamedTuple\nUsed in link_2mon force calculation.\nis_minimized::Bool\nSet to true after minimization\n\n\n\n\n\n\n\n\n\n\n\n\n\nLink2mon Parameters, there is one instance of this per link2mon type\n\ndefaultstate::MEDYAN.Link2MonState\nmechparams::Any\nno_collide::Bool\nif true, allows cylinders this link_2mon type connects and adjacent cylinders to clip\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere is one instance of this per cadherin.\n\nchemstate::NamedTuple\nOther state.\nmechstate::NamedTuple\nUsed in link_2mon force calculation.\nis_minimized::Bool\nSet to true after minimization\n\n\n\n\n\n\n\n\n\n\n\n\n\nCadherin Parameters, there is one instance of this per cadherin type\n\ndefaultstate::MEDYAN.CadherinState\nmechparams::Any\n\n\n\n\n\n\n\n\n\n\n\n\n\nSysDef(agentnames::AgentNames)\nA mutable struct mapping names to id numbers in a simulation\n\nagentnames::MEDYAN.AgentNames\ndiffusing::MEDYAN.PropDictionary\ndiffusing_coeff::MEDYAN.PropDictionary\nbulkspecies_indexmap::MEDYAN.PropDictionary\nmembranediffusing::MEDYAN.PropDictionary\nfixedspecies::MEDYAN.PropDictionary\nfilament::MEDYAN.PropDictionary\nfilament_params::MEDYAN.PropDictionary\nvertex::MEDYAN.PropDictionary\nstate::MEDYAN.PropDictionary\nlink_2mon::MEDYAN.PropDictionary\nlink_2mon_params::MEDYAN.PropDictionary\ncadherin::MEDYAN.PropDictionary\ncadherinparams::MEDYAN.PropDictionary\nfilamentsite::MEDYAN.PropDictionary\nfilamentendsite::MEDYAN.PropDictionary\nmembranesite::MEDYAN.PropDictionary\nEach membrane site represents the membrane patches in each compartment together with some membrane diffusing species.\nlink_2mon_site::MEDYAN.PropDictionary\nlinkablesite::MEDYAN.PropDictionary\ncadherinsite::MEDYAN.PropDictionary\npossiblecadherinsite::MEDYAN.PropDictionary\nallfixedspeciesnames::Vector{String}\ncompartmentreactions::Vector{MEDYAN.CompartmentReaction}\ncompartmentreactioncallbacks::Vector{Any}\nbulkreactions::Vector{MEDYAN.BulkReaction}\nbulkreactioncallbacks::Vector{Any}\nContext -> Nothing\n\n\n\n\n\n\n\n\n\n\n\n\n\nadd_diffusion_coeff!(s::SysDef, diffusing_name::Symbol, diffusing_coeff::Float64)\nAdd the diffusing species to the system with diffusion coefficent in units of (nm²/s). Return s.\n\n\n\n\n\n\n\n\n\n\n\n\nadd_filament_params!(s::SysDef, filament_name::Symbol, filament_params::FilamentMechParams)\nAdd the filament parameters to the system. Return s.\nSee MEDYAN.FilamentMechParams\n\n\n\n\n\n\n\n\n\n\n\n\nadd_link_2mon!(s::SysDef,link_2mon_typename::Symbol,defaultstate::Link2MonState,mechparams;no_collide=false)\nAdd the link_2mon to the system. Return s.\nSetting no_collide to true allows cylinders this link_2mon type connects and adjacent cylinders to clip.\n\n:::\n\n## [`` MEDYAN.addfilamentsite! ``](/docstrings/medyan.addfilamentsite--eb6bfd871a21b6f4.qmd) {#medyan.addfilamentsite--eb6bfd871a21b6f4}\n:::{.callout-note appearance=\"minimal\"}\n```julia\naddfilamentsite!(s::SysDef,filamenttypename::Symbol,filamentsitename::Symbol,site)\n\n\n\n\n\n\n\n\n\n\n\n\naddfilamentendsite!(s::SysDef,filamenttypename::Symbol,filamentendsitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\nadd_link_2mon_site!(s::SysDef,link_2mon_typename::Symbol,link_2mon_sitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddlinkablesite!(s::SysDef,linkablesitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddcadherin!(s::SysDef,cadherintypename::Symbol,defaultstate::CadherinState,mechparams). Add the cadherin to the system. Return s.\n\n\n\n\n\n\n\n\n\n\n\n\naddcadherinsite!(s::SysDef,cadherintypename::Symbol,cadherinsitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddpossiblecadherinsite!(s::SysDef,possiblecadherinsitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddmembranesite!(s::MEDYAN.SysDef, membranesitename::Symbol, site) -> MEDYAN.SysDef\nAdd a new site with a specified name. During this process, a new fixed species is created suffixed with “membranesite.”.\n\n\n\n\n\n\n\n\n\n\n\n\naddreaction!(s::SysDef,reaction::CompartmentReaction)::SysDef\n\n\n\n\n\n\n\n\n\naddreaction!(s::SysDef,reactionexpr::AbstractString,rate::Float64,invvolumepower::Int)::SysDef\nAdd a reaction to the system. Return s\nreactionexpr is a string describing the reaction stoichiometry\nreactionexpr is comprised of reactant and product parts seperated by a \"-->\"\nAll whitespace characters are ignored.\nEach side is then split by \"+\" to get the species names.\nRepeated or extra \"+\" are ignored.\nA species name can be prepended by a positive integer to represent multiple copies.\n\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s) rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)).\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\"diffusing.a + diffusing.b --> diffusing.c\"\n\"diffusing.c --> diffusing.a + diffusing.b\"\n\"+ + diffusing.c + --> + diffusing.a + + diffusing.b + +\"\n\" --> diffusing.a + diffusing.b\"\n\"diffusing.a + diffusing.b --> \"\n\"diffusing.a + diffusing.a --> \"\n\"2diffusing.a --> \"\n\"2diffusing.a --> 20diffusing.a\"\n\"diffusing.c + diffusing.b --> diffusing.c + diffusing.b\"\n\"fixedspecies.rate1b --> fixedspecies.g\"\n\"fixedspecies.rate1b + fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.rate1b + 23fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.g --> fixedspecies.rate1b + 23fixedspecies.g\"\n\"fixedspecies.g + fixedspecies.rate1b--> 2fixedspecies.rate1b + 23fixedspecies.g\"\n\"filamentsite.MT.d --> filamentsite.MT.d\"\n\"filamentsite.MT.d + diffusing.a --> filamentsite.MT.d\"\n\"fixedspecies.g --> diffusing.a\"\n\"diffusing.a --> fixedspecies.g\"\n\"filamentsite.actin.pm + diffusing.a --> filamentsite.actin.pm\"\n\n\n\n\n\n\n\n\n\n\n\n\n\naddreactioncallback!(s::SysDef, reaction::CompartmentReaction, callback)::SysDef\naddreactioncallback!(s::SysDef, reactantexpr::AbstractString, rate::Float64, invvolumepower::Int, callback)::SysDef\nLike addreaction! but also adds callback. callback is called when the reaction happens with input of MEDYAN.Context and Int the compartment id where the reaction happened.\nThe reaction should normally have no net stoichiometry because the callback should handle updating species counts. If an AbstractString is passed instead of a CompartmentReaction for the reaction, that string will be parsed to determine the reactants. The net stoichiometry will be zero.\nMEDYAN.errorcheck_addcallback(callback,s::SysDef) can optionally be overloaded to add errorchecking when the callback is added.\n\n\n\n\n\n\n\n\n\nCallback for bulk reactions: Context -> Nothing.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd filament reaction. Return s. Add a filamentsite and reaction with callback to change the monomer state. This can be used for filament aging, filament catalyzed reactions, or simple binding reactions.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentsitename::Symbol: the new name of the filamentsite added. This can be used as a catalyst in other reactions.\nchangedstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the monomer states, the first is the states to match. The second is the new monomer states after the reaction. both should be the same length. Ordered minus end first.\ncenter::Int: Which index of changedstatenames.first is the actual location of the filamentsite. Used for determining what compartment the reaction goes in.\nreactantexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentsite.$(filamenttypename).$(filamentsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nagentnames = AgentNames(\n    filamentnames= [(:filname,[\n                            :a,\n                            :b,\n                            :c,\n                        ]),\n    ],\n)\ns= SysDef(agentnames)\naddfilament_reaction!(s, :filname, :ab,\n    [:a]=>[:b], 1,\n    \"-->\", 1.75E-3, 0,\n)\naddfilament_reaction!(s, :filname, :aabc,\n    [:a,:a]=>[:b,:c], 2,\n    \"-->\", 1.75E-3, 0,\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd filament end reaction. Return s. Add a filamentendsite and reaction with callback to change the filaments. This can be used for polymerization, depolymeriation, and changing end state.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentendsitename::Symbol: the new name of the filamentendsite added. This can be used as a catalyst in other reactions.\nisminusend::Bool: true if changing the minus end, false if changing the plus end.\nchangedendstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the end monomer states, the first is the states to match. The second is the new monomer states after the reaction. If the second has more states than the first, new monomers will be added, if the second has less, monomers will be removed. Ordered minus end first.\nspacing::Float64: Space needed at the filament end for this reaction. (nm) ratefactor= exp(-β*spacing*loadforce) where β is 1/kT, loadforce is the external force pushing axially on the end of the filament. and ratefactor affects this reaction propensity and any others using filamentendsitename\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentendsite.$(filamenttypename).$(filamentendsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentendsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nagentnames = AgentNames(\n    diffusingspeciesnames= [:a,],\n    filamentnames= [(:filname,[\n                            :plus,\n                            :mid,\n                            :minus,\n                        ]),\n    ],\n)\ns= SysDef(agentnames)\nmonomerspacing= 2.7\n#minus end polymerization\naddfilamentend_reaction!(s, :filname, :pm, true,\n    [:minus]=>[:minus,:mid], monomerspacing,\n    \"diffusing.a -->\", 10E3, 1,\n)\n#plus end depolymerization\naddfilamentend_reaction!(s, :filname, :dpp, false,\n    [:mid,:plus]=>[:plus], 0.0,\n    \"--> diffusing.a\", 1.75E-3, 0,\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd unbinding site, callback, and reaction. Return s.\n\n\n\ns::SysDef: the system to add to.\nlink_2mon_typename::Symbol: the link_2mon type name.\nlink_2mon_sitename::Symbol: the new name of the link_2mon_site added. This can be used as a catalyst in other reactions.\nlink_2mon_site: the link_2mon site to add.\nplusfilamenttypename::Symbol: the filament type name of the plus end.\nplusnewmonomerstatename::Symbol: the new name of the monomer state of the plus end.\nminusfilamenttypename::Symbol: the filament type name of the minus end.\nminusnewmonomerstatename::Symbol: the new name of the monomer state of the minus end.\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + link_2mon_site.$(link_2mon_typename).$(link_2mon_sitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using link_2mon_sitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd a membrane site with the corresponding reaction with callback.\nKeyword arguments:\n\ns: SysDef.\nname_newmembranesite: Symbol.\nmembranediffusingreactants: Vector of symbols as membrane reactants. 0 or 1 reactant is currently supported.\nmembranediffusingproducts: Vector of symbols as membrane products.\nreactionexpr_extra: Reaction expression for other species involved.\nrate: Float.\nchangerage_bypotentialenergy: Whether the rate is affected by potential energy.\ninvvolumepower: rate scaling with compartment volume.\n\nNotes:\n\nIf error occurs, this function does not ensure that s is unchanged."
  },
  {
    "objectID": "docstrings/src/linkablesites.html",
    "href": "docstrings/src/linkablesites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Any pair within max to min range are linkable if they have matching state with minusstate and plusstate.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64\n\n\n\n\n\n\n\n\n\n\n\n\n\nAny pair within max to min range are linkable if they have matching state with minusstate and plusstate and if both the angles between the filaments and line between the pair are greater than acos(cosminangle) for example if cosminangle is 1, all angles are ok, if cosminangle is sqrt(2)/2, and the line between the pair of monomers is parallel or anti parallel to either filament, it won’t be linkable.\nThis can be used to prevent link_2mons from binding both ends to the same filament.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64\ncosminangle::Float64"
  },
  {
    "objectID": "docstrings/src/sever_filament.html",
    "href": "docstrings/src/sever_filament.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "sever_filament!(c::Context, mon_name::MonomerName)::Int\nReturn the new filament id of the minus end filament.\nCalling this will invalidate the chem cache.\nThe split will happen between mon_name and the monomer slightly towards the minus end.\nThe plus end will keep the same fil_id, the minus end will get a new fil_id.\nThe split cannot create a filament with less than 2 monomers."
  },
  {
    "objectID": "docstrings/src/context.html",
    "href": "docstrings/src/context.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Membrane protein physical parameters.\n\ndiffusion_coeff::Float64\nMembrane diffusion coefficients (nm^2/s).\narea::Float64\nProtein area projected onto the surface (nm^2).\nkbend::Float64\nBending rigidity (pN nm).\neqcurv::Float64\nThe protein’s own spontaneous mean curvature (/nm). Can be used in bending energy computations with curvatures.\n\n\n\n\n\n\n\n\n\n\n\n\n\nShallow copy, https://stackoverflow.com/questions/51956958/how-to-copy-a-struct-in-julia\n\n\n\n\n\n\n\n\n\n\n\n\nContext(systemdefs::SysDef, grid::CubicGrid; kwargs...)\n\nagentnames::MEDYAN.AgentNames\ncompartments::Vector{MEDYAN.Compartment}\ngrid::Any\ntime::Ref{Float64}\ntime (s)\nstats::MEDYAN.PerformanceStats\nβ::Float64\ninverse kT (1/(nm*pN))\nbase_diffusion_coeffs::Vector{Float64}\nDiffusion coefficients indexed by diffusing species id (nm²/s)\nmembrane_species_params::StaticArraysCore.SVector{NUM_MEMBRANEDIFFUSINGSPECIES, MEDYAN.MembraneSpeciesParams} where NUM_MEMBRANEDIFFUSINGSPECIES\nMembrane species parameters indexed by membrane diffusing species id.\nmin_compartment_volume_ratio::Float64\nSmallest volume a compartment can have before being deactivated as a ratio to a full compartment volume.\nchemistryengine::MEDYAN.RDMESampler\nThe reaction diffusion master equation sampler, contains the diffusing and regular fixed species state\nlargestfilamentid::Vector{Int64}\nThe largest filament id, indexed by filament type id\nchem_cylinders::Vector{MEDYAN.ChemCylinders}\nData about filament cylinders, indexed by filament type id\nmembranes::Vector\nAll membrane meshes.\nlink_2mon_data::Tuple{Vararg{MEDYAN.Link2MonData}}\nThe linked link2mon parameters, indexed by link2mon type id, to give a Link2MonData\nlinkablesite_managers::Tuple{Vararg{MEDYAN.AbstractLinkableSiteManager}}\nThe linkable site managers, indexed by linkable site id\nlinked_monomers::Dictionaries.Dictionary{MEDYAN.MonomerName, Vector{Vector{Int64}}}\nDictionary of all monomers that have a bound link2mon. indexed by monomer name, then link2montypeid, to give a vector of unique link2mon ids that reference the monomer name\nfilamentsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}\nThe filament site definitions, indexed by filament type id, filament site id to get a SiteData with fields of id, site, fxsid\nfilamentendsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}\nThe filamentend site definitions, indexed by filament type id, filamentend site id to get a SiteData with fields of id, site, fxsid\nmaxfilsite_plusrange::Vector{Int64}\nThe maximum plus range in monomers that any filament site or end site can see. Indexed by filament type id\nmaxfilsite_minusrange::Vector{Int64}\nThe maximum minus range in monomers that any filament site or end site can see. Indexed by filament type id\nmembranesites::Tuple{Vararg{MEDYAN.SiteData}}\nMaps membrane site id to a SiteData with fields of id, site, fxsid.\nmap_membranediffusingspeciesindex_membranesiteindices::Tuple{Vararg{Vector{Int64}}}\nMaps membrane diffusing species index to a list of membrane sites using this species as reactant. This is initialized during context init and should not be changed.\nlink_2mon_sites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}\nThe link2mon site definitions, indexed by link2mon type id, link_2mon site id to get a SiteData with fields of id, site, fxsid\nlinkablesites::Tuple{Vararg{MEDYAN.SiteData}}\nThe linkable site definitions, indexed by linkable site id to get a SiteData with fields of id, site, fxsid\ncadherinsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}\ncadherindata::Tuple{Vararg{MEDYAN.CadherinData}}\npossiblecadherinsite_managers::Tuple{Vararg{MEDYAN.AbstractPossibleCadherinSiteManager}}\nThe linkable site managers, indexed by linkable site id\ncadherinlinked_vertices::Dictionaries.Dictionary{MEDYAN.VertexName, Vector{Vector{Pair{MEDYAN.VertexName, MEDYAN.MonomerName}}}}\nDictionary of all vertices that have a bound cadherin. indexed by vertex name, then cadherintypeid, to give a vector of unique cadherin endnames that reference the monomer name and vertex name\ncheck_sitecount_error::Bool\nIf true site counts are checked for errors on every chem update. This is extremely slow, but useful for testing chem update errors.\ncompartmentreactioncallbacks::Any\nbulkreactioncallbacks::Any\nmemdiff_bulks_index::Int64\nMock bulk species index for membrane diffusion.\ng_tol::Float64\nmaximum force magnitude after minimization (pN)\nshake_before_minimization::Bool\nIf true, add noise to coordinates before starting minimization.\niter_max_cg_minimization::Int64\nMax number of steps in conjugate gradient minimization.\nmaxstep::Float64\nmax step to take during line search (nm)\nmax_cylinder_force::Float64\nmax cylinder force when two cylinders are at zero distance (pN)\ncheck_neighborlist_error::Bool\nIf true neighborlists are checked for errors on every force calc. This is extremely slow, but useful for testing neighborlist errors.\nnthreads::Int64\nExperimental Set to more than 1 to enable multi threading. This is currently may result in non bitwise reproducable simulations. Results should be statistcally identical, but this is currently not well tested.\nenable_cylinder_volume_exclusion::Ref{Bool}\nAre cylinder volume exclusion forces calculated\nenable_triangle_bead_volume_exclusion::Bool\nAre triangle-bead volume exclusion forces calculated.\ncylinder_skin_radius::Float64\nExtra cell list cutoff radius in nm. The cell lists are reset after a bead moves over this amount\nfilamentmechparams::Vector{MEDYAN.FilamentMechParams}\nThe filament mechanical parameters, indexed by filament type id\nmembranemechparams::Vector{MEDYAN.MembraneMechParams}\nMembrane mechanical parameters, indexed by membrane type id.\nfunc_membranespeciespotentialenergy::Any\nMembrane species potential energy function. See docs on default function for more info.\nfunc_membranespeciesfreeenergy!::Any\nMembrane species total free energy function. See docs on default function for more info.\nmembranefilamentmechparams::MEDYAN.MembraneFilamentMechParams\nMembrane-filament mechanical interaction parameters.\nexternal_energy_forces!::Any\nExternal energy/force expressions. This should be a function (vectorizedforce, vectorizedx, vectorizeresult) -> energy, which also modifies the force as well. The energy and force must be consistent, and this is not checked. The neighbor lists and related are currently not accessible in the vectorizedinfo. This can be used as ad-hoc solutions to experiment with uncommon forces, such as specifically designed attachments, etc. If this variable is used often, consider moving it into MEDYAN.\nchemboundary::MEDYAN.Boundary\nchemical boundary, updates compartment volumes and diffusion rates\nmeshindex_as_chemboundary::Ref{Int64}\nThe membrane index used as chemical boundary. If values other than 0 is used, the actual interior region of the chemical boundary is the intersection between\n\nthe interior of chemboundary, and\nthe interior of the membrane mesh at this index.\n\nNote: Since the membrane may change its shape often, set_chemboundary! might need to be called often accordingly to update volumes of compartments.\nmechboundary::MEDYAN.Boundary\nmechanical boundary\nsharedtypedconfigs::MEDYAN.SharedTypedConfigs\nShared configurations stored in type parameters.\nvalidflags::MEDYAN.ValidFlags\nInterval system consistency validation flags.\n\n\n\n\n\n\n\n\n\n\n\n\n\nnum_filtypes(c::MEDYAN.Context) -> Int64\nReturn the number of filament types.\n\n\n\n\n\n\n\n\n\n\n\n\nfiltype_fil_ids(c::MEDYAN.Context, ftid::Int64) -> Vector{Int64}\nReturn a read only iterable of all filament ids of filament type ftid.\nThis can be invalid after any mutations to context, so collect if needed.\n\n\n\n\n\n\n\n\n\n\n\n\nfil_node_positions(c::MEDYAN.Context, ftid::Int64, fil_id::Int64) -> Vector{StaticArraysCore.SVector{3, Float64}}\nReturn the node positions of the filament\n\n\n\n\n\n\n\n\n\n\n\n\nfil_node_mon_ids(c::MEDYAN.Context, ftid::Int64, fil_id::Int64) -> Vector{Int64}\nReturn the node monomer ids of the filament.\nThe fil_node_mon_ids are the monomer ids at (slightly plus side of) the fil_node_positions\n                                 |\n                      -----+-----|-----+-----\n  minus end <----       M  |  M  | (M) |  M        ----> plus end\n                      -----+-----|-----+-----\n                                 |\n                                 ^ A node position is indicated by the line.\n\nThe monomer id with parenthesis (M) will in `fil_node_mon_ids`\nThe first monomer id is the first monomer id on the filament. The last monomer id is the last monomer id on the filament + 1\n\n\n\n\n\n\n\n\n\n\n\n\nfil_mon_states(c::MEDYAN.Context, ftid::Int64, fil_id::Int64) -> OffsetArrays.OffsetVector{UInt8, Vector{UInt8}}\nReturn a read only OffsetVector of monomer states on a filament.\nThis can be invalid after any mutations to context, so copy if needed.\n\n\n\n\n\n\n\n\n\n\n\n\nvertex_state(c::MEDYAN.Context, vertexname::MEDYAN.VertexName) -> UInt8\nReturn the vertex state on a membrane.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_exists(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> Bool\nReturn true iff the filament and monomer exists\n\n\n\n\n\n\n\n\n\n\n\n\nmon_minimized(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> Bool\nReturn true iff the monomer has been minimized\n\n\n\n\n\n\n\n\n\n\n\n\nmon_3states(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> Tuple{UInt8, UInt8, UInt8}\nReturn a tuple of three monomer states centered at a monomer.\nIf a monomer doesn’t exist, its state will be zero. The filament must exist.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_position(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> StaticArraysCore.SVector{3, Float64}\nReturn the monomer position.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_plusvector(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> StaticArraysCore.SVector{3, Float64}\nReturn the unit vector toward the plus end of the filament.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_position_plusvector(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}\nReturn a tuple of position and plusvector at a monomer.\n\n\n\n\n\n\n\n\n\n\n\n\nlink_2mon_endnames(c::MEDYAN.Context, ltid, lid) -> Pair{MEDYAN.MonomerName, MEDYAN.MonomerName}\nReturn the minusend name => plusend name of the link with type id ltid, and link id lid\n\n\n\n\n\n\n\n\n\n\n\n\nset_time!(c::MEDYAN.Context, x::Float64) -> Float64\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\nset_enable_cylinder_volume_exclusion!(c::MEDYAN.Context, x::Bool) -> Bool\nAre cylinder volume exclusion forces calculated.\n\n\n\n\n\n\n\n\n\n\n\n\nset_chemboundary!(c::MEDYAN.Context; meshindex_as_chemboundary, kwargs...) -> MEDYAN.Boundary\nSet chemical boundary and update compartment volumes and diffusion rates. Note, the chemboundary should be outside the mechboundary so that it is rare for filaments to go outside the chemboundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the chemical boundary of the simulation\ninside = signbit(pos ⋅ planes[bi][1:3] - planes[bi][4])\nFor example, a plane [1,0,0,3] is inside if x < 3 nm.\n2.0*[1,0,0,3] is also inside if x < 3 nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the chemical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is ignored.\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\n\nmeshindex_as_chemboundary::Int = 0: Index of membrane mesh that further restricts the chem boundary. 0 for none.\n\nThe system geometry information must be up-to-date. This mesh index is not stored in the boundary object, but is directly set in the context.\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_mechboundary!(c::MEDYAN.Context; kwargs...) -> MEDYAN.Boundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the mechanical boundary of the simulation\nE = 1//2 * relu(pos ⋅ planes[bi][1:3] - planes[bi][4])^2\nFor example, a mech bounding plane [1,0,0,3] would try and make x < 3 nm with a spring constant of 1 pN/nm.\n2.0*[1,0,0,3] would try and make x < 3 nm with a spring constant of 4 pN/nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the mechanical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is the spring constant (pN/nm).\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\nE = 1//2*k*relu(d - r0)^2 where:\n\nd is the distance of the point to the spine line segment described by capsules[bi][1:6].\nr0 is capsules[bi][7]\nk is capsules[bi][8]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchem_adddiffusingcount!(c::Context, sid, cid, inccount)\nAdd inccount to diffusing species id sid in compartment id cid\n\n\n\n\n\n\n\n\n\n\n\n\nchem_addfixedcount!(c::Context, sid, cid, inccount)\nAdd inccount to fixed species id sid in compartment id cid\n\n\n\n\n\n\n\n\n\n\n\n\nadddiffusingcount_rand!(c::Context, dsid, inccount)\nDistribute the added diffusing species count randomly to compartments weighted by volume.\n\ndsid: diffusing species id.\ninccount: amount to add.\n\n\n\n\n\n\n\n\n\n\n\n\n\naddmembranediffusingcount_rand!(c::MEDYAN.Context, membraneindex::Int64, speciesindex::Int64, addcount::Int64)\nDistribute the added membrane species count randomly to membrane cells, ignoring cell area difference. Does NOT update propensity.\n\n\n\n\n\n\n\n\n\n\n\n\nnewfilament_rand!(c::Context, monomerstates; iterations = 10^9, ftid = 1)\nAdd a filament with type id ftid to the Context with random center position and direction.\nReturn the filament id of a new filament.\nmonomerstates is a collection of the MonomerState of the monomers in the new filament.\nThe filament will be inside the mech boundary.\nErrors if it fails to add a filament.\nThe monomer are spaced by the value in the filament type’s mechanical parameters.\n\n\n\n\n\n\n\n\n\n\n\n\nrun_chemistry!(c::Context, Δt)\nRun chemistry for Δt time.\nUpdate c.time.\n\n\n\n\n\n\n\n\n\n\n\n\ndefer_chem_caching!(c::Context)::Nothing\nThis should only be used for advanced optimizations.\nDuring chemistry, the context mutating functions will typically try to avoid invalidating various cached data needed to quickly sample sites.\nHowever, if you want to mutate the context outside of chemistry, for example right before or after minimization, you may not want to pay the cost of revalidating all the caches because minimization will already invalidate the caches. Caching will be enabled again and caches will be made valid the next time chemistry is run. Caching can also be manually refreshed and reenabled with: refresh_chem_cache!\n\n\n\n\n\n\n\n\n\n\n\n\nrefresh_chem_cache!(c::Context)::Nothing\nNormally this isn’t needed as it will happen automatically.\n\n\n\n\n\n\n\n\n\n\n\n\nis_chem_cache_valid(c::Context)::Bool\nReturn true if the chemistry cache is valid, false otherwise.\n\n\n\n\n\n\n\n\n\n\n\n\nempty!(c::Context)\nRemove all filaments, membranes, link_2mons, cadherins, diffusing species, fixed species, bulk species, chemboundary, and mechboundary.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_setmonomerstate!(c::Context, name::MonomerName, state::MonomerState)\nUpdate a monomer state.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_polymerize!(c::Context, ftid, fid, isminusend::Bool, newstate::MonomerState)\nAdd a monomer with state newstate to the end of the filament with type id ftid and id fid.\nIf isminusend is true add the monomer to the minus end of the filament, if false add it to the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked link_2mons, or change any of the monomer names. New monomers are not linkable until after minimization.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_depolymerize!(c::Context, ftid, fid, isminusend::Bool)\nRemove a monomer from the end of the filament with type id ftid and id fid.\nIf isminusend is true remove the monomer from the minus end of the filament, if false remove it from the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked link_2mons, or change any of the monomer names.\nError if the filament isn’t initially over 2 monomers long.\nWarn if the old end monomer is referenced in a link2mon, and remove the link2mon.\nThe warning can be disabled by passing keyword argument warniflink_2mon_removed=false\n\n\n\n\n\n\n\n\n\n\n\n\nchem_newlink_2mon!(c::Context, ltid::Int, endnames::Pair{MonomerName,MonomerName}, link_2mon_state::Link2MonState;\n    new_lid::Union{Nothing,Int64} = nothing,\n)::Int64\n\nchem_newlink_2mon!(c::Context, ltid::Int, endnames::Pair{MonomerName,MonomerName};\n    changedchemstate = (;),\n    changedmechstate = (;),\n    is_minimized = c.link_2mon_data[ltid].params.defaultstate.is_minimized,\n    new_lid::Union{Nothing,Int64} = nothing,\n)::Int64\nAdd a new link_2mon with type id ltid between monemers endnames.\nReturn the link_2mon id.\nError if a link_2mon of the same type links the same monomers in the same order.\nIf the link2mon state isn’t provided, c.link*2mon*data[ltid].params.defaultstate is new link2mon’s state, optionally modified by the changedchemstate, changedmechstate, and is_minimized keyword arguments.\nKeyword arguments changedchemstate and changedmechstate are namedtuples that shadow fields from the default chemstate and mechstate for the new link_2mon.\nKeyword argument is_minimized can be used to set the new link*2mon’s is*minimized state.\nKeyword argument new_lid can be optionally used to set the new link_2mon’s id, if this id is currently used, error.\n\n\nlid = chem_newlink_2mon!(c, g.ltid, minusname=>plusname;\n        changedmechstate = (L0 = dist,),\n        changedchemstate = (numHeads = rand(g.numHeadsMin:g.numHeadsMax),),\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nchem_removelink_2mon!(c::Context, ltid::Int, lid::Int64)\nRemove a link_2mon of type id ltid with id lid.\nError if the specified link_2mon doesn’t exist.\nDon’t modify monomer states.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_setlink_2mon_state!(c::Context, ltid, lid, link_2mon_state::Link2MonState)\nSet link2monstate of the link_2mon of type id ltid with id lid.\nError if the specified link_2mon doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_newfilament!(c::Context; ftid=1, monomerstates, node_mids, nodepositions)\nReturn the filament id of a new filament.\nError if the filament isn’t initially over 2 monomers long.\nNewly added filaments don’t have linkable sites, until after minimization.\n\n\n\nftid=1: filament type id.\nmonomerstates: Collection of the MonomerState of the monomers in the new filament. In order from minus end to plus end.\nlength(monomerstates)>1\nnodepositions: Collection of SVector{3,Float64}. The positions of the nodes, monomers are between nodes.\nnode_mids: Collection of Integer. The monomer ids at (slightly plus side of) the nodepositions\n                               |\n                    -----+-----|-----+-----\nminus end <----       M  |  M  | (M) |  M        ----> plus end\n                    -----+-----|-----+-----\n                               |\n                               ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\nlength(node_mids) == length(nodepositions) - 1\nendloadforces=(0.0=>0.0): end load forces, usually don’t use this, because load forces will automatically get updated at the next minimization.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchem_removefilament!(c::Context; ftid=1, fid=maximum(filtype_fil_ids(c, ftid)))\nRemove the filament with type id ftid and id fid.\nBy default the last added filament with type id ftid is removed.\nWarn if any monomers on the filament are referenced by any link2mons, and remove those link2mons.\nThe warning can be disabled by passing keyword argument warniflink_2mon_removed=false\n\n\n\n\n\n\n\n\n\n\n\n\nnewmembrane!(c::MEDYAN.Context; type, meshinit)\nAdd a new membrane to the system.\n\n\n\nmeshinit is structure containing mesh shape initialization information, such as a named tuple (vertlist, trilist) containing vertex coordinates and triangle list, MeshInitEllipsoid, MeshInitPlane or a general MeshInitSurfaceFunc."
  },
  {
    "objectID": "docstrings/src/filamentsites.html",
    "href": "docstrings/src/filamentsites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "General filament site just matches monomer states\n\ncenter::Int64\nindex of center monomer in states\nstates::Vector{UInt8}\nmonomer states to match"
  },
  {
    "objectID": "docstrings/src/util/stableindex.html",
    "href": "docstrings/src/util/stableindex.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Whether an ID is in use.\n\n\n\n\n\n\n\n\n\n\n\n\nTotal number of IDs in use.\n\n\n\n\n\n\n\n\n\n\n\n\nGet index at ID.\n\n\n\n\n\n\n\n\n\n\n\n\nMap ID to a new index. The ID must be in use.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd a new index. Returns its ID.\n\n\n\n\n\n\n\n\n\n\n\n\nRemove a recorded index at ID.\n\n\n\n\n\n\n\n\n\n\n\n\nClear all index records.\n\n\n\n\n\n\n\n\n\n\n\n\nIterates through valid IDs in the StableIndex."
  },
  {
    "objectID": "docstrings/src/util/math/cuboidslicing.html",
    "href": "docstrings/src/util/math/cuboidslicing.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "scale the volume and area\n\n\n\n\n\n\n\n\n\nscale the volume and area by different amounts in each direction"
  },
  {
    "objectID": "docstrings/src/util/bibliography.html",
    "href": "docstrings/src/util/bibliography.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "gen_citation(C::Context; ...)\nGiven a context, generate the citations from used components.\nKeyword arguments:\n\nbibtex_file: If specified, will also save to this file using bibtex format."
  },
  {
    "objectID": "docstrings/src/auxprocs.html",
    "href": "docstrings/src/auxprocs.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Remesh all membrane meshes.\n\n\n\n\n\n\n\n\n\n\n\n\nGiven an AABB tree corresponding to up-to-date membrane mesh triangles, resolve all filament-membrane intersections.\nRequires\n\nup-to-date unit normals of all triangles in the meshes.\nup-to-date AABB tree corresponding to all membrane meshes.\n\n\n\n\n\n\n\n\n\n\n\n\n\nUpdates all membrane geometries used across various parts of MEDYAN.\nThe list of all items can be found in the document for MEDYAN.compute_geometry!_system function.\nKeyword parameters:\n\ninclude_ff::Bool: If true, compute_geometry! used in energy computations will be applied as well, requiring vectorization of the membrane. This happens before system geometry computation in case some fields are overriden."
  },
  {
    "objectID": "docstrings/src/filamentendsites.html",
    "href": "docstrings/src/filamentendsites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Filament end site that matches with a vector of monomer states.\n\nisminusend::Bool\nendstates::Vector{UInt8}\nspacing::Float64"
  },
  {
    "objectID": "docstrings/src/trajectory-io/snapshot.html",
    "href": "docstrings/src/trajectory-io/snapshot.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "load_snapshot!(c::Context,group::StorageTrees.ZGroup)\nEmpty the context and load the state saved in the snapshot group.\nc should be constructed with the same SysDef and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nSee Snapshot group for more details."
  },
  {
    "objectID": "docstrings/medyan.link2monparams-d960d08f0808df0c.html",
    "href": "docstrings/medyan.link2monparams-d960d08f0808df0c.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Link2mon Parameters, there is one instance of this per link2mon type\n\ndefaultstate::MEDYAN.Link2MonState\nmechparams::Any\nno_collide::Bool\nif true, allows cylinders this link_2mon type connects and adjacent cylinders to clip"
  },
  {
    "objectID": "docstrings/medyan.link2monsitemotorcatch-0185d4c95b91e30b.html",
    "href": "docstrings/medyan.link2monsitemotorcatch-0185d4c95b91e30b.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "The catch-bond nature of myosin unbinding with multiple heads. Adopted from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the force increases, the motor unbinding rate decreases to a minimum of k0/10\nlink_2mon_sitecount returns the unbinding rate in units of 1/s It returns k0 if the link2mon hasn’t been minimized yet. It assumes link2monstate.chemstate.numHeads exists for the link2mon.\n\nf0::Float64\nsingle head characteristic unbinding force, units of pN/head\nonRate::Float64\nsingle head binding rate, units of 1/s\noffRate::Float64\nsingle head unbinding rate, units of 1/s\nβ::Float64\nslope of head binding, units of (head)/(pN/head)"
  },
  {
    "objectID": "docstrings/medyan.newmembrane--a714b4a1c87062be.html",
    "href": "docstrings/medyan.newmembrane--a714b4a1c87062be.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "newmembrane!(c::MEDYAN.Context; type, meshinit)\nAdd a new membrane to the system.\n\n\n\nmeshinit is structure containing mesh shape initialization information, such as a named tuple (vertlist, trilist) containing vertex coordinates and triangle list, MeshInitEllipsoid, MeshInitPlane or a general MeshInitSurfaceFunc."
  },
  {
    "objectID": "docstrings/medyan.chem_removefilament--f36888837f14bad7.html",
    "href": "docstrings/medyan.chem_removefilament--f36888837f14bad7.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_removefilament!(c::Context; ftid=1, fid=maximum(filtype_fil_ids(c, ftid)))\nRemove the filament with type id ftid and id fid.\nBy default the last added filament with type id ftid is removed.\nWarn if any monomers on the filament are referenced by any link2mons, and remove those link2mons.\nThe warning can be disabled by passing keyword argument warniflink_2mon_removed=false"
  },
  {
    "objectID": "docstrings/medyan.set_time--a6dd8f73f68a3759.html",
    "href": "docstrings/medyan.set_time--a6dd8f73f68a3759.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_time!(c::MEDYAN.Context, x::Float64) -> Float64\nTime (s)"
  },
  {
    "objectID": "docstrings/medyan.set_enable_cylinder_volume_exclusion--38c20ab68ab8bf1a.html",
    "href": "docstrings/medyan.set_enable_cylinder_volume_exclusion--38c20ab68ab8bf1a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_enable_cylinder_volume_exclusion!(c::MEDYAN.Context, x::Bool) -> Bool\nAre cylinder volume exclusion forces calculated."
  },
  {
    "objectID": "docstrings/medyan.add_membranesitereaction--59d1fe245302e071.html",
    "href": "docstrings/medyan.add_membranesitereaction--59d1fe245302e071.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add a membrane site with the corresponding reaction with callback.\nKeyword arguments:\n\ns: SysDef.\nname_newmembranesite: Symbol.\nmembranediffusingreactants: Vector of symbols as membrane reactants. 0 or 1 reactant is currently supported.\nmembranediffusingproducts: Vector of symbols as membrane products.\nreactionexpr_extra: Reaction expression for other species involved.\nrate: Float.\nchangerage_bypotentialenergy: Whether the rate is affected by potential energy.\ninvvolumepower: rate scaling with compartment volume.\n\nNotes:\n\nIf error occurs, this function does not ensure that s is unchanged."
  },
  {
    "objectID": "docstrings/medyan.link2monsiteone-9886bc1476194731.html",
    "href": "docstrings/medyan.link2monsiteone-9886bc1476194731.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Always returns 1.0"
  },
  {
    "objectID": "docstrings/medyan.filter_grididat-58a94154d21e32b0.html",
    "href": "docstrings/medyan.filter_grididat-58a94154d21e32b0.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "filter_grididat(f,grid::CubicGrid,location)\nReturn the nearest grid id of location where f(id) evaluates to true. The origin is in the corner. errors if there is no id that evaluates to true. Returns a close by compartment if out of the grid"
  },
  {
    "objectID": "docstrings/medyan.mon_exists-898c415a5eddc619.html",
    "href": "docstrings/medyan.mon_exists-898c415a5eddc619.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_exists(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> Bool\nReturn true iff the filament and monomer exists"
  },
  {
    "objectID": "docstrings/medyan.chem_polymerize--7a5e88ac36e4ccbf.html",
    "href": "docstrings/medyan.chem_polymerize--7a5e88ac36e4ccbf.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_polymerize!(c::Context, ftid, fid, isminusend::Bool, newstate::MonomerState)\nAdd a monomer with state newstate to the end of the filament with type id ftid and id fid.\nIf isminusend is true add the monomer to the minus end of the filament, if false add it to the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked link_2mons, or change any of the monomer names. New monomers are not linkable until after minimization."
  },
  {
    "objectID": "docstrings/medyan.link2monsitecount-ab4fcc1eb50c2313.html",
    "href": "docstrings/medyan.link2monsitecount-ab4fcc1eb50c2313.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Returns link_2mon_state.chemstate.sitecount"
  },
  {
    "objectID": "docstrings/medyan.context-736368ed32b08894.html",
    "href": "docstrings/medyan.context-736368ed32b08894.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Context(systemdefs::SysDef, grid::CubicGrid; kwargs...)\n\nagentnames::MEDYAN.AgentNames\ncompartments::Vector{MEDYAN.Compartment}\ngrid::Any\ntime::Ref{Float64}\ntime (s)\nstats::MEDYAN.PerformanceStats\nβ::Float64\ninverse kT (1/(nm*pN))\nbase_diffusion_coeffs::Vector{Float64}\nDiffusion coefficients indexed by diffusing species id (nm²/s)\nmembrane_species_params::StaticArraysCore.SVector{NUM_MEMBRANEDIFFUSINGSPECIES, MEDYAN.MembraneSpeciesParams} where NUM_MEMBRANEDIFFUSINGSPECIES\nMembrane species parameters indexed by membrane diffusing species id.\nmin_compartment_volume_ratio::Float64\nSmallest volume a compartment can have before being deactivated as a ratio to a full compartment volume.\nchemistryengine::MEDYAN.RDMESampler\nThe reaction diffusion master equation sampler, contains the diffusing and regular fixed species state\nlargestfilamentid::Vector{Int64}\nThe largest filament id, indexed by filament type id\nchem_cylinders::Vector{MEDYAN.ChemCylinders}\nData about filament cylinders, indexed by filament type id\nmembranes::Vector\nAll membrane meshes.\nlink_2mon_data::Tuple{Vararg{MEDYAN.Link2MonData}}\nThe linked link2mon parameters, indexed by link2mon type id, to give a Link2MonData\nlinkablesite_managers::Tuple{Vararg{MEDYAN.AbstractLinkableSiteManager}}\nThe linkable site managers, indexed by linkable site id\nlinked_monomers::Dictionaries.Dictionary{MEDYAN.MonomerName, Vector{Vector{Int64}}}\nDictionary of all monomers that have a bound link2mon. indexed by monomer name, then link2montypeid, to give a vector of unique link2mon ids that reference the monomer name\nfilamentsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}\nThe filament site definitions, indexed by filament type id, filament site id to get a SiteData with fields of id, site, fxsid\nfilamentendsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}\nThe filamentend site definitions, indexed by filament type id, filamentend site id to get a SiteData with fields of id, site, fxsid\nmaxfilsite_plusrange::Vector{Int64}\nThe maximum plus range in monomers that any filament site or end site can see. Indexed by filament type id\nmaxfilsite_minusrange::Vector{Int64}\nThe maximum minus range in monomers that any filament site or end site can see. Indexed by filament type id\nmembranesites::Tuple{Vararg{MEDYAN.SiteData}}\nMaps membrane site id to a SiteData with fields of id, site, fxsid.\nmap_membranediffusingspeciesindex_membranesiteindices::Tuple{Vararg{Vector{Int64}}}\nMaps membrane diffusing species index to a list of membrane sites using this species as reactant. This is initialized during context init and should not be changed.\nlink_2mon_sites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}\nThe link2mon site definitions, indexed by link2mon type id, link_2mon site id to get a SiteData with fields of id, site, fxsid\nlinkablesites::Tuple{Vararg{MEDYAN.SiteData}}\nThe linkable site definitions, indexed by linkable site id to get a SiteData with fields of id, site, fxsid\ncadherinsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}\ncadherindata::Tuple{Vararg{MEDYAN.CadherinData}}\npossiblecadherinsite_managers::Tuple{Vararg{MEDYAN.AbstractPossibleCadherinSiteManager}}\nThe linkable site managers, indexed by linkable site id\ncadherinlinked_vertices::Dictionaries.Dictionary{MEDYAN.VertexName, Vector{Vector{Pair{MEDYAN.VertexName, MEDYAN.MonomerName}}}}\nDictionary of all vertices that have a bound cadherin. indexed by vertex name, then cadherintypeid, to give a vector of unique cadherin endnames that reference the monomer name and vertex name\ncheck_sitecount_error::Bool\nIf true site counts are checked for errors on every chem update. This is extremely slow, but useful for testing chem update errors.\ncompartmentreactioncallbacks::Any\nbulkreactioncallbacks::Any\nmemdiff_bulks_index::Int64\nMock bulk species index for membrane diffusion.\ng_tol::Float64\nmaximum force magnitude after minimization (pN)\nshake_before_minimization::Bool\nIf true, add noise to coordinates before starting minimization.\niter_max_cg_minimization::Int64\nMax number of steps in conjugate gradient minimization.\nmaxstep::Float64\nmax step to take during line search (nm)\nmax_cylinder_force::Float64\nmax cylinder force when two cylinders are at zero distance (pN)\ncheck_neighborlist_error::Bool\nIf true neighborlists are checked for errors on every force calc. This is extremely slow, but useful for testing neighborlist errors.\nnthreads::Int64\nExperimental Set to more than 1 to enable multi threading. This is currently may result in non bitwise reproducable simulations. Results should be statistcally identical, but this is currently not well tested.\nenable_cylinder_volume_exclusion::Ref{Bool}\nAre cylinder volume exclusion forces calculated\nenable_triangle_bead_volume_exclusion::Bool\nAre triangle-bead volume exclusion forces calculated.\ncylinder_skin_radius::Float64\nExtra cell list cutoff radius in nm. The cell lists are reset after a bead moves over this amount\nfilamentmechparams::Vector{MEDYAN.FilamentMechParams}\nThe filament mechanical parameters, indexed by filament type id\nmembranemechparams::Vector{MEDYAN.MembraneMechParams}\nMembrane mechanical parameters, indexed by membrane type id.\nfunc_membranespeciespotentialenergy::Any\nMembrane species potential energy function. See docs on default function for more info.\nfunc_membranespeciesfreeenergy!::Any\nMembrane species total free energy function. See docs on default function for more info.\nmembranefilamentmechparams::MEDYAN.MembraneFilamentMechParams\nMembrane-filament mechanical interaction parameters.\nexternal_energy_forces!::Any\nExternal energy/force expressions. This should be a function (vectorizedforce, vectorizedx, vectorizeresult) -> energy, which also modifies the force as well. The energy and force must be consistent, and this is not checked. The neighbor lists and related are currently not accessible in the vectorizedinfo. This can be used as ad-hoc solutions to experiment with uncommon forces, such as specifically designed attachments, etc. If this variable is used often, consider moving it into MEDYAN.\nchemboundary::MEDYAN.Boundary\nchemical boundary, updates compartment volumes and diffusion rates\nmeshindex_as_chemboundary::Ref{Int64}\nThe membrane index used as chemical boundary. If values other than 0 is used, the actual interior region of the chemical boundary is the intersection between\n\nthe interior of chemboundary, and\nthe interior of the membrane mesh at this index.\n\nNote: Since the membrane may change its shape often, set_chemboundary! might need to be called often accordingly to update volumes of compartments.\nmechboundary::MEDYAN.Boundary\nmechanical boundary\nsharedtypedconfigs::MEDYAN.SharedTypedConfigs\nShared configurations stored in type parameters.\nvalidflags::MEDYAN.ValidFlags\nInterval system consistency validation flags."
  },
  {
    "objectID": "docstrings/medyan.add_link_2mon_site--b9548c4a2d23aac9.html",
    "href": "docstrings/medyan.add_link_2mon_site--b9548c4a2d23aac9.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "add_link_2mon_site!(s::SysDef,link_2mon_typename::Symbol,link_2mon_sitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.addreaction--da9bd35e7d1df7c3.html",
    "href": "docstrings/medyan.addreaction--da9bd35e7d1df7c3.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addreaction!(s::SysDef,reaction::CompartmentReaction)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddreaction!(s::SysDef,reactionexpr::AbstractString,rate::Float64,invvolumepower::Int)::SysDef\nAdd a reaction to the system. Return s\nreactionexpr is a string describing the reaction stoichiometry\nreactionexpr is comprised of reactant and product parts seperated by a \"-->\"\nAll whitespace characters are ignored.\nEach side is then split by \"+\" to get the species names.\nRepeated or extra \"+\" are ignored.\nA species name can be prepended by a positive integer to represent multiple copies.\n\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s) rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)).\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\"diffusing.a + diffusing.b --> diffusing.c\"\n\"diffusing.c --> diffusing.a + diffusing.b\"\n\"+ + diffusing.c + --> + diffusing.a + + diffusing.b + +\"\n\" --> diffusing.a + diffusing.b\"\n\"diffusing.a + diffusing.b --> \"\n\"diffusing.a + diffusing.a --> \"\n\"2diffusing.a --> \"\n\"2diffusing.a --> 20diffusing.a\"\n\"diffusing.c + diffusing.b --> diffusing.c + diffusing.b\"\n\"fixedspecies.rate1b --> fixedspecies.g\"\n\"fixedspecies.rate1b + fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.rate1b + 23fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.g --> fixedspecies.rate1b + 23fixedspecies.g\"\n\"fixedspecies.g + fixedspecies.rate1b--> 2fixedspecies.rate1b + 23fixedspecies.g\"\n\"filamentsite.MT.d --> filamentsite.MT.d\"\n\"filamentsite.MT.d + diffusing.a --> filamentsite.MT.d\"\n\"fixedspecies.g --> diffusing.a\"\n\"diffusing.a --> fixedspecies.g\"\n\"filamentsite.actin.pm + diffusing.a --> filamentsite.actin.pm\""
  },
  {
    "objectID": "docstrings/medyan.addmembranesite--892875b2c079002d.html",
    "href": "docstrings/medyan.addmembranesite--892875b2c079002d.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addmembranesite!(s::MEDYAN.SysDef, membranesitename::Symbol, site) -> MEDYAN.SysDef\nAdd a new site with a specified name. During this process, a new fixed species is created suffixed with “membranesite.”."
  },
  {
    "objectID": "docstrings/medyan.chem_newlink_2mon--e4f84fe5cfa9a727.html",
    "href": "docstrings/medyan.chem_newlink_2mon--e4f84fe5cfa9a727.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_newlink_2mon!(c::Context, ltid::Int, endnames::Pair{MonomerName,MonomerName}, link_2mon_state::Link2MonState;\n    new_lid::Union{Nothing,Int64} = nothing,\n)::Int64\n\nchem_newlink_2mon!(c::Context, ltid::Int, endnames::Pair{MonomerName,MonomerName};\n    changedchemstate = (;),\n    changedmechstate = (;),\n    is_minimized = c.link_2mon_data[ltid].params.defaultstate.is_minimized,\n    new_lid::Union{Nothing,Int64} = nothing,\n)::Int64\nAdd a new link_2mon with type id ltid between monemers endnames.\nReturn the link_2mon id.\nError if a link_2mon of the same type links the same monomers in the same order.\nIf the link2mon state isn’t provided, c.link*2mon*data[ltid].params.defaultstate is new link2mon’s state, optionally modified by the changedchemstate, changedmechstate, and is_minimized keyword arguments.\nKeyword arguments changedchemstate and changedmechstate are namedtuples that shadow fields from the default chemstate and mechstate for the new link_2mon.\nKeyword argument is_minimized can be used to set the new link*2mon’s is*minimized state.\nKeyword argument new_lid can be optionally used to set the new link_2mon’s id, if this id is currently used, error.\n\n\nlid = chem_newlink_2mon!(c, g.ltid, minusname=>plusname;\n        changedmechstate = (L0 = dist,),\n        changedchemstate = (numHeads = rand(g.numHeadsMin:g.numHeadsMax),),\n    )"
  },
  {
    "objectID": "docstrings/medyan.load_snapshot--e534be293ce74465.html",
    "href": "docstrings/medyan.load_snapshot--e534be293ce74465.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "load_snapshot!(c::Context,group::StorageTrees.ZGroup)\nEmpty the context and load the state saved in the snapshot group.\nc should be constructed with the same SysDef and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nSee Snapshot group for more details."
  },
  {
    "objectID": "docstrings/medyan.is_chem_cache_valid-8336a8adc58a252f.html",
    "href": "docstrings/medyan.is_chem_cache_valid-8336a8adc58a252f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "is_chem_cache_valid(c::Context)::Bool\nReturn true if the chemistry cache is valid, false otherwise."
  },
  {
    "objectID": "docstrings/medyan.run_chemistry--dda22fac5c555b9e.html",
    "href": "docstrings/medyan.run_chemistry--dda22fac5c555b9e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "run_chemistry!(c::Context, Δt)\nRun chemistry for Δt time.\nUpdate c.time."
  },
  {
    "objectID": "docstrings/medyan.linkablesiteminanglerange-fb2b6cfdc0e13e58.html",
    "href": "docstrings/medyan.linkablesiteminanglerange-fb2b6cfdc0e13e58.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Any pair within max to min range are linkable if they have matching state with minusstate and plusstate and if both the angles between the filaments and line between the pair are greater than acos(cosminangle) for example if cosminangle is 1, all angles are ok, if cosminangle is sqrt(2)/2, and the line between the pair of monomers is parallel or anti parallel to either filament, it won’t be linkable.\nThis can be used to prevent link_2mons from binding both ends to the same filament.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64\ncosminangle::Float64"
  },
  {
    "objectID": "docstrings/medyan.minimize_energy--84c4aeab5457d3ee.html",
    "href": "docstrings/medyan.minimize_energy--84c4aeab5457d3ee.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "minimize_energy!(c::Context)\nMinimize mechanical energy of the context."
  },
  {
    "objectID": "docstrings/medyan.centerof-e902b9bb7b2a6caf.html",
    "href": "docstrings/medyan.centerof-e902b9bb7b2a6caf.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "centerof(grid::CubicGrid,cid)\nReturn the location of the center of a grid id The origin is in the corner.\n\n\n\n\n\n\n\n\n\n\n\n\ncenterof(grid::CubicGrid)\nReturn the location of the center the grid The origin is in the corner."
  },
  {
    "objectID": "docstrings/medyan.addlinkablesite--9ffc8c8377769414.html",
    "href": "docstrings/medyan.addlinkablesite--9ffc8c8377769414.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addlinkablesite!(s::SysDef,linkablesitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.mon_position_plusvector-927d0affbbdfef6f.html",
    "href": "docstrings/medyan.mon_position_plusvector-927d0affbbdfef6f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_position_plusvector(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}\nReturn a tuple of position and plusvector at a monomer."
  },
  {
    "objectID": "docstrings/base.setindex--725f722fff4cfa6d.html",
    "href": "docstrings/base.setindex--725f722fff4cfa6d.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Map ID to a new index. The ID must be in use."
  },
  {
    "objectID": "docstrings/base.iterate-5228367cd62c0bf2.html",
    "href": "docstrings/base.iterate-5228367cd62c0bf2.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Iterates through valid IDs in the StableIndex."
  },
  {
    "objectID": "docstrings/medyan.vertex_state-aa3350c08b68b63a.html",
    "href": "docstrings/medyan.vertex_state-aa3350c08b68b63a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "vertex_state(c::MEDYAN.Context, vertexname::MEDYAN.VertexName) -> UInt8\nReturn the vertex state on a membrane."
  },
  {
    "objectID": "docstrings/medyan.addfilamentendsite--95612d72d1fda05f.html",
    "href": "docstrings/medyan.addfilamentendsite--95612d72d1fda05f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addfilamentendsite!(s::SysDef,filamenttypename::Symbol,filamentendsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.linkablesiterange-8facd8a85195dbd0.html",
    "href": "docstrings/medyan.linkablesiterange-8facd8a85195dbd0.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Any pair within max to min range are linkable if they have matching state with minusstate and plusstate.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64"
  },
  {
    "objectID": "docstrings/medyan.grididat-8671e01413346deb.html",
    "href": "docstrings/medyan.grididat-8671e01413346deb.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "grididat(grid::CubicGrid,location)\nReturn the grid id of location The origin is in the corner. Returns a close by compartment if out of the grid"
  },
  {
    "objectID": "docstrings/medyan.mon_minimized-5b17adaf7d8a4f62.html",
    "href": "docstrings/medyan.mon_minimized-5b17adaf7d8a4f62.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_minimized(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> Bool\nReturn true iff the monomer has been minimized"
  },
  {
    "objectID": "docstrings/medyan.agentnames-948e6a24b4fb0cb5.html",
    "href": "docstrings/medyan.agentnames-948e6a24b4fb0cb5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "The names of the agents in a simulation\n\ndiffusingspeciesnames::Vector{Symbol}\nbulkspeciesnames::Vector{Symbol}\nmembranediffusingspeciesnames::Vector{Symbol}\nfixedspeciesnames::Vector{Symbol}\nfilamentnames::Vector{Tuple{Symbol, Vector{Symbol}}}\nvertexnames::Vector{Symbol}\nlink_2mon_names::Vector{Symbol}\ncadherinnames::Vector{Symbol}"
  },
  {
    "objectID": "docstrings/medyan.add_filament_params--74c7d0081157ca31.html",
    "href": "docstrings/medyan.add_filament_params--74c7d0081157ca31.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "add_filament_params!(s::SysDef, filament_name::Symbol, filament_params::FilamentMechParams)\nAdd the filament parameters to the system. Return s.\nSee MEDYAN.FilamentMechParams"
  },
  {
    "objectID": "docstrings/medyan.filtype_fil_ids-d333c38b9f9b3584.html",
    "href": "docstrings/medyan.filtype_fil_ids-d333c38b9f9b3584.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "filtype_fil_ids(c::MEDYAN.Context, ftid::Int64) -> Vector{Int64}\nReturn a read only iterable of all filament ids of filament type ftid.\nThis can be invalid after any mutations to context, so collect if needed."
  },
  {
    "objectID": "docstrings/medyan.addcadherin--3c757785fa097c75.html",
    "href": "docstrings/medyan.addcadherin--3c757785fa097c75.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addcadherin!(s::SysDef,cadherintypename::Symbol,defaultstate::CadherinState,mechparams). Add the cadherin to the system. Return s."
  },
  {
    "objectID": "docstrings/medyan.fil_node_mon_ids-b1d3d66a81296343.html",
    "href": "docstrings/medyan.fil_node_mon_ids-b1d3d66a81296343.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "fil_node_mon_ids(c::MEDYAN.Context, ftid::Int64, fil_id::Int64) -> Vector{Int64}\nReturn the node monomer ids of the filament.\nThe fil_node_mon_ids are the monomer ids at (slightly plus side of) the fil_node_positions\n                                 |\n                      -----+-----|-----+-----\n  minus end <----       M  |  M  | (M) |  M        ----> plus end\n                      -----+-----|-----+-----\n                                 |\n                                 ^ A node position is indicated by the line.\n\nThe monomer id with parenthesis (M) will in `fil_node_mon_ids`\nThe first monomer id is the first monomer id on the filament. The last monomer id is the last monomer id on the filament + 1"
  },
  {
    "objectID": "docstrings/medyan.adddiffusingcount_rand--9d3ddfabbceeef92.html",
    "href": "docstrings/medyan.adddiffusingcount_rand--9d3ddfabbceeef92.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "adddiffusingcount_rand!(c::Context, dsid, inccount)\nDistribute the added diffusing species count randomly to compartments weighted by volume.\n\ndsid: diffusing species id.\ninccount: amount to add."
  },
  {
    "objectID": "docstrings/medyan.chem_depolymerize--a5f262191e484dd4.html",
    "href": "docstrings/medyan.chem_depolymerize--a5f262191e484dd4.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_depolymerize!(c::Context, ftid, fid, isminusend::Bool)\nRemove a monomer from the end of the filament with type id ftid and id fid.\nIf isminusend is true remove the monomer from the minus end of the filament, if false remove it from the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked link_2mons, or change any of the monomer names.\nError if the filament isn’t initially over 2 monomers long.\nWarn if the old end monomer is referenced in a link2mon, and remove the link2mon.\nThe warning can be disabled by passing keyword argument warniflink_2mon_removed=false"
  },
  {
    "objectID": "docstrings/medyan.num_filtypes-b9943bbf7a9c7781.html",
    "href": "docstrings/medyan.num_filtypes-b9943bbf7a9c7781.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "num_filtypes(c::MEDYAN.Context) -> Int64\nReturn the number of filament types."
  },
  {
    "objectID": "docstrings/medyan.mon_3states-6c16efb303a60058.html",
    "href": "docstrings/medyan.mon_3states-6c16efb303a60058.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_3states(c::MEDYAN.Context, monomer::MEDYAN.MonomerName) -> Tuple{UInt8, UInt8, UInt8}\nReturn a tuple of three monomer states centered at a monomer.\nIf a monomer doesn’t exist, its state will be zero. The filament must exist."
  },
  {
    "objectID": "docstrings/medyan.filamentendsitegeneral-7a32ac96fb4364ea.html",
    "href": "docstrings/medyan.filamentendsitegeneral-7a32ac96fb4364ea.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Filament end site that matches with a vector of monomer states.\n\nisminusend::Bool\nendstates::Vector{UInt8}\nspacing::Float64"
  },
  {
    "objectID": "docstrings/medyan.addfilamentend_reaction--83ec3db37b4e2130.html",
    "href": "docstrings/medyan.addfilamentend_reaction--83ec3db37b4e2130.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add filament end reaction. Return s. Add a filamentendsite and reaction with callback to change the filaments. This can be used for polymerization, depolymeriation, and changing end state.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentendsitename::Symbol: the new name of the filamentendsite added. This can be used as a catalyst in other reactions.\nisminusend::Bool: true if changing the minus end, false if changing the plus end.\nchangedendstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the end monomer states, the first is the states to match. The second is the new monomer states after the reaction. If the second has more states than the first, new monomers will be added, if the second has less, monomers will be removed. Ordered minus end first.\nspacing::Float64: Space needed at the filament end for this reaction. (nm) ratefactor= exp(-β*spacing*loadforce) where β is 1/kT, loadforce is the external force pushing axially on the end of the filament. and ratefactor affects this reaction propensity and any others using filamentendsitename\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentendsite.$(filamenttypename).$(filamentendsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentendsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nagentnames = AgentNames(\n    diffusingspeciesnames= [:a,],\n    filamentnames= [(:filname,[\n                            :plus,\n                            :mid,\n                            :minus,\n                        ]),\n    ],\n)\ns= SysDef(agentnames)\nmonomerspacing= 2.7\n#minus end polymerization\naddfilamentend_reaction!(s, :filname, :pm, true,\n    [:minus]=>[:minus,:mid], monomerspacing,\n    \"diffusing.a -->\", 10E3, 1,\n)\n#plus end depolymerization\naddfilamentend_reaction!(s, :filname, :dpp, false,\n    [:mid,:plus]=>[:plus], 0.0,\n    \"--> diffusing.a\", 1.75E-3, 0,\n)"
  },
  {
    "objectID": "docstrings/medyan.addcadherinsite--9e21ac42968d0196.html",
    "href": "docstrings/medyan.addcadherinsite--9e21ac42968d0196.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addcadherinsite!(s::SysDef,cadherintypename::Symbol,cadherinsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.fil_node_positions-618a66637eb50781.html",
    "href": "docstrings/medyan.fil_node_positions-618a66637eb50781.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "fil_node_positions(c::MEDYAN.Context, ftid::Int64, fil_id::Int64) -> Vector{StaticArraysCore.SVector{3, Float64}}\nReturn the node positions of the filament"
  },
  {
    "objectID": "docstrings/base.copy-4ca5eb8401ab10b2.html",
    "href": "docstrings/base.copy-4ca5eb8401ab10b2.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Shallow copy, https://stackoverflow.com/questions/51956958/how-to-copy-a-struct-in-julia"
  },
  {
    "objectID": "docstrings/medyan.addfilamentsite--eb6bfd871a21b6f4.html",
    "href": "docstrings/medyan.addfilamentsite--eb6bfd871a21b6f4.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addfilamentsite!(s::SysDef,filamenttypename::Symbol,filamentsitename::Symbol,site)"
  },
  {
    "objectID": "docstrings/medyan.gen_citation-5a613a4d19801a8b.html",
    "href": "docstrings/medyan.gen_citation-5a613a4d19801a8b.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "gen_citation(C::Context; ...)\nGiven a context, generate the citations from used components.\nKeyword arguments:\n\nbibtex_file: If specified, will also save to this file using bibtex format."
  },
  {
    "objectID": "docstrings/medyan.add_link_2mon--b801c872b8ff168a.html",
    "href": "docstrings/medyan.add_link_2mon--b801c872b8ff168a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "add_link_2mon!(s::SysDef,link_2mon_typename::Symbol,defaultstate::Link2MonState,mechparams;no_collide=false)\nAdd the link_2mon to the system. Return s.\nSetting no_collide to true allows cylinders this link_2mon type connects and adjacent cylinders to clip.\n```julia"
  },
  {
    "objectID": "docstrings/medyan.addpossiblecadherinsite--ae8586daa0b5454a.html",
    "href": "docstrings/medyan.addpossiblecadherinsite--ae8586daa0b5454a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addpossiblecadherinsite!(s::SysDef,possiblecadherinsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.link2monstate-9845e7e08620ea8a.html",
    "href": "docstrings/medyan.link2monstate-9845e7e08620ea8a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "There is one instance of this per link_2mon.\n\nchemstate::NamedTuple\nOther state.\nmechstate::NamedTuple\nUsed in link_2mon force calculation.\nis_minimized::Bool\nSet to true after minimization"
  },
  {
    "objectID": "docstrings/medyan.addmembranediffusingcount_rand--7b719dca63a36b1b.html",
    "href": "docstrings/medyan.addmembranediffusingcount_rand--7b719dca63a36b1b.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addmembranediffusingcount_rand!(c::MEDYAN.Context, membraneindex::Int64, speciesindex::Int64, addcount::Int64)\nDistribute the added membrane species count randomly to membrane cells, ignoring cell area difference. Does NOT update propensity."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "src/sysdefs.jl\n\nMEDYAN.AgentNames\nMEDYAN.SysDef\nadd_diffusion_coeff!\naddreaction!\naddreactioncallback!\nadd_filament_params!\naddfilamentsite!\naddfilament_reaction!\naddfilamentendsite!\naddfilamentend_reaction!\nadd_link_2mon!\n\n\n\n\n\nMEDYAN.Context\nCubicGrid\ndeepcopy, note: rng is shared\n\n\n\n\n\nBase.empty!\nload_snapshot!\nchem_newfilament!\nchem_removefilament!\nchem_polymerize!\nchem_depolymerize!\nchem_setmonomerstate!\nchem_newlink_2mon!\nchem_removelink_2mon!\nchem_setlink_2mon_state!\nchem_adddiffusingcount!\nchem_addfixedcount!\nadddiffusingcount_rand!\nnewfilament_rand!\nset_time!\nset_enable_cylinder_volume_exclusion!\nset_chemboundary!\nset_mechboundary!\nsever_filament!\n\n\n\n\n\nnum_filtypes\nfiltype_fil_ids\nfil_node_positions\nfil_node_mon_ids\nfil_mon_states\nmon_exists\nmon_minimized\nmon_position\nmon_plusvector\nmon_position_plusvector\nmon_3states\nnum_link_2montypes\nlink_2mon_endnames\n\n\n\n\n\nrun_chemistry!\nminimize_energy!\n\n\n\n\n\n\n\n\n\n\nfilament sites\nfilament end sites\nlink_2mon sites\nlinkable sites\n\n\n\n\n\n\n\n\n\n\nCubicGrid\nMEDYAN.grididat\nMEDYAN.filter_grididat\nMEDYAN.centerof"
  },
  {
    "objectID": "reference/fileformats.html",
    "href": "reference/fileformats.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "MEDYAN.jl uses Zarr v2 zip store for saving snapshots.\n\n\n\n\n\n\nOther Languages\n\n\n\nTo open the snapshots in python use zarr\n\n\n\n\nTrajectory outputs and logs are stored in a directory.\nThe folder contains a header.json file, a list.txt file, and a snapshots sub directory containing many snapshot$(NUMBER).zarr.zip files where NUMBER is the frame number of the snapshot.\nThe initial state returned by setup is stored in snapshot0.zarr.zip.\nInside the snapshot$(NUMBER).zarr.zip there is a medyan_context directory containing the snapshot of the MEDYAN.Context at the step. Other state may be stored in sibling directories to medyan_context.\nThe header.json file also has a top level \"medyan_context\" key with a value describing the system being simulated.\nOther header information may be under other top level keys.\nSee https://github.com/medyan-dev/MEDYANSimRunner.jl for details on the structure of the list.txt file.\n\n\n\nheader.json[\"medyan_context\"] contains static metadata about the simulation that is constant over time.\n\n\n\nusing MEDYAN\nimport JSON3\ncinit, s = MEDYAN.example_all_sites_context()\nJSON3.pretty(MEDYAN.header(cinit); allow_inf = true)\n\n{\n    \"version\": \"0.1.0\"\n\n\n,\n    \"medyanInfo\": {\n\n\n        \"title\": \"MEDYAN.jl\",\n        \"version\": \"0.1.0\",\n        \"sourceCodeUrl\": \"https://github.com/medyan-dev/MEDYAN.jl\"\n    },\n    \"size\": {\n        \"x(nm)\": 2000,\n        \"y(nm)\": 500,\n        \"z(nm)\": 500\n    },\n    \"chem_grid_size\": {\n        \"nx\": 4,\n        \"ny\": 1,\n        \"nz\": 1,\n        \"voxel_x(nm)\": 500,\n        \"voxel_y(nm)\": 500,\n        \"voxel_z(nm)\": 500\n    },\n    \"diffusing_species\": [\n\n\n        {\n            \"name\": \"b\"\n        },\n        {\n            \"name\": \"c\"\n        }\n    ],\n    \"membrane_diffusing_species\": [\n        {\n            \"name\": \"ma\"\n        },\n        {\n            \"name\": \"mb\"\n        },\n        {\n            \"name\": \"mc\"\n        }\n    ],\n    \"fixed_species\": [\n        {\n            \"name\": \"d\"\n        },\n        {\n            \"name\": \"a\"\n        }\n    ],\n    \"filaments\": \n\n\n[\n        {\n            \"name\": \"a\",\n            \"radius(nm)\": 3,\n            \"monomerstates\": [\n                \"me\",\n                \"a\",\n                \"b\",\n                \"c\",\n                \"pe\"\n            ]\n        },\n        {\n            \"name\": \"b\",\n            \"radius(nm)\": 3,\n            \"monomerstates\": [\n                \"me\",\n                \"a\",\n                \"b\",\n                \"c\",\n                \"pe\"\n            ]\n        }\n    ],\n    \"link_2mons\": [\n        {\n            \"name\": \"a\"\n        },\n        {\n            \"name\": \"b\"\n        },\n        {\n            \"name\": \"c\"\n        },\n        {\n            \"name\": \"d\"\n        }\n    ]\n}\n\n\n\n\n\n\nA snapshot describes the state of a Context at a single point in time.\nA snapshot can be used to set the state of a Context if it was constructed with the same system and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nThe snapshot doesn’t hold the exact full state of a Context, simulations restarted from a snapshot may not have the exact same results because:\n\nThe snapshot doesn’t store the state of the random number generator.\nCoordinates may be rounded to save disk space.\nDictionaries and other internal data structures may get reordered and or resorted when the snapshot is loaded.\nMultithreading may be non deterministic.\n\nBut if rounding isn’t too extreme, the reloaded Context should have the same statistics.\n\n\nThe snapshot format is versioned by the “version” attribute. The current snapshot version is:\n\nusing MEDYAN\nMEDYAN.SNAPSHOT_VERSION\n\nv\"0.7.0\"\n\n\nCurrently before snapshot version 1.0.0 anything goes.\nAfter snapshot version 1.0.0 is released.\nSnapshots written with a previous snapshot version above v\"1\" should be readable. Snapshots written with a newer snapshot version are generally not readable.\nIf new agent types are added to MEDYAN.jl, usually only the minor version needs to be updated, as nothing special needs to be done to read older snapshot versions without that added agent type.\nIf new data is added to an existing agent type, also usually only the minor version needs to be increment, though the case of the new data not existing must be handled with some default.\nIf the way an existing agent type is stored significantly changes, such that external code analyzing the snapshot would need to be modified, the major version must be incremented. Also if possible there should be a function to update a snapshot from the old version to the new version.\n\n\nAny group, dataset, or attribute name prefixed with with “#” can change format or be removed without changing the snapshot version.\n“#experimental” is used for saving new types of agents or other data that doesn’t have a stable format yet.\n“#comment” is used for saving human readable comments that could change in format or wording.\n\n\n\n\n\nusing MEDYAN\nusing StorageTrees\ncinit, s = MEDYAN.example_all_sites_context()\ngroup = MEDYAN.snapshot(cinit)\n\n\n\n\n\n\n\nSnapshot 📂\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\ntime (s)\n\n\nattrs(group)[\"time (s)\"]\n\n0.0\n\n\nDefault: No change\nSee MEDYAN.set_time!\n\n\n\nversion\n\n\nattrs(group)[\"version\"]\n\n\"0.7.0\"\n\n\nDefault: No change\nSee Snapshot Versioning\n\n\n\nuuid\n\n\nattrs(group)[\"uuid\"]\n\n\"37eee81f-88ae-4d11-b6b3-d38e1ccf0a08\"\n\n\nMust be set to exactly “37eee81f-88ae-4d11-b6b3-d38e1ccf0a08”\nto be considered a valid MEDYAN snapshot.\n\n\n\n\n\n\n\n\n\n\n\n\n🔢\n\n\n\n\n\n\n\ndiffusingcounts\n\n\ncollect(group[\"diffusingcounts\"])\n\n2×4 Matrix{Int32}:\n 0   100   40  0\n 0  1000  400  0\n\n\nDefault: Empty\nIndexed by [species id, compartment id] to give count.\nSee MEDYAN.chem_adddiffusingcount!\n\n\n\nfixedcounts\n\n\ncollect(group[\"fixedcounts\"])\n\n2×4 Matrix{Float64}:\n 10.25  0.0  0.0   0.0\n  0.0   0.0  0.0  20.25\n\n\nDefault: Empty\nIndexed by [species id, compartment id] to give count.\nSee MEDYAN.chem_addfixedcount!\n\n\n\n\n\n\n\n\n\n\n\n\n📂\n\n\n\n\n\n\n\n\n\n\n\n\nchemboundary\n\n\n\n\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.set_chemboundary!\n\n\n🔢 capsules\n\n\ncollect(group[\"chemboundary/capsules\"])\n\n8×1 Matrix{Float64}:\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n 10000.0\n     1.0\n\n\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 planes\n\n\ncollect(group[\"chemboundary/planes\"])\n\n4×6 Matrix{Float64}:\n -10.0     10.0    0.0     0.0    0.0     0.0\n   0.0      0.0  -10.0    10.0    0.0     0.0\n   0.0      0.0    0.0     0.0  -10.0    10.0\n   0.0  20000.0    0.0  5000.0    0.0  5000.0\n\n\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nfilaments\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nposition_scale\n\n\nattrs(group[\"filaments\"])[\"position_scale\"]\n\n3\n\n\nDefault: No effect\nFilament positions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\nThere is a subgroup for each filament type with at least one filament. The subgroups are named by their filament type id. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n🔢 endloadforces\n\n\ncollect(group[\"filaments/1/endloadforces\"])\n\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\n\nFilament end load forces (pN).\nEach row is the load force on the minus and plus ends of a filament.\n\n\n\n🔢 fids\n\n\ncollect(group[\"filaments/1/fids\"])\n\n2-element Vector{Int32}:\n 1\n 2\n\n\nFilament ids.\n\n\n\n🔢 minusend_num_notminimized\n\n\ncollect(group[\"filaments/1/minusend_num_notminimized\"])\n\n2-element Vector{Int32}:\n 0\n 0\n\n\nNumber of newly added monomers to the filament minus ends since last minimization.\n\n\n\n🔢 plusend_num_notminimized\n\n\ncollect(group[\"filaments/1/plusend_num_notminimized\"])\n\n2-element Vector{Int32}:\n 0\n 0\n\n\nNumber of newly added monomers to the filament plus ends since last minimization.\n\n\n\n🔢 num_cylinders\n\n\ncollect(group[\"filaments/1/num_cylinders\"])\n\n2-element Vector{Int32}:\n 1\n 1\n\n\nNumber of cylinders per filament.\n\n\n\n🔢 num_monomers\n\n\ncollect(group[\"filaments/1/num_monomers\"])\n\n2-element Vector{Int32}:\n 9\n 9\n\n\nNumber of monomers per filament.\n\n\n\n🔢 node_mids\n\n\ncollect(group[\"filaments/1/node_mids\"])\n\n2-element Vector{Int32}:\n 1\n 1\n\n\nThe monomer ids at the minus ends of the cylinders.\n                                   |\n                        -----+-----|-----+-----\n    minus end <----       M  |  M  | (M) |  M        ----> plus end\n                        -----+-----|-----+-----\n                                   |\n                                   ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\n\n\n\n🔢 nodepositions\n\n\ncollect(group[\"filaments/1/nodepositions\"])\n\n4×3 Matrix{Float64}:\n 470.0  200.0  200.0\n 560.0  200.0  200.0\n 480.0  201.0  200.0\n 570.0  201.0  200.0\n\n\nEach row is a node position in nm.\n\n\n\n🔢 monomerstates\n\n\ncollect(group[\"filaments/1/monomerstates\"])\n\n18-element Vector{UInt8}:\n 0x01\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x05\n 0x01\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x05\n\n\nMonomer states.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlink_2mons\n\n\n\n\n\nThere is a subgroup for each link_2mon type with at least one link_2mon. The subgroups are named by their link_2mon type id. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nnum_link_2mons\n\n\nattrs(group[\"link_2mons/1\"])[\"num_link_2mons\"]\n\n2\n\n\nNumber of link_2mons of this type.\n\n\n\n\n\n\n\n🔢 endnames\n\n\ncollect(group[\"link_2mons/1/endnames\"])\n\n2×6 Matrix{Int64}:\n 1  1  2  1  1  2\n 1  1  2  1  2  2\n\n\nThe pairs of monomers that the link_2mons are linked between. The monomer pairs are directed and unique.\nEach row of this matrix represents two monomers. The 6 integers per row are in order:\n\nMinus end filament type id.\nMinus end filament id.\nMinus end monomer id.\nPlus end filament type id.\nPlus end filament id.\nPlus end monomer id.\n\n\n\n\n📂 state\n\nDefault: default link_2mon_state\nSee MEDYAN.chem_setlink_2mon_state! and MEDYAN.Link2MonState\nThe state of a link_2mon, organized in a nested struct of vector like form. Any static arrays will be unwrapped into a tuple of vectors, in column major order. The “name” attribute of each subgroup and dataset is the corresponding property name in the StructArray Any property in the default state that isn’t in the snapshot will stay at its default value.\n\ngroup[\"link_2mons/1/state\"]\n\n📂\n├─ 📂 1 🏷️ name => \"chemstate\",\n|  ├─ 🔢 1: 2 Int64  🏷️ name => \"a\",\n|  └─ 🔢 2: 2 Float64  🏷️ name => \"b\",\n├─ 📂 2 🏷️ name => \"mechstate\",\n|  └─ 📂 1 🏷️ name => \"â\",\n|     ├─ 🔢 1: 2 Float32  🏷️ name => \"1\",\n|     ├─ 🔢 2: 2 Float32  🏷️ name => \"2\",\n|     └─ 🔢 3: 2 Float32  🏷️ name => \"3\",\n└─ 🔢 3: 2 Bool  🏷️ name => \"is_minimized\",\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmechboundary\n\n\n\n\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.set_mechboundary!\n\n\n🔢 capsules\n\n\ncollect(group[\"mechboundary/capsules\"])\n\n8×1 Matrix{Float64}:\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n 10000.0\n     1.0\n\n\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 planes\n\n\ncollect(group[\"mechboundary/planes\"])\n\n4×6 Matrix{Float64}:\n -10.0     10.0    0.0     0.0    0.0     0.0\n   0.0      0.0  -10.0    10.0    0.0     0.0\n   0.0      0.0    0.0     0.0  -10.0    10.0\n   0.0  20000.0    0.0  5000.0    0.0  5000.0\n\n\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nmembranes\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nnum_membranes\n\n\nattrs(group[\"membranes\"])[\"num_membranes\"]\n\n1\n\n\nTotal number of membranes.\n\n\n\nposition_scale\n\n\nattrs(group[\"membranes\"])[\"position_scale\"]\n\n3\n\n\nDefault: No effect\nPositions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\nThere is a subgroup for each membrane. The subgroups are named by the membrane index. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\ntype_id\n\n\nattrs(group[\"membranes/1\"])[\"type_id\"]\n\n1\n\n\nThis membrane’s type id.\n\n\n\n\n\n\n\n🔢 trilist\n\n\ncollect(group[\"membranes/1/trilist\"])\n\n3×1956 Matrix{Int64}:\n 568   23  313  682   39  353   80  575  …  692  246  114  268  326  378  961\n 442  440  185  104  270  917  167  833     581  337  629   84  730  517  716\n 502  320  391  662  181  964  191  231     503   48   95  375  647   80  497\n\n\nEach column is the 3 vertex indexes of a triangle. Indexes are one based, and follow the right hand rule. Looking at the triangle from the outside in, they have counterclockwise winding.\n\n\n\n🔢 vertlist\n\n\ncollect(group[\"membranes/1/vertlist\"])\n\n3×980 Matrix{Float64}:\n 889.75   531.25   548.5     629.75   …  1235.88   290.125  383.125  631.125\n 725.125  191.75   425.875   512.125      256.375  232.5    126.375  685.0\n 284.875  692.375  669.375  -155.0        145.0    436.25   560.125  459.625\n\n\nEach column is a vertex coordinate in nm.\n\n\n\n🔢 id\n\n\ncollect(group[\"membranes/1/id\"])\n\n980-element Vector{Int64}:\n  8310\n  5489\n  1956\n  1234\n  3527\n 13082\n 11479\n  7695\n  1433\n  3558\n  2511\n  2593\n  3248\n     ⋮\n 10174\n   970\n  9836\n  3276\n  3144\n   974\n  2897\n 12158\n 14632\n 10168\n  7317\n 12170\n\n\nArray of vertex IDs. Each vertex has an id which is assigned upon initialization and persists throughout its lifetime.\n\n\n\noptional 🔢 copynumbers\n\n\ncollect(group[\"membranes/1/copynumbers\"])\n\n3×980 Matrix{Int64}:\n 0  0  0  0  0  0  0  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0\n\n\nArray of vertex membrane species copynumbers. If the membrane has no defined species this dataset will not exist."
  },
  {
    "objectID": "reference/sitesinfo.html",
    "href": "reference/sitesinfo.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Abstractly, sites are an interface that allow more complex structures like filaments to interact with diffusing species and compartment reaction propensities.\nEach site type has an associated fixed species. During chemistry that fixed species count will always be the total counts of the site in the compartment.\nChemistry callbacks can try and pick a random site in a compartment to get specific information about exactly where in a compartment some event should happen.\nThese are the groups of sites currently in MEDYAN.jl:\n\n\nFilament sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament site.\n\n\nHow many monomer states in the plus direction this site looks at.\n\n\n\nHow many monomer states in the minus direction this site looks at.\n\n\n\nReturn site count at a monomer given states, A vector of MonomerState with length length(states) == getminusrange(filamentsite) + 1 + getplusrange(filamentsite)\nThe site count gets put in the compartment of the center monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomfilamentsite function\nMEDYAN.Context#filamentsites field\n\n\n\nMEDYAN.SysDef#filamentsite field\nMEDYAN.addfilamentsite! function\nMEDYAN.addfilament_reaction! function\n\n\n\n\n\nFilament end sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament end site.\n\n\nHow many monomer states this site looks at.\n\n\n\nTrue if the filament end site is on the minus end, false if on the plus end.\n\n\n\nReturn spacing needed for the filament end site reaction to happen, units of nm.\n\n\n\nReturn the filament end site count at the end of a filament with monomer states vector states The rate of filament end reaction will be modified by the brownian ratchet model:\nexp(-β*F*L) where F is the compression force on the filament end, and L is spacing(site).\nlength(states) == getrange(filamentendsite)\nThe site count gets put in the compartment of the end monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomfilamentendsite\nMEDYAN.Context#filamentendsites field\n\n\n\nMEDYAN.SysDef#filamentendsite field\nMEDYAN.addfilamentendsite!\nMEDYAN.addfilamentend_reaction!\n\n\n\n\n\nLink_2mon sites can only be associated with one link_2mon type. They can represent propensities for reactions to happen to a link_2mon attached to two monomers, like unbinding or motor walking, or a site for a diffusing species to interact with a bound link_2mon.\n\n\nA type T must implement the following functions to be a link_2mon site.\n\n\nReturn the site count given the state of the link_2mon, the minusftid, plusftid filament type ids, the minusmonomerstates, plusmonomerstates monomer states, and the positions and orientations of the two monomers.\nminusmonomerstates and plusmonomerstates should be collections of 3 MonomerState ordered from minus to plus end, with the link_2mon attached to the center monomer.\nIf a monomer doesn’t exist, its state should be input as zero.\nThe site count gets put in the compartment of the minus end of the link_2mon.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomlink_2mon_site\nMEDYAN.Context#link_2mon_sites field\n\n\n\nMEDYAN.SysDef#link_2mon_site field\nMEDYAN.add_link_2mon_site!\n\n\n\n\n\nLinkable sites represent a potential link between two monomers, potentially on two different filaments. The site count is added to the compartment of the potential monomer that could attach to the minus end of the link_2mon.\n\n\nA type T must implement the following functions to be a linkable site.\n\n\nReturn the maximum distance in nm of a linkable site.\n\n\n\nReturn the maximum linkablesitecount will return given a pair of monomers in linkable range.\n\n\n\nReturn if two monomers are in range to possibly link in the forward direction, and if they are in range to possibly link in the reverse direction.\n\n\n\nReturn the filament types of the minus and plus monomers.\n\n\n\nReturn the monomer step size starting with mid 0 in the search for potential linkable sites on the minus and plus ends respectively.\n1 searches every monomer. 2 searches every monomer with even mid …\nIf the plus and minus filament types are the same, then getmidsteps(site)[1] == getmidsteps(site)[2]\n\n\n\nReturn the site count of two monomers getting linked given their states, their positions, and their plus vectors. The monomers can be assumed to be in linkable range, from the correct filament types, and at the correct step.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomlinkablesite\nMEDYAN.Context#linkablesites field\n\n\n\nMEDYAN.SysDef#linkablesite field\nMEDYAN.addlinkablesite!\n\n\n\n\n\nCadherin sites can only be associated with the cadherin type. They can represent propensities for reactions to happen to a cadherin between one monomer and one membrane vertex.\n\n\nA type T must implement the following functions to be a cadherin site.\n\n\nReturn the site count given the state of the cadherin, the vid vertex id, the ftid filament type id, the vertexstate vertex state, the monomerstates monomer states, the positions of vertex and the monomer, and the orientation of the monomer.\nvertexstate should be the state of vertex on the one end of cadherin, when monomerstates should be the collection of 3 MonomerState ordered from minus to plus end, with the other end of cadherin attached to the center monomer.\nVertex state is defined to denote the reaction activity of vertices. The default state of vertex is one, which means the vertex is inert to chemical reaction.\nIf a monomer or a vertex doesn’t exist, its state should be input as zero.\nThe site count gets put in the compartment with the vertex.\n\n\n\n\n\n\n\n\n\nMEDYAN.Context#cadherinsites field\n\n\n\nMEDYAN.SysDef#cadherinsite field\nMEDYAN.addcadherinsite!"
  },
  {
    "objectID": "docstrings.html",
    "href": "docstrings.html",
    "title": "Docstrings",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\n\n\n\n\nBase.:*\n\n\n\n\nBase.copy\n\n\n\n\nBase.delete!\n\n\n\n\nBase.empty!\n\n\n\n\nBase.getindex\n\n\n\n\nBase.haskey\n\n\n\n\nBase.iterate\n\n\n\n\nBase.length\n\n\n\n\nBase.push!\n\n\n\n\nBase.setindex!\n\n\n\n\nMEDYAN.AgentNames\n\n\n\n\nMEDYAN.CadherinParams\n\n\n\n\nMEDYAN.CadherinState\n\n\n\n\nMEDYAN.Context\n\n\n\n\nMEDYAN.CubicGrid\n\n\n\n\nMEDYAN.FilamentEndSiteGeneral\n\n\n\n\nMEDYAN.FilamentSiteGeneral\n\n\n\n\nMEDYAN.Link2MonParams\n\n\n\n\nMEDYAN.Link2MonSiteCount\n\n\n\n\nMEDYAN.Link2MonSiteMonomerStateMatch\n\n\n\n\nMEDYAN.Link2MonSiteMotorCatch\n\n\n\n\nMEDYAN.Link2MonSiteMotorStall\n\n\n\n\nMEDYAN.Link2MonSiteOne\n\n\n\n\nMEDYAN.Link2MonSiteSlipBond\n\n\n\n\nMEDYAN.Link2MonState\n\n\n\n\nMEDYAN.LinkableSiteMinAngleRange\n\n\n\n\nMEDYAN.LinkableSiteRange\n\n\n\n\nMEDYAN.MembraneSiteDiffusing\n\n\n\n\nMEDYAN.MembraneSpeciesParams\n\n\n\n\nMEDYAN.MonomerName\n\n\n\n\nMEDYAN.SysDef\n\n\n\n\nMEDYAN.VertexName\n\n\n\n\nMEDYAN.adapt_membranes!\n\n\n\n\nMEDYAN.add_diffusion_coeff!\n\n\n\n\nMEDYAN.add_filament_params!\n\n\n\n\nMEDYAN.add_link_2mon!\n\n\n\n\nMEDYAN.add_link_2mon_site!\n\n\n\n\nMEDYAN.add_membranesitereaction!\n\n\n\n\nMEDYAN.addcadherin!\n\n\n\n\nMEDYAN.addcadherinsite!\n\n\n\n\nMEDYAN.adddiffusingcount_rand!\n\n\n\n\nMEDYAN.addfilament_reaction!\n\n\n\n\nMEDYAN.addfilamentend_reaction!\n\n\n\n\nMEDYAN.addfilamentendsite!\n\n\n\n\nMEDYAN.addfilamentsite!\n\n\n\n\nMEDYAN.addlinkablesite!\n\n\n\n\nMEDYAN.addmembranediffusingcount_rand!\n\n\n\n\nMEDYAN.addmembranesite!\n\n\n\n\nMEDYAN.addpossiblecadherinsite!\n\n\n\n\nMEDYAN.addreaction!\n\n\n\n\nMEDYAN.addreactioncallback!\n\n\n\n\nMEDYAN.addunbindinglink_2mon_site!\n\n\n\n\nMEDYAN.centerof\n\n\n\n\nMEDYAN.chem_adddiffusingcount!\n\n\n\n\nMEDYAN.chem_addfixedcount!\n\n\n\n\nMEDYAN.chem_depolymerize!\n\n\n\n\nMEDYAN.chem_newfilament!\n\n\n\n\nMEDYAN.chem_newlink_2mon!\n\n\n\n\nMEDYAN.chem_polymerize!\n\n\n\n\nMEDYAN.chem_removefilament!\n\n\n\n\nMEDYAN.chem_removelink_2mon!\n\n\n\n\nMEDYAN.chem_setlink_2mon_state!\n\n\n\n\nMEDYAN.chem_setmonomerstate!\n\n\n\n\nMEDYAN.compute_all_membrane_geometry!_system\n\n\n\n\nMEDYAN.defer_chem_caching!\n\n\n\n\nMEDYAN.fil_mon_states\n\n\n\n\nMEDYAN.fil_node_mon_ids\n\n\n\n\nMEDYAN.fil_node_positions\n\n\n\n\nMEDYAN.filter_grididat\n\n\n\n\nMEDYAN.filtype_fil_ids\n\n\n\n\nMEDYAN.gen_citation\n\n\n\n\nMEDYAN.grididat\n\n\n\n\nMEDYAN.is_chem_cache_valid\n\n\n\n\nMEDYAN.link_2mon_endnames\n\n\n\n\nMEDYAN.load_snapshot!\n\n\n\n\nMEDYAN.minimize_energy!\n\n\n\n\nMEDYAN.mon_3states\n\n\n\n\nMEDYAN.mon_exists\n\n\n\n\nMEDYAN.mon_minimized\n\n\n\n\nMEDYAN.mon_plusvector\n\n\n\n\nMEDYAN.mon_position\n\n\n\n\nMEDYAN.mon_position_plusvector\n\n\n\n\nMEDYAN.newfilament_rand!\n\n\n\n\nMEDYAN.newmembrane!\n\n\n\n\nMEDYAN.num_filtypes\n\n\n\n\nMEDYAN.randompoint\n\n\n\n\nMEDYAN.refresh_chem_cache!\n\n\n\n\nMEDYAN.resolve_all_filament_mesh_crossing!\n\n\n\n\nMEDYAN.run_chemistry!\n\n\n\n\nMEDYAN.set_chemboundary!\n\n\n\n\nMEDYAN.set_enable_cylinder_volume_exclusion!\n\n\n\n\nMEDYAN.set_mechboundary!\n\n\n\n\nMEDYAN.set_time!\n\n\n\n\nMEDYAN.sever_filament!\n\n\n\n\nMEDYAN.vertex_state\n\n\n\n\nNLSolversBase.value!!\n\n\n\n\nsrc/auxprocs.jl\n\n\n\n\nsrc/context.jl\n\n\n\n\nsrc/filamentendsites.jl\n\n\n\n\nsrc/filamentsites.jl\n\n\n\n\nsrc/grids.jl\n\n\n\n\nsrc/link_2mon_sites.jl\n\n\n\n\nsrc/linkablesites.jl\n\n\n\n\nsrc/membrane/membranesites.jl\n\n\n\n\nsrc/minimize_energy.jl\n\n\n\n\nsrc/sever_filament.jl\n\n\n\n\nsrc/sysdefs.jl\n\n\n\n\nsrc/trajectory-io/snapshot.jl\n\n\n\n\nsrc/util/bibliography.jl\n\n\n\n\nsrc/util/math/cuboidslicing.jl\n\n\n\n\n\nsrc/util/stableindex.jl\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Documentation for MEDYAN."
  },
  {
    "objectID": "index.html#warning-the-api-is-very-unstable-and-this-package-is-not-released-yet.",
    "href": "index.html#warning-the-api-is-very-unstable-and-this-package-is-not-released-yet.",
    "title": "MEDYAN.jl",
    "section": "Warning, the API is very unstable, and this package is not released yet.",
    "text": "Warning, the API is very unstable, and this package is not released yet.\nWelcome to Papoian Lab’s Mechanochemical Dynamics of Active Networks Julia package.\nThis is based on the C++ medyan command line tool also developed by the Papoian Lab.\nCopyright 2022, Papoian lab at the University of Maryland.\nThis code is distributed under the license found in this directory, license.txt."
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "MEDYAN.jl",
    "section": "Usage",
    "text": "Usage\nFirst install and run Julia https://julialang.org/downloads/\nThen if you haven’t yet, set up ssh keys with github.\nAlso, currently you may have to install git and ensure you have a .julia/config/startup.jl with\nENV[\"JULIA_PKG_USE_CLI_GIT\"]= \"true\"\nThen if you haven’t yet, install the MEDYANRegistry.\njulia -e '\n    using Pkg\n    Pkg.Registry.add(RegistrySpec(url = \"git@github.com:medyan-dev/MEDYANRegistry.git\"))\n    Pkg.Registry.add(RegistrySpec(url = \"https://github.com/JuliaRegistries/General\"))'\nFinally, to add the current MEDYAN.jl, in Julia run:\n] add git@github.com:medyan-dev/MEDYAN.jl.git\nTo add a specific commit id, for example 2d31e2a, in Julia run:\n] add \"git@github.com:medyan-dev/MEDYAN.jl.git\"#2d31e2a\nSee the docs for tutorials and more information."
  },
  {
    "objectID": "index.html#authors",
    "href": "index.html#authors",
    "title": "MEDYAN.jl",
    "section": "Authors",
    "text": "Authors\nActive developers:\n\n\n\nName\nEmail\n\n\n\n\nHaoran Ni\nhaoranni@umd.edu\n\n\nNathan Zimmerberg\nnzimmerb@umd.edu\n\n\nMengxin Gu\nmxgu1234@umd.edu\n\n\n\nAll developers including developers of C++ medyan:\nGaregin Papoian (gpapoian@umd.edu), Konstantin Popov, James Komianos, Aravind Chandrasekaran, Qin Ni, Carlos Floyd, Haoran Ni, Nathan Zimmerberg, Joshua Lucker, Mengxin Gu.\nAll general correspondence about the code and its applications should be directed to Garegin Papoian. All developer and more specific code, installation, and usage correspondence should be directed to Active developers via email or the issue tracker."
  },
  {
    "objectID": "index.html#running-tests",
    "href": "index.html#running-tests",
    "title": "MEDYAN.jl",
    "section": "Running tests",
    "text": "Running tests\nIn shell:\ncd test\njulia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=dirname(pwd()))); Pkg.instantiate()'\njulia --project\nIn julia repl:\ninclude(\"runtests.jl\")\nYou can also include individual test files to run just those tests."
  },
  {
    "objectID": "index.html#running-notebooks",
    "href": "index.html#running-notebooks",
    "title": "MEDYAN.jl",
    "section": "Running notebooks",
    "text": "Running notebooks\nTo run interactively in a Pluto Notebook, run the following shell commands:\ncd notebooks\njulia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=dirname(pwd()))); Pkg.instantiate()'\njulia --project -e 'import Pluto; Pluto.run()'\nTo generate static html files, run the following shell commands:\ncd notebooks\njulia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=dirname(pwd()))); Pkg.instantiate()'\njulia --project runnotebooks.jl"
  },
  {
    "objectID": "index.html#editing-documentation",
    "href": "index.html#editing-documentation",
    "title": "MEDYAN.jl",
    "section": "Editing Documentation",
    "text": "Editing Documentation\nFirst, if you haven’t yet, install quarto at least 1.2.\nRun the following to check your quarto installation has the julia kernel.\nquarto check jupyter\nYou may have to run the following after updating julia if jupyter doesn’t have the latest kernel.\nusing Pkg\nPkg.add(\"IJulia\")\nPkg.build(\"IJulia\")\nRun the following to set up the environment and create a preview. Any changes to files in docs should auto update.\n./docs/make.jl\nor\njulia docs/make.jl\nRun the following to refresh the docstrings for the site.\njulia --project=docs docs/make-docstrings.jl"
  }
]