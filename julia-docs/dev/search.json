[
  {
    "objectID": "reference/sitesinfo.html",
    "href": "reference/sitesinfo.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Abstractly, sites are an interface that allow more complex structures like filaments to interact with diffusing species and compartment reaction propensities.\nEach site type has an associated fixed species. During chemistry that fixed species count will always be the total counts of the site in the compartment.\nChemistry callbacks can try and pick a random site in a compartment to get specific information about exactly where in a compartment some event should happen.\nThese are the groups of sites currently in MEDYAN.jl:\n\n\nFilament sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament site.\n\n\nHow many monomer states in the plus direction this site looks at.\n\n\n\nHow many monomer states in the minus direction this site looks at.\n\n\n\nReturn site count at a monomer given states, A vector of MonomerState with length length(states) == getminusrange(filamentsite) + 1 + getplusrange(filamentsite)\nThe site count gets put in the compartment of the center monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomfilamentsite function\nMEDYAN.Context#filamentsites field\n\n\n\nMEDYAN.SysDef#filamentsite field\nMEDYAN.addfilamentsite! function\nMEDYAN.addfilament_reaction! function\n\n\n\n\n\nFilament end sites can only be associated with one filament type.\n\n\nA type T must implement the following functions to be a filament end site.\n\n\nHow many monomer states this site looks at.\n\n\n\nTrue if the filament end site is on the minus end, false if on the plus end.\n\n\n\nReturn spacing needed for the filament end site reaction to happen, units of nm.\n\n\n\nReturn the filament end site count at the end of a filament with monomer states vector states The rate of filament end reaction will be modified by the brownian ratchet model:\nexp(-β*F*L) where F is the compression force on the filament end, and L is spacing(site).\nlength(states) == getrange(filamentendsite)\nThe site count gets put in the compartment of the end monomer.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomfilamentendsite\nMEDYAN.Context#filamentendsites field\n\n\n\nMEDYAN.SysDef#filamentendsite field\nMEDYAN.addfilamentendsite!\nMEDYAN.addfilamentend_reaction!\n\n\n\n\n\nLink_2mon sites can only be associated with one link_2mon type. They can represent propensities for reactions to happen to a link_2mon attached to two monomers, like unbinding or motor walking, or a site for a diffusing species to interact with a bound link_2mon.\n\n\nA type T must implement the following functions to be a link_2mon site.\n\n\nReturn the site count given the state of the link_2mon, the minusftid, plusftid filament type ids, the minusmonomerstates, plusmonomerstates monomer states, and the positions and orientations of the two monomers.\nminusmonomerstates and plusmonomerstates should be collections of 3 MonomerState ordered from minus to plus end, with the link_2mon attached to the center monomer.\nIf a monomer doesn’t exist, its state should be input as zero.\nThe site count gets put in the compartment of the minus end of the link_2mon.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomlink_2mon_site\nMEDYAN.Context#link_2mon_sites field\n\n\n\nMEDYAN.SysDef#link_2mon_site field\nMEDYAN.add_link_2mon_site!\n\n\n\n\n\nLinkable sites represent a potential link between two monomers, potentially on two different filaments. The site count is added to the compartment of the potential monomer that could attach to the minus end of the link_2mon.\n\n\nA type T must implement the following functions to be a linkable site.\n\n\nReturn the maximum distance in nm of a linkable site.\n\n\n\nReturn the maximum linkablesitecount will return given a pair of monomers in linkable range.\n\n\n\nReturn if two monomers are in range to possibly link in the forward direction, and if they are in range to possibly link in the reverse direction.\n\n\n\nReturn the filament types of the minus and plus monomers.\n\n\n\nReturn the monomer step size starting with mid 0 in the search for potential linkable sites on the minus and plus ends respectively.\n1 searches every monomer. 2 searches every monomer with even mid …\nIf the plus and minus filament types are the same, then getmidsteps(site)[1] == getmidsteps(site)[2]\n\n\n\nReturn the site count of two monomers getting linked given their states, their positions, and their plus vectors. The monomers can be assumed to be in linkable range, from the correct filament types, and at the correct step.\n\n\n\n\n\n\n\n\n\nMEDYAN.pickrandomlinkablesite\nMEDYAN.Context#linkablesites field\n\n\n\nMEDYAN.SysDef#linkablesite field\nMEDYAN.addlinkablesite!\n\n\n\n\n\nCadherin sites can only be associated with the cadherin type. They can represent propensities for reactions to happen to a cadherin between one monomer and one membrane vertex.\n\n\nA type T must implement the following functions to be a cadherin site.\n\n\nReturn the site count given the state of the cadherin, the vid vertex id, the ftid filament type id, the vertexstate vertex state, the monomerstates monomer states, the positions of vertex and the monomer, and the orientation of the monomer.\nvertexstate should be the state of vertex on the one end of cadherin, when monomerstates should be the collection of 3 MonomerState ordered from minus to plus end, with the other end of cadherin attached to the center monomer.\nVertex state is defined to denote the reaction activity of vertices. The default state of vertex is one, which means the vertex is inert to chemical reaction.\nIf a monomer or a vertex doesn’t exist, its state should be input as zero.\nThe site count gets put in the compartment with the vertex.\n\n\n\n\n\n\n\n\n\nMEDYAN.Context#cadherinsites field\n\n\n\nMEDYAN.SysDef#cadherinsite field\nMEDYAN.addcadherinsite!"
  },
  {
    "objectID": "reference/fileformats.html",
    "href": "reference/fileformats.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "MEDYAN.jl uses Zarr v2 zip store for saving snapshots.\n\n\n\n\n\n\nOther Languages\n\n\n\nTo open the snapshots in python use zarr\n\n\n\n\nTrajectory outputs and logs are stored in a directory.\nThe folder contains a header.json file, a list.txt file, and a snapshots sub directory containing many snapshot$(NUMBER).zarr.zip files where NUMBER is the frame number of the snapshot.\nThe initial state returned by setup is stored in snapshot0.zarr.zip.\nInside the snapshot$(NUMBER).zarr.zip there is a medyan_context directory containing the snapshot of the MEDYAN.Context at the step. Other state may be stored in sibling directories to medyan_context.\nThe header.json file also has a top level \"medyan_context\" key with a value describing the system being simulated.\nOther header information may be under other top level keys.\nSee https://github.com/medyan-dev/MEDYANSimRunner.jl for details on the structure of the list.txt file.\n\n\n\nheader.json[\"medyan_context\"] contains static metadata about the simulation that is constant over time.\n\n\n\nusing MEDYAN\nimport JSON3\ncinit, s = MEDYAN.example_all_sites_context()\nJSON3.pretty(MEDYAN.header(cinit); allow_inf = true)\n\n{\n    \n\n\n\"version\": \"0.1.0\",\n    \"medyanInfo\": {\n\n\n        \"title\": \"MEDYAN.jl\",\n        \"version\": \"0.1.0\",\n        \"sourceCodeUrl\": \"https://github.com/medyan-dev/MEDYAN.jl\"\n    },\n    \"size\": {\n        \"x(nm)\": 2000,\n        \"y(nm)\": 500,\n        \"z(nm)\": 500\n    },\n    \"chem_grid_size\": {\n        \"nx\": 4,\n        \"ny\": 1,\n        \"nz\": 1,\n        \"voxel_x(nm)\": 500,\n        \"voxel_y(nm)\": 500,\n        \"voxel_z(nm)\": 500\n    },\n    \"diffusing_species\": [\n\n\n        {\n            \"name\": \"b\"\n        },\n        {\n            \"name\": \"c\"\n        }\n    ],\n    \"membrane_diffusing_species\": [\n        {\n            \"name\": \"ma\"\n        },\n        {\n            \"name\": \"mb\"\n        },\n        {\n            \"name\": \"mc\"\n        }\n    ],\n    \"fixed_species\": [\n        {\n            \"name\": \"d\"\n        },\n        {\n            \"name\": \"a\"\n        }\n    ],\n    \"filaments\": \n\n\n[\n        {\n            \"name\": \"a\",\n            \"radius(nm)\": 3,\n            \"monomerstates\": [\n                \"me\",\n                \"a\",\n                \"b\",\n                \"c\",\n                \"pe\"\n            ]\n        },\n        {\n            \"name\": \"b\",\n            \"radius(nm)\": 3,\n            \"monomerstates\": [\n                \"me\",\n                \"a\",\n                \"b\",\n                \"c\",\n                \"pe\"\n            ]\n        }\n    ],\n    \"link_2mons\": [\n        {\n            \"name\": \"a\"\n        },\n        {\n            \"name\": \"b\"\n        },\n        {\n            \"name\": \"c\"\n        },\n        {\n            \"name\": \"d\"\n        }\n    ]\n}\n\n\n\n\n\n\nA snapshot describes the state of a Context at a single point in time.\nA snapshot can be used to set the state of a Context if it was constructed with the same system and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nThe snapshot doesn’t hold the exact full state of a Context, simulations restarted from a snapshot may not have the exact same results because:\n\nThe snapshot doesn’t store the state of the random number generator.\nCoordinates may be rounded to save disk space.\nDictionaries and other internal data structures may get reordered and or resorted when the snapshot is loaded.\nMultithreading may be non deterministic.\n\nBut if rounding isn’t too extreme, the reloaded Context should have the same statistics.\n\n\nThe snapshot format is versioned by the “version” attribute. The current snapshot version is:\n\nusing MEDYAN\nMEDYAN.SNAPSHOT_VERSION\n\nv\"0.7.0\"\n\n\nCurrently before snapshot version 1.0.0 anything goes.\nAfter snapshot version 1.0.0 is released.\nSnapshots written with a previous snapshot version above v\"1\" should be readable. Snapshots written with a newer snapshot version are generally not readable.\nIf new agent types are added to MEDYAN.jl, usually only the minor version needs to be updated, as nothing special needs to be done to read older snapshot versions without that added agent type.\nIf new data is added to an existing agent type, also usually only the minor version needs to be increment, though the case of the new data not existing must be handled with some default.\nIf the way an existing agent type is stored significantly changes, such that external code analyzing the snapshot would need to be modified, the major version must be incremented. Also if possible there should be a function to update a snapshot from the old version to the new version.\n\n\nAny group, dataset, or attribute name prefixed with with “#” can change format or be removed without changing the snapshot version.\n“#experimental” is used for saving new types of agents or other data that doesn’t have a stable format yet.\n“#comment” is used for saving human readable comments that could change in format or wording.\n\n\n\n\n\nusing MEDYAN\nusing StorageTrees\ncinit, s = MEDYAN.example_all_sites_context()\ngroup = MEDYAN.snapshot(cinit)\n\n\n\n\n\n\n\nSnapshot 📂\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\ntime (s)\n\n\nattrs(group)[\"time (s)\"]\n\n0.0\n\n\nDefault: No change\nSee MEDYAN.set_time!\n\n\n\nversion\n\n\nattrs(group)[\"version\"]\n\n\"0.7.0\"\n\n\nDefault: No change\nSee Snapshot Versioning\n\n\n\nuuid\n\n\nattrs(group)[\"uuid\"]\n\n\"37eee81f-88ae-4d11-b6b3-d38e1ccf0a08\"\n\n\nMust be set to exactly “37eee81f-88ae-4d11-b6b3-d38e1ccf0a08”\nto be considered a valid MEDYAN snapshot.\n\n\n\n\n\n\n\n\n\n\n\n\n🔢\n\n\n\n\n\n\n\ndiffusingcounts\n\n\ncollect(group[\"diffusingcounts\"])\n\n2×4 Matrix{Int32}:\n 0   100   40  0\n 0  1000  400  0\n\n\nDefault: Empty\nIndexed by [species id, compartment id] to give count.\nSee MEDYAN.chem_adddiffusingcount!\n\n\n\nfixedcounts\n\n\ncollect(group[\"fixedcounts\"])\n\n2×4 Matrix{Float64}:\n 10.25  0.0  0.0   0.0\n  0.0   0.0  0.0  20.25\n\n\nDefault: Empty\nIndexed by [species id, compartment id] to give count.\nSee MEDYAN.chem_addfixedcount!\n\n\n\n\n\n\n\n\n\n\n\n\n📂\n\n\n\n\n\n\n\n\n\n\n\n\nchemboundary\n\n\n\n\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.set_chemboundary!\n\n\n🔢 capsules\n\n\ncollect(group[\"chemboundary/capsules\"])\n\n8×1 Matrix{Float64}:\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n 10000.0\n     1.0\n\n\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 planes\n\n\ncollect(group[\"chemboundary/planes\"])\n\n4×6 Matrix{Float64}:\n -10.0     10.0    0.0     0.0    0.0     0.0\n   0.0      0.0  -10.0    10.0    0.0     0.0\n   0.0      0.0    0.0     0.0  -10.0    10.0\n   0.0  20000.0    0.0  5000.0    0.0  5000.0\n\n\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nfilaments\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nposition_scale\n\n\nattrs(group[\"filaments\"])[\"position_scale\"]\n\n3\n\n\nDefault: No effect\nFilament positions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\nThere is a subgroup for each filament type with at least one filament. The subgroups are named by their filament type id. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n🔢 endloadforces\n\n\ncollect(group[\"filaments/1/endloadforces\"])\n\n2×2 Matrix{Float64}:\n 0.0  0.0\n 0.0  0.0\n\n\nFilament end load forces (pN).\nEach row is the load force on the minus and plus ends of a filament.\n\n\n\n🔢 fids\n\n\ncollect(group[\"filaments/1/fids\"])\n\n2-element Vector{Int32}:\n 1\n 2\n\n\nFilament ids.\n\n\n\n🔢 minusend_num_notminimized\n\n\ncollect(group[\"filaments/1/minusend_num_notminimized\"])\n\n2-element Vector{Int32}:\n 0\n 0\n\n\nNumber of newly added monomers to the filament minus ends since last minimization.\n\n\n\n🔢 plusend_num_notminimized\n\n\ncollect(group[\"filaments/1/plusend_num_notminimized\"])\n\n2-element Vector{Int32}:\n 0\n 0\n\n\nNumber of newly added monomers to the filament plus ends since last minimization.\n\n\n\n🔢 num_cylinders\n\n\ncollect(group[\"filaments/1/num_cylinders\"])\n\n2-element Vector{Int32}:\n 1\n 1\n\n\nNumber of cylinders per filament.\n\n\n\n🔢 num_monomers\n\n\ncollect(group[\"filaments/1/num_monomers\"])\n\n2-element Vector{Int32}:\n 9\n 9\n\n\nNumber of monomers per filament.\n\n\n\n🔢 node_mids\n\n\ncollect(group[\"filaments/1/node_mids\"])\n\n2-element Vector{Int32}:\n 1\n 1\n\n\nThe monomer ids at the minus ends of the cylinders.\n                                   |\n                        -----+-----|-----+-----\n    minus end <----       M  |  M  | (M) |  M        ----> plus end\n                        -----+-----|-----+-----\n                                   |\n                                   ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\n\n\n\n🔢 nodepositions\n\n\ncollect(group[\"filaments/1/nodepositions\"])\n\n4×3 Matrix{Float64}:\n 470.0  200.0  200.0\n 560.0  200.0  200.0\n 480.0  201.0  200.0\n 570.0  201.0  200.0\n\n\nEach row is a node position in nm.\n\n\n\n🔢 monomerstates\n\n\ncollect(group[\"filaments/1/monomerstates\"])\n\n18-element Vector{UInt8}:\n 0x01\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x05\n 0x01\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x02\n 0x05\n\n\nMonomer states.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlink_2mons\n\n\n\n\n\nThere is a subgroup for each link_2mon type with at least one link_2mon. The subgroups are named by their link_2mon type id. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nnum_link_2mons\n\n\nattrs(group[\"link_2mons/1\"])[\"num_link_2mons\"]\n\n2\n\n\nNumber of link_2mons of this type.\n\n\n\n\n\n\n\n🔢 endnames\n\n\ncollect(group[\"link_2mons/1/endnames\"])\n\n2×6 Matrix{Int64}:\n 1  1  2  1  1  2\n 1  1  2  1  2  2\n\n\nThe pairs of monomers that the link_2mons are linked between. The monomer pairs are directed and unique.\nEach row of this matrix represents two monomers. The 6 integers per row are in order:\n\nMinus end filament type id.\nMinus end filament id.\nMinus end monomer id.\nPlus end filament type id.\nPlus end filament id.\nPlus end monomer id.\n\n\n\n\n📂 state\n\nDefault: default link_2mon_state\nSee MEDYAN.chem_setlink_2mon_state! and MEDYAN.Link2MonState\nThe state of a link_2mon, organized in a nested struct of vector like form. Any static arrays will be unwrapped into a tuple of vectors, in column major order. The “name” attribute of each subgroup and dataset is the corresponding property name in the StructArray Any property in the default state that isn’t in the snapshot will stay at its default value.\n\ngroup[\"link_2mons/1/state\"]\n\n📂 \n├─ \"1\" ⇒ 📂 🏷️\"name\" => \"chemstate\", \n│        ├─ \"1\" ⇒ 🔢 2 Int64 🏷️\"name\" => \"a\", \n│        └─ \"2\" ⇒ 🔢 2 Float64 🏷️\"name\" => \"b\", \n├─ \"2\" ⇒ 📂 🏷️\"name\" => \"mechstate\", \n│        └─ \"1\" ⇒ 📂 🏷️\"name\" => \"â\", \n│                 ├─ \"1\" ⇒ 🔢 2 Float32 🏷️\"name\" => \"1\", \n│                 ├─ \"2\" ⇒ 🔢 2 Float32 🏷️\"name\" => \"2\", \n│                 └─ \"3\" ⇒ 🔢 2 Float32 🏷️\"name\" => \"3\", \n└─ \"3\" ⇒ 🔢 2 Bool 🏷️\"name\" => \"is_minimized\", \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmechboundary\n\n\n\n\n\nThere is a dataset for each type of boundary, the total boundary is an intersection of the following.\nSee MEDYAN.set_mechboundary!\n\n\n🔢 capsules\n\n\ncollect(group[\"mechboundary/capsules\"])\n\n8×1 Matrix{Float64}:\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n     0.0\n 10000.0\n     1.0\n\n\nDefault: Empty\nEach column of the dataset is a capsule.\n\n\n\n🔢 planes\n\n\ncollect(group[\"mechboundary/planes\"])\n\n4×6 Matrix{Float64}:\n -10.0     10.0    0.0     0.0    0.0     0.0\n   0.0      0.0  -10.0    10.0    0.0     0.0\n   0.0      0.0    0.0     0.0  -10.0    10.0\n   0.0  20000.0    0.0  5000.0    0.0  5000.0\n\n\nDefault: Empty\nEach column of the dataset is a plane.\n\n\n\n\n\n\n\n\n\n\n\n\nmembranes\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\nnum_membranes\n\n\nattrs(group[\"membranes\"])[\"num_membranes\"]\n\n1\n\n\nTotal number of membranes.\n\n\n\nposition_scale\n\n\nattrs(group[\"membranes\"])[\"position_scale\"]\n\n3\n\n\nDefault: No effect\nPositions were rounded to the nearest 2^-position_scale nm when saved.\n\n\n\n\n\nThere is a subgroup for each membrane. The subgroups are named by the membrane index. For example:\n\n\n\n\n\n\n\n📂 1\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️\n\n\n\n\n\n\n\ntype_id\n\n\nattrs(group[\"membranes/1\"])[\"type_id\"]\n\n1\n\n\nThis membrane’s type id.\n\n\n\n\n\n\n\n🔢 trilist\n\n\ncollect(group[\"membranes/1/trilist\"])\n\n3×1956 Matrix{Int64}:\n 568   23  313  682   39  353   80  575  …  692  246  114  268  326  378  961\n 442  440  185  104  270  917  167  833     581  337  629   84  730  517  716\n 502  320  391  662  181  964  191  231     503   48   95  375  647   80  497\n\n\nEach column is the 3 vertex indexes of a triangle. Indexes are one based, and follow the right hand rule. Looking at the triangle from the outside in, they have counterclockwise winding.\n\n\n\n🔢 vertlist\n\n\ncollect(group[\"membranes/1/vertlist\"])\n\n3×980 Matrix{Float64}:\n 889.75   531.25   548.5     629.75   …  1235.88   290.125  383.125  631.125\n 725.125  191.75   425.875   512.125      256.375  232.5    126.375  685.0\n 284.875  692.375  669.375  -155.0        145.0    436.25   560.125  459.625\n\n\nEach column is a vertex coordinate in nm.\n\n\n\n🔢 id\n\n\ncollect(group[\"membranes/1/id\"])\n\n980-element Vector{Int64}:\n  8310\n  5489\n  1956\n  1234\n  3527\n 13082\n 11479\n  7695\n  1433\n  3558\n  2511\n  2593\n  3248\n     ⋮\n 10174\n   970\n  9836\n  3276\n  3144\n   974\n  2897\n 12158\n 14632\n 10168\n  7317\n 12170\n\n\nArray of vertex IDs. Each vertex has an id which is assigned upon initialization and persists throughout its lifetime.\n\n\n\noptional 🔢 copynumbers\n\n\ncollect(group[\"membranes/1/copynumbers\"])\n\n3×980 Matrix{Int64}:\n 0  0  0  0  0  0  0  0  0  0  0  0  0  …  0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0\n 0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0\n\n\nArray of vertex membrane species copynumbers. If the membrane has no defined species this dataset will not exist."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "src/sysdefs.jl\n\nMEDYAN.StateDef\nMEDYAN.SysDef\nadd_diffusion_coeff!\naddreaction!\naddreactioncallback!\nadd_filament_params!\naddfilamentsite!\naddfilament_reaction!\naddfilamentendsite!\naddfilamentend_reaction!\nadd_link_2mon!\n\n\n\n\n\nMEDYAN.Context\ndeepcopy, note: rng is shared\n\n\n\n\n\nBase.empty!\nload_snapshot!\nchem_newfilament!\nchem_removefilament!\nchem_polymerize!\nchem_depolymerize!\nchem_setmonomerstate!\nchem_newlink_2mon!\nchem_removelink_2mon!\nchem_setlink_2mon_state!\nchem_adddiffusingcount!\nchem_addfixedcount!\nadddiffusingcount_rand!\nnewfilament_rand!\nset_time!\nset_enable_cylinder_volume_exclusion!\nset_chemboundary!\nset_mechboundary!\n\n\n\n\n\nnum_filtypes\nfiltype_fil_ids\nfil_node_positions\nfil_node_mon_ids\nfil_mon_states\nmon_exists\nmon_minimized\nmon_position\nmon_plusvector\nmon_position_plusvector\nmon_3states\n\n\n\n\n\nrun_chemistry!\nminimize_energy!\n\n\n\n\n\n\n\n\n\n\nfilament sites\nfilament end sites\nlink_2mon sites\nlinkable sites"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Documentation for MEDYAN."
  },
  {
    "objectID": "index.html#warning-the-api-is-very-unstable-and-this-package-is-not-released-yet.",
    "href": "index.html#warning-the-api-is-very-unstable-and-this-package-is-not-released-yet.",
    "title": "MEDYAN.jl",
    "section": "Warning, the API is very unstable, and this package is not released yet.",
    "text": "Warning, the API is very unstable, and this package is not released yet.\nWelcome to Papoian Lab’s Mechanochemical Dynamics of Active Networks Julia package.\nThis is based on the C++ medyan command line tool also developed by the Papoian Lab.\nCopyright 2022, Papoian lab at the University of Maryland.\nThis code is distributed under the license found in this directory, license.txt."
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "MEDYAN.jl",
    "section": "Usage",
    "text": "Usage\nFirst install and run Julia https://julialang.org/downloads/\nThen if you haven’t yet, set up ssh keys with github.\nAlso, currently you may have to install git and ensure you have a .julia/config/startup.jl with\nENV[\"JULIA_PKG_USE_CLI_GIT\"]= \"true\"\nThen if you haven’t yet, install the MEDYANRegistry.\njulia -e '\n    using Pkg\n    Pkg.Registry.add(RegistrySpec(url = \"git@github.com:medyan-dev/MEDYANRegistry.git\"))\n    Pkg.Registry.add(RegistrySpec(url = \"https://github.com/JuliaRegistries/General\"))'\nFinally, to add the current MEDYAN.jl, in Julia run:\n] add git@github.com:medyan-dev/MEDYAN.jl.git\nTo add a specific commit id, for example 2d31e2a, in Julia run:\n] add \"git@github.com:medyan-dev/MEDYAN.jl.git\"#2d31e2a\nSee the docs for tutorials and more information."
  },
  {
    "objectID": "index.html#authors",
    "href": "index.html#authors",
    "title": "MEDYAN.jl",
    "section": "Authors",
    "text": "Authors\nActive developers:\n\n\n\nName\nEmail\n\n\n\n\nHaoran Ni\nhaoranni@umd.edu\n\n\nNathan Zimmerberg\nnzimmerb@umd.edu\n\n\nMengxin Gu\nmxgu1234@umd.edu\n\n\n\nAll developers including developers of C++ medyan:\nGaregin Papoian (gpapoian@umd.edu), Konstantin Popov, James Komianos, Aravind Chandrasekaran, Qin Ni, Carlos Floyd, Haoran Ni, Nathan Zimmerberg, Joshua Lucker, Mengxin Gu.\nAll general correspondence about the code and its applications should be directed to Garegin Papoian. All developer and more specific code, installation, and usage correspondence should be directed to Active developers via email or the issue tracker."
  },
  {
    "objectID": "index.html#running-tests",
    "href": "index.html#running-tests",
    "title": "MEDYAN.jl",
    "section": "Running tests",
    "text": "Running tests\nIn shell:\ncd test\njulia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=dirname(pwd()))); Pkg.instantiate()'\njulia --project\nIn julia repl:\ninclude(\"runtests.jl\")\nYou can also include individual test files to run just those tests."
  },
  {
    "objectID": "index.html#running-notebooks",
    "href": "index.html#running-notebooks",
    "title": "MEDYAN.jl",
    "section": "Running notebooks",
    "text": "Running notebooks\nTo run interactively in a Pluto Notebook, run the following shell commands:\ncd notebooks\njulia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=dirname(pwd()))); Pkg.instantiate()'\njulia --project -e 'import Pluto; Pluto.run()'\nTo generate static html files, run the following shell commands:\ncd notebooks\njulia --project -e 'using Pkg; Pkg.develop(PackageSpec(path=dirname(pwd()))); Pkg.instantiate()'\njulia --project runnotebooks.jl"
  },
  {
    "objectID": "index.html#editing-documentation",
    "href": "index.html#editing-documentation",
    "title": "MEDYAN.jl",
    "section": "Editing Documentation",
    "text": "Editing Documentation\nFirst, if you haven’t yet, install quarto at least 1.2.\nRun the following to check your quarto installation has the julia kernel.\nquarto check jupyter\nYou may have to run the following after updating julia if jupyter doesn’t have the latest kernel.\nusing Pkg\nPkg.add(\"IJulia\")\nPkg.build(\"IJulia\")\nRun the following to set up the environment and create a preview. Any changes to files in docs should auto update.\n./docs/make.jl\nor\njulia docs/make.jl\nRun the following to refresh the docstrings for the site.\njulia --project=docs docs/make-docstrings.jl"
  },
  {
    "objectID": "docstrings.html",
    "href": "docstrings.html",
    "title": "Docstrings",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\n\n\n\n\nBase.:*\n\n\n\n\nBase.copy\n\n\n\n\nBase.delete!\n\n\n\n\nBase.empty!\n\n\n\n\nBase.getindex\n\n\n\n\nBase.haskey\n\n\n\n\nBase.iterate\n\n\n\n\nBase.length\n\n\n\n\nBase.push!\n\n\n\n\nBase.setindex!\n\n\n\n\nMEDYAN.CadherinParams\n\n\n\n\nMEDYAN.CadherinState\n\n\n\n\nMEDYAN.Context\n\n\n\n\nMEDYAN.CubicGrid\n\n\n\n\nMEDYAN.FilamentEndSiteGeneral\n\n\n\n\nMEDYAN.FilamentSiteGeneral\n\n\n\n\nMEDYAN.Link2MonParams\n\n\n\n\nMEDYAN.Link2MonSiteCount\n\n\n\n\nMEDYAN.Link2MonSiteMonomerStateMatch\n\n\n\n\nMEDYAN.Link2MonSiteMotorCatch\n\n\n\n\nMEDYAN.Link2MonSiteMotorStall\n\n\n\n\nMEDYAN.Link2MonSiteOne\n\n\n\n\nMEDYAN.Link2MonSiteSlipBond\n\n\n\n\nMEDYAN.Link2MonState\n\n\n\n\nMEDYAN.LinkableSiteMinAngleRange\n\n\n\n\nMEDYAN.LinkableSiteRange\n\n\n\n\nMEDYAN.MembraneSiteDiffusing\n\n\n\n\nMEDYAN.MembraneSpeciesParams\n\n\n\n\nMEDYAN.MonomerName\n\n\n\n\nMEDYAN.VertexName\n\n\n\n\nMEDYAN.adapt_membranes!\n\n\n\n\nMEDYAN.add_diffusion_coeff!\n\n\n\n\nMEDYAN.add_filament_params!\n\n\n\n\nMEDYAN.add_link_2mon!\n\n\n\n\nMEDYAN.add_link_2mon_site!\n\n\n\n\nMEDYAN.add_membranesitereaction!\n\n\n\n\nMEDYAN.addcadherin!\n\n\n\n\nMEDYAN.addcadherinsite!\n\n\n\n\nMEDYAN.adddiffusingcount_rand!\n\n\n\n\nMEDYAN.addfilament_reaction!\n\n\n\n\nMEDYAN.addfilamentend_reaction!\n\n\n\n\nMEDYAN.addfilamentendsite!\n\n\n\n\nMEDYAN.addfilamentsite!\n\n\n\n\nMEDYAN.addlinkablesite!\n\n\n\n\nMEDYAN.addmembranediffusingcount_rand!\n\n\n\n\nMEDYAN.addmembranesite!\n\n\n\n\nMEDYAN.addpossiblecadherinsite!\n\n\n\n\nMEDYAN.addreaction!\n\n\n\n\nMEDYAN.addreactioncallback!\n\n\n\n\nMEDYAN.addunbindinglink_2mon_site!\n\n\n\n\nMEDYAN.chem_adddiffusingcount!\n\n\n\n\nMEDYAN.chem_addfixedcount!\n\n\n\n\nMEDYAN.chem_depolymerize!\n\n\n\n\nMEDYAN.chem_newfilament!\n\n\n\n\nMEDYAN.chem_newlink_2mon!\n\n\n\n\nMEDYAN.chem_polymerize!\n\n\n\n\nMEDYAN.chem_removefilament!\n\n\n\n\nMEDYAN.chem_removelink_2mon!\n\n\n\n\nMEDYAN.chem_setlink_2mon_state!\n\n\n\n\nMEDYAN.chem_setmonomerstate!\n\n\n\n\nMEDYAN.compute_all_membrane_geometry!_system\n\n\n\n\nMEDYAN.defer_chem_caching!\n\n\n\n\nMEDYAN.fil_mon_states\n\n\n\n\nMEDYAN.fil_node_mon_ids\n\n\n\n\nMEDYAN.fil_node_positions\n\n\n\n\nMEDYAN.filtype_fil_ids\n\n\n\n\nMEDYAN.gen_citation\n\n\n\n\nMEDYAN.is_chem_cache_valid\n\n\n\n\nMEDYAN.load_snapshot!\n\n\n\n\nMEDYAN.minimize_energy!\n\n\n\n\nMEDYAN.mon_3states\n\n\n\n\nMEDYAN.mon_exists\n\n\n\n\nMEDYAN.mon_minimized\n\n\n\n\nMEDYAN.mon_plusvector\n\n\n\n\nMEDYAN.mon_position\n\n\n\n\nMEDYAN.mon_position_plusvector\n\n\n\n\nMEDYAN.newfilament_rand!\n\n\n\n\nMEDYAN.newmembrane!\n\n\n\n\nMEDYAN.num_filtypes\n\n\n\n\nMEDYAN.refresh_chem_cache!\n\n\n\n\nMEDYAN.resolve_all_filament_mesh_crossing!\n\n\n\n\nMEDYAN.run_chemistry!\n\n\n\n\nMEDYAN.set_chemboundary!\n\n\n\n\nMEDYAN.set_enable_cylinder_volume_exclusion!\n\n\n\n\nMEDYAN.set_mechboundary!\n\n\n\n\nMEDYAN.set_time!\n\n\n\n\nMEDYAN.vertex_state\n\n\n\n\nNLSolversBase.value!!\n\n\n\n\nsrc/auxprocs.jl\n\n\n\n\nsrc/context.jl\n\n\n\n\nsrc/filamentendsites.jl\n\n\n\n\nsrc/filamentsites.jl\n\n\n\n\nsrc/grids.jl\n\n\n\n\nsrc/link_2mon_sites.jl\n\n\n\n\nsrc/linkablesites.jl\n\n\n\n\nsrc/membrane/membranesites.jl\n\n\n\n\nsrc/minimize_energy.jl\n\n\n\n\nsrc/sysdefs.jl\n\n\n\n\nsrc/trajectory-io/snapshot.jl\n\n\n\n\nsrc/util/bibliography.jl\n\n\n\n\nsrc/util/math/cuboidslicing.jl\n\n\n\n\n\nsrc/util/stableindex.jl\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "docstrings/medyan.cadherinstate-0cd5353e58a90ec2.html",
    "href": "docstrings/medyan.cadherinstate-0cd5353e58a90ec2.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "There is one instance of this per cadherin.\n\nchemstate::NamedTuple: Other state.\nmechstate::NamedTuple: Used in link_2mon force calculation.\nis_minimized::Bool: Set to true after minimization"
  },
  {
    "objectID": "docstrings/medyan.load_snapshot--e534be293ce74465.html",
    "href": "docstrings/medyan.load_snapshot--e534be293ce74465.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "load_snapshot!(c::Context,group::StorageTrees.ZGroup)\nEmpty the context and load the state saved in the snapshot group.\nc should be constructed with the same SysDef and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nSee Snapshot group for more details."
  },
  {
    "objectID": "docstrings/medyan.chem_adddiffusingcount--2264be341b81a600.html",
    "href": "docstrings/medyan.chem_adddiffusingcount--2264be341b81a600.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_adddiffusingcount!(c::Context, sid, cid, inccount)\nAdd inccount to diffusing species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/medyan.run_chemistry--dda22fac5c555b9e.html",
    "href": "docstrings/medyan.run_chemistry--dda22fac5c555b9e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "run_chemistry!(c::Context, Δt)\nRun chemistry for Δt time.\nUpdate c.time."
  },
  {
    "objectID": "docstrings/medyan.set_enable_cylinder_volume_exclusion--38c20ab68ab8bf1a.html",
    "href": "docstrings/medyan.set_enable_cylinder_volume_exclusion--38c20ab68ab8bf1a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_enable_cylinder_volume_exclusion!(\n    c::MEDYAN.Context,\n    x::Bool\n) -> Bool\nAre cylinder volume exclusion forces calculated."
  },
  {
    "objectID": "docstrings/medyan.mon_plusvector-b7271c7721602813.html",
    "href": "docstrings/medyan.mon_plusvector-b7271c7721602813.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_plusvector(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> StaticArraysCore.SVector{3, Float64}\nReturn the unit vector toward the plus end of the filament."
  },
  {
    "objectID": "docstrings/medyan.num_filtypes-b9943bbf7a9c7781.html",
    "href": "docstrings/medyan.num_filtypes-b9943bbf7a9c7781.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "num_filtypes(c::MEDYAN.Context) -> Int64\nReturn the number of filament types."
  },
  {
    "objectID": "docstrings/medyan.is_chem_cache_valid-8336a8adc58a252f.html",
    "href": "docstrings/medyan.is_chem_cache_valid-8336a8adc58a252f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "is_chem_cache_valid(c::Context)::Bool\nReturn true if the chemistry cache is valid, false otherwise."
  },
  {
    "objectID": "docstrings/medyan.link2monparams-d960d08f0808df0c.html",
    "href": "docstrings/medyan.link2monparams-d960d08f0808df0c.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Link2mon Parameters, there is one instance of this per link2mon type\n\ndefaultstate::MEDYAN.Link2MonState\nmechparams::Any\nno_collide::Bool: if true, allows cylinders this link_2mon type connects and adjacent cylinders to clip"
  },
  {
    "objectID": "docstrings/medyan.addfilamentend_reaction--83ec3db37b4e2130.html",
    "href": "docstrings/medyan.addfilamentend_reaction--83ec3db37b4e2130.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add filament end reaction. Return s. Add a filamentendsite and reaction with callback to change the filaments. This can be used for polymerization, depolymeriation, and changing end state.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentendsitename::Symbol: the new name of the filamentendsite added. This can be used as a catalyst in other reactions.\nisminusend::Bool: true if changing the minus end, false if changing the plus end.\nchangedendstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the end monomer states, the first is the states to match. The second is the new monomer states after the reaction. If the second has more states than the first, new monomers will be added, if the second has less, monomers will be removed. Ordered minus end first.\nspacing::Float64: Space needed at the filament end for this reaction. (nm) ratefactor= exp(-β*spacing*loadforce) where β is 1/kT, loadforce is the external force pushing axially on the end of the filament. and ratefactor affects this reaction propensity and any others using filamentendsitename\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentendsite.$(filamenttypename).$(filamentendsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentendsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nstatedef = StateDef(\n    diffusingspeciesnames= [:a,],\n    filamentnames= [(:filname,[\n                            :plus,\n                            :mid,\n                            :minus,\n                        ]),\n    ],\n)\ns= SysDef(statedef)\nmonomerspacing= 2.7\n#minus end polymerization\naddfilamentend_reaction!(s, :filname, :pm, true,\n    [:minus]=>[:minus,:mid], monomerspacing,\n    \"diffusing.a -->\", 10E3, 1,\n)\n#plus end depolymerization\naddfilamentend_reaction!(s, :filname, :dpp, false,\n    [:mid,:plus]=>[:plus], 0.0,\n    \"--> diffusing.a\", 1.75E-3, 0,\n)"
  },
  {
    "objectID": "docstrings/medyan.chem_removelink_2mon--e25a3fd69f791cd0.html",
    "href": "docstrings/medyan.chem_removelink_2mon--e25a3fd69f791cd0.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_removelink_2mon!(c::Context, ltid::Int, lid::Int64)\nRemove a link_2mon of type id ltid with id lid.\nError if the specified link_2mon doesn’t exist.\nDon’t modify monomer states."
  },
  {
    "objectID": "docstrings/medyan.link2monsitecount-ab4fcc1eb50c2313.html",
    "href": "docstrings/medyan.link2monsitecount-ab4fcc1eb50c2313.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Returns link_2mon_state.chemstate.sitecount"
  },
  {
    "objectID": "docstrings/medyan.addfilamentendsite--95612d72d1fda05f.html",
    "href": "docstrings/medyan.addfilamentendsite--95612d72d1fda05f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addfilamentendsite!(s::SysDef,filamenttypename::Symbol,filamentendsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.set_time--a6dd8f73f68a3759.html",
    "href": "docstrings/medyan.set_time--a6dd8f73f68a3759.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_time!(c::MEDYAN.Context, x::Float64) -> Float64\nTime (s)"
  },
  {
    "objectID": "docstrings/medyan.add_link_2mon_site--b9548c4a2d23aac9.html",
    "href": "docstrings/medyan.add_link_2mon_site--b9548c4a2d23aac9.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "add_link_2mon_site!(s::SysDef,link_2mon_typename::Symbol,link_2mon_sitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.chem_newfilament--7a45f2860949bee3.html",
    "href": "docstrings/medyan.chem_newfilament--7a45f2860949bee3.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_newfilament!(c::Context; ftid=1, monomerstates, node_mids, nodepositions)\nReturn the filament id of a new filament.\nError if the filament isn’t initially over 2 monomers long.\nNewly added filaments don’t have linkable sites, until after minimization.\n\n\n\nftid=1: filament type id.\nmonomerstates: Collection of the MonomerState of the monomers in the new filament. In order from minus end to plus end.\nlength(monomerstates)>1\nnodepositions: Collection of SVector{3,Float64}. The positions of the nodes, monomers are between nodes.\nnode_mids: Collection of Integer. The monomer ids at (slightly plus side of) the nodepositions\n                               |\n                    -----+-----|-----+-----\nminus end <----       M  |  M  | (M) |  M        ----> plus end\n                    -----+-----|-----+-----\n                               |\n                               ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\nlength(node_mids) == length(nodepositions) - 1\nendloadforces=(0.0=>0.0): end load forces, usually don’t use this, because load forces will automatically get updated at the next minimization."
  },
  {
    "objectID": "docstrings/medyan.filtype_fil_ids-d333c38b9f9b3584.html",
    "href": "docstrings/medyan.filtype_fil_ids-d333c38b9f9b3584.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "filtype_fil_ids(\n    c::MEDYAN.Context,\n    ftid::Int64\n) -> Vector{Int64}\nReturn a read only iterable of all filament ids of filament type ftid.\nThis can be invalid after any mutations to context, so collect if needed."
  },
  {
    "objectID": "docstrings/medyan.addmembranesite--892875b2c079002d.html",
    "href": "docstrings/medyan.addmembranesite--892875b2c079002d.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addmembranesite!(\n    s::MEDYAN.SysDef,\n    membranesitename::Symbol,\n    site\n) -> MEDYAN.SysDef\nAdd a new site with a specified name. During this process, a new fixed species is created suffixed with “membranesite.”."
  },
  {
    "objectID": "docstrings/medyan.cubicgrid-fe4b7cc2dceb0431.html",
    "href": "docstrings/medyan.cubicgrid-fe4b7cc2dceb0431.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "n::StaticArraysCore.SVector{3, Int64}\ncompartmentsize::Float64"
  },
  {
    "objectID": "docstrings/medyan.compute_all_membrane_geometry-_system-05b4d2a32e31560c.html",
    "href": "docstrings/medyan.compute_all_membrane_geometry-_system-05b4d2a32e31560c.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Updates all membrane geometries used across various parts of MEDYAN.\nThe list of all items can be found in the document for MEDYAN.compute_geometry!_system function.\nKeyword parameters:\n\ninclude_ff::Bool: If true, compute_geometry! used in energy computations will be applied as well, requiring vectorization of the membrane. This happens before system geometry computation in case some fields are overriden."
  },
  {
    "objectID": "docstrings/nlsolversbase.value---d4fdd3b317023c0e.html",
    "href": "docstrings/nlsolversbase.value---d4fdd3b317023c0e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Force (re-)evaluation of the objective value at x. Returns f(x) and stores the value in obj.F also calculates the gradient and stores it in obj.DF"
  },
  {
    "objectID": "docstrings/medyan.adapt_membranes--1d26092defd0f4fa.html",
    "href": "docstrings/medyan.adapt_membranes--1d26092defd0f4fa.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Remesh all membrane meshes."
  },
  {
    "objectID": "docstrings/medyan.add_diffusion_coeff--a77d1ef833cfdedd.html",
    "href": "docstrings/medyan.add_diffusion_coeff--a77d1ef833cfdedd.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "add_diffusion_coeff!(s::SysDef, diffusing_name::Symbol, diffusing_coeff::Float64)\nAdd the diffusing species to the system with diffusion coefficent in units of (nm²/s). Return s."
  },
  {
    "objectID": "docstrings/medyan.link2monsitemonomerstatematch-c495443de74016ce.html",
    "href": "docstrings/medyan.link2monsitemonomerstatematch-c495443de74016ce.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Returns 1.0 if the monomer states match, otherwise, returns 0.0.\n\nminusstate::Tuple{UInt8, UInt8, UInt8}: minus end monomer state\nplusstate::Tuple{UInt8, UInt8, UInt8}: plus end monomer state"
  },
  {
    "objectID": "docstrings/base.copy-4ca5eb8401ab10b2.html",
    "href": "docstrings/base.copy-4ca5eb8401ab10b2.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Shallow copy, https://stackoverflow.com/questions/51956958/how-to-copy-a-struct-in-julia"
  },
  {
    "objectID": "docstrings/medyan.filamentsitegeneral-0d87ce44fed17b2c.html",
    "href": "docstrings/medyan.filamentsitegeneral-0d87ce44fed17b2c.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "General filament site just matches monomer states\n\ncenter::Int64: index of center monomer in states\nstates::Vector{UInt8}: monomer states to match"
  },
  {
    "objectID": "docstrings/base.length-7ea31a421de7d258.html",
    "href": "docstrings/base.length-7ea31a421de7d258.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Total number of IDs in use.\n\n\n\n\n\n\n\n\n\n\n\n\nTotal number of compartments in the grid"
  },
  {
    "objectID": "docstrings/medyan.mon_minimized-5b17adaf7d8a4f62.html",
    "href": "docstrings/medyan.mon_minimized-5b17adaf7d8a4f62.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_minimized(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Bool\nReturn true iff the monomer has been minimized"
  },
  {
    "objectID": "docstrings/medyan.add_membranesitereaction--59d1fe245302e071.html",
    "href": "docstrings/medyan.add_membranesitereaction--59d1fe245302e071.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add a membrane site with the corresponding reaction with callback.\nKeyword arguments:\n\ns: SysDef.\nname_newmembranesite: Symbol.\nmembranediffusingreactants: Vector of symbols as membrane reactants. 0 or 1 reactant is currently supported.\nmembranediffusingproducts: Vector of symbols as membrane products.\nreactionexpr_extra: Reaction expression for other species involved.\nrate: Float.\nchangerage_bypotentialenergy: Whether the rate is affected by potential energy.\ninvvolumepower: rate scaling with compartment volume.\n\nNotes:\n\nIf error occurs, this function does not ensure that s is unchanged."
  },
  {
    "objectID": "docstrings/medyan.membranesitediffusing-66734014eb12ddb1.html",
    "href": "docstrings/medyan.membranesitediffusing-66734014eb12ddb1.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Allows up to 1 membrane diffusing species as reactants. Also stores net stoich of membrane diffusing species.\n\nid_membranediffusing_reactant::Int64: Set to 0 if no membrane diffusing species is involved.\ncanchangerate_bypotentialenergy::Bool: Whether the reaction rate depends on reactant species potential energy.\nmembranediffusingnet_stoich::Vector{Pair{Int64, Int64}}: Pairs of membrane diffusing species index => Δcount"
  },
  {
    "objectID": "docstrings/medyan.gen_citation-5a613a4d19801a8b.html",
    "href": "docstrings/medyan.gen_citation-5a613a4d19801a8b.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "gen_citation(C::Context; ...)\nGiven a context, generate the citations from used components.\nKeyword arguments:\n\nbibtex_file: If specified, will also save to this file using bibtex format."
  },
  {
    "objectID": "docstrings/medyan.add_filament_params--74c7d0081157ca31.html",
    "href": "docstrings/medyan.add_filament_params--74c7d0081157ca31.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "add_filament_params!(s::SysDef, filament_name::Symbol, filament_params::FilamentMechParams)\nAdd the filament parameters to the system. Return s.\nSee MEDYAN.FilamentMechParams"
  },
  {
    "objectID": "docstrings/medyan.link2monsiteone-9886bc1476194731.html",
    "href": "docstrings/medyan.link2monsiteone-9886bc1476194731.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Always returns 1.0"
  },
  {
    "objectID": "docstrings/medyan.addfilamentsite--eb6bfd871a21b6f4.html",
    "href": "docstrings/medyan.addfilamentsite--eb6bfd871a21b6f4.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addfilamentsite!(s::SysDef,filamenttypename::Symbol,filamentsitename::Symbol,site)"
  },
  {
    "objectID": "docstrings/medyan.chem_depolymerize--a5f262191e484dd4.html",
    "href": "docstrings/medyan.chem_depolymerize--a5f262191e484dd4.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_depolymerize!(c::Context, ftid, fid, isminusend::Bool)\nRemove a monomer from the end of the filament with type id ftid and id fid.\nIf isminusend is true remove the monomer from the minus end of the filament, if false remove it from the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked link_2mons, or change any of the monomer names.\nError if the filament isn’t initially over 2 monomers long.\nWarn if the old end monomer is referenced in a link2mon, and remove the link2mon.\nThe warning can be disabled by passing keyword argument warniflink_2mon_removed=false"
  },
  {
    "objectID": "docstrings/medyan.adddiffusingcount_rand--9d3ddfabbceeef92.html",
    "href": "docstrings/medyan.adddiffusingcount_rand--9d3ddfabbceeef92.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "adddiffusingcount_rand!(c::Context, dsid, inccount)\nDistribute the added diffusing species count randomly to compartments weighted by volume.\n\ndsid: diffusing species id.\ninccount: amount to add."
  },
  {
    "objectID": "docstrings/medyan.chem_setlink_2mon_state--82213403237b28e5.html",
    "href": "docstrings/medyan.chem_setlink_2mon_state--82213403237b28e5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_setlink_2mon_state!(c::Context, ltid, lid, link_2mon_state::Link2MonState)\nSet link2monstate of the link_2mon of type id ltid with id lid.\nError if the specified link_2mon doesn’t exist."
  },
  {
    "objectID": "docstrings/base.delete--56ef520341df3c06.html",
    "href": "docstrings/base.delete--56ef520341df3c06.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Remove a recorded index at ID."
  },
  {
    "objectID": "docstrings/medyan.addreaction--da9bd35e7d1df7c3.html",
    "href": "docstrings/medyan.addreaction--da9bd35e7d1df7c3.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addreaction!(s::SysDef,reaction::CompartmentReaction)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddreaction!(s::SysDef,reactionexpr::AbstractString,rate::Float64,invvolumepower::Int)::SysDef\nAdd a reaction to the system. Return s\nreactionexpr is a string describing the reaction stoichiometry\nreactionexpr is comprised of reactant and product parts seperated by a \"-->\"\nAll whitespace characters are ignored.\nEach side is then split by \"+\" to get the species names.\nRepeated or extra \"+\" are ignored.\nA species name can be prepended by a positive integer to represent multiple copies.\n\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s) rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)).\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\"diffusing.a + diffusing.b --> diffusing.c\"\n\"diffusing.c --> diffusing.a + diffusing.b\"\n\"+ + diffusing.c + --> + diffusing.a + + diffusing.b + +\"\n\" --> diffusing.a + diffusing.b\"\n\"diffusing.a + diffusing.b --> \"\n\"diffusing.a + diffusing.a --> \"\n\"2diffusing.a --> \"\n\"2diffusing.a --> 20diffusing.a\"\n\"diffusing.c + diffusing.b --> diffusing.c + diffusing.b\"\n\"fixedspecies.rate1b --> fixedspecies.g\"\n\"fixedspecies.rate1b + fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.rate1b + 23fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.g --> fixedspecies.rate1b + 23fixedspecies.g\"\n\"fixedspecies.g + fixedspecies.rate1b--> 2fixedspecies.rate1b + 23fixedspecies.g\"\n\"filamentsite.MT.d --> filamentsite.MT.d\"\n\"filamentsite.MT.d + diffusing.a --> filamentsite.MT.d\"\n\"fixedspecies.g --> diffusing.a\"\n\"diffusing.a --> fixedspecies.g\"\n\"filamentsite.actin.pm + diffusing.a --> filamentsite.actin.pm\""
  },
  {
    "objectID": "docstrings/src/filamentsites.html",
    "href": "docstrings/src/filamentsites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "General filament site just matches monomer states\n\ncenter::Int64: index of center monomer in states\nstates::Vector{UInt8}: monomer states to match"
  },
  {
    "objectID": "docstrings/src/context.html",
    "href": "docstrings/src/context.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Membrane protein physical parameters.\n\ndiffusion_coeff::Float64: Membrane diffusion coefficients (nm^2/s).\narea::Float64: Protein area projected onto the surface (nm^2).\nkbend::Float64: Bending rigidity (pN nm).\neqcurv::Float64: The protein’s own spontaneous mean curvature (/nm). Can be used in bending energy computations with curvatures.\n\n\n\n\n\n\n\n\n\n\n\n\n\nShallow copy, https://stackoverflow.com/questions/51956958/how-to-copy-a-struct-in-julia\n\n\n\n\n\n\n\n\n\n\n\n\n\nstatedef::MEDYAN.StateDef\ncompartments::Vector{MEDYAN.Compartment}\ngrid::Any\ntime::Ref{Float64}: time (s)\nstats::MEDYAN.PerformanceStats\nβ::Float64: inverse kT (1/(nm*pN))\nbase_diffusion_coeffs::Vector{Float64}: Diffusion coefficients indexed by diffusing species id (nm²/s)\nmembrane_species_params::StaticArraysCore.SVector{NUM_MEMBRANEDIFFUSINGSPECIES, MEDYAN.MembraneSpeciesParams} where NUM_MEMBRANEDIFFUSINGSPECIES: Membrane species parameters indexed by membrane diffusing species id.\nmin_compartment_volume_ratio::Float64: Smallest volume a compartment can have before being deactivated as a ratio to a full compartment volume.\nchemistryengine::MEDYAN.RDMESampler: The reaction diffusion master equation sampler, contains the diffusing and regular fixed species state\nlargestfilamentid::Vector{Int64}: The largest filament id, indexed by filament type id\nchem_cylinders::Vector{MEDYAN.ChemCylinders}: Data about filament cylinders, indexed by filament type id\nmembranes::Vector: All membrane meshes.\nlink_2mon_data::Tuple{Vararg{MEDYAN.Link2MonData}}: The linked link2mon parameters, indexed by link2mon type id, to give a Link2MonData\nlinkablesite_managers::Tuple{Vararg{MEDYAN.AbstractLinkableSiteManager}}: The linkable site managers, indexed by linkable site id\nlinked_monomers::Dictionaries.Dictionary{MEDYAN.MonomerName, Vector{Vector{Int64}}}: Dictionary of all monomers that have a bound link2mon. indexed by monomer name, then link2montypeid, to give a vector of unique link2mon ids that reference the monomer name\nfilamentsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filament site definitions, indexed by filament type id, filament site id to get a SiteData with fields of id, site, fxsid\nfilamentendsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filamentend site definitions, indexed by filament type id, filamentend site id to get a SiteData with fields of id, site, fxsid\nmaxfilsite_plusrange::Vector{Int64}: The maximum plus range in monomers that any filament site or end site can see. Indexed by filament type id\nmaxfilsite_minusrange::Vector{Int64}: The maximum minus range in monomers that any filament site or end site can see. Indexed by filament type id\nmembranesites::Tuple{Vararg{MEDYAN.SiteData}}: Maps membrane site id to a SiteData with fields of id, site, fxsid.\nmap_membranediffusingspeciesindex_membranesiteindices::Tuple{Vararg{Vector{Int64}}}: Maps membrane diffusing species index to a list of membrane sites using this species as reactant. This is initialized during context init and should not be changed.\nlink_2mon_sites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The link2mon site definitions, indexed by link2mon type id, link_2mon site id to get a SiteData with fields of id, site, fxsid\nlinkablesites::Tuple{Vararg{MEDYAN.SiteData}}: The linkable site definitions, indexed by linkable site id to get a SiteData with fields of id, site, fxsid\ncadherinsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}\ncadherindata::Tuple{Vararg{MEDYAN.CadherinData}}\npossiblecadherinsite_managers::Tuple{Vararg{MEDYAN.AbstractPossibleCadherinSiteManager}}: The linkable site managers, indexed by linkable site id\ncadherinlinked_vertices::Dictionaries.Dictionary{MEDYAN.VertexName, Vector{Vector{Pair{MEDYAN.VertexName, MEDYAN.MonomerName}}}}: Dictionary of all vertices that have a bound cadherin. indexed by vertex name, then cadherintypeid, to give a vector of unique cadherin endnames that reference the monomer name and vertex name\ncheck_sitecount_error::Bool: If true site counts are checked for errors on every chem update. This is extremely slow, but useful for testing chem update errors.\ncompartmentreactioncallbacks::Any\nbulkreactioncallbacks::Any\nmemdiff_bulks_index::Int64: Mock bulk species index for membrane diffusion.\ng_tol::Float64: maximum force magnitude after minimization (pN)\nshake_before_minimization::Bool: If true, add noise to coordinates before starting minimization.\niter_max_cg_minimization::Int64: Max number of steps in conjugate gradient minimization.\nmaxstep::Float64: max step to take during line search (nm)\nmax_cylinder_force::Float64: max cylinder force when two cylinders are at zero distance (pN)\ncheck_neighborlist_error::Bool: If true neighborlists are checked for errors on every force calc. This is extremely slow, but useful for testing neighborlist errors.\nnthreads::Int64: Experimental Set to more than 1 to enable multi threading. This is currently may result in non bitwise reproducable simulations. Results should be statistcally identical, but this is currently not well tested.\nenable_cylinder_volume_exclusion::Ref{Bool}: Are cylinder volume exclusion forces calculated\nenable_triangle_bead_volume_exclusion::Bool: Are triangle-bead volume exclusion forces calculated.\ncylinder_skin_radius::Float64: Extra cell list cutoff radius in nm. The cell lists are reset after a bead moves over this amount\nfilamentmechparams::Vector{MEDYAN.FilamentMechParams}: The filament mechanical parameters, indexed by filament type id\nmembranemechparams::Vector{MEDYAN.MembraneMechParams}: Membrane mechanical parameters, indexed by membrane type id.\nfunc_membranespeciespotentialenergy::Any: Membrane species potential energy function. See docs on default function for more info.\nfunc_membranespeciesfreeenergy!::Any: Membrane species total free energy function. See docs on default function for more info.\nmembranefilamentmechparams::MEDYAN.MembraneFilamentMechParams: Membrane-filament mechanical interaction parameters.\nexternal_energy_forces!::Any: External energy/force expressions. This should be a function (vectorizedforce, vectorizedx, vectorizeresult) -> energy, which also modifies the force as well. The energy and force must be consistent, and this is not checked. The neighbor lists and related are currently not accessible in the vectorizedinfo. This can be used as ad-hoc solutions to experiment with uncommon forces, such as specifically designed attachments, etc. If this variable is used often, consider moving it into MEDYAN.\nchemboundary::MEDYAN.Boundary: chemical boundary, updates compartment volumes and diffusion rates\nmeshindex_as_chemboundary::Ref{Int64}: The membrane index used as chemical boundary. If values other than 0 is used, the actual interior region of the chemical boundary is the intersection between\n\nthe interior of chemboundary, and\nthe interior of the membrane mesh at this index.\n\nNote: Since the membrane may change its shape often, set_chemboundary! might need to be called often accordingly to update volumes of compartments.\nmechboundary::MEDYAN.Boundary: mechanical boundary\nsharedtypedconfigs::MEDYAN.SharedTypedConfigs: Shared configurations stored in type parameters.\nvalidflags::MEDYAN.ValidFlags: Interval system consistency validation flags.\n\n\n\n\n\n\n\n\n\n\n\n\n\nnum_filtypes(c::MEDYAN.Context) -> Int64\nReturn the number of filament types.\n\n\n\n\n\n\n\n\n\n\n\n\nfiltype_fil_ids(\n    c::MEDYAN.Context,\n    ftid::Int64\n) -> Vector{Int64}\nReturn a read only iterable of all filament ids of filament type ftid.\nThis can be invalid after any mutations to context, so collect if needed.\n\n\n\n\n\n\n\n\n\n\n\n\nfil_node_positions(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> Vector{StaticArraysCore.SVector{3, Float64}}\nReturn the node positions of the filament\n\n\n\n\n\n\n\n\n\n\n\n\nfil_node_mon_ids(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> Vector{Int64}\nReturn the node monomer ids of the filament.\nThe fil_node_mon_ids are the monomer ids at (slightly plus side of) the fil_node_positions\n                                 |\n                      -----+-----|-----+-----\n  minus end <----       M  |  M  | (M) |  M        ----> plus end\n                      -----+-----|-----+-----\n                                 |\n                                 ^ A node position is indicated by the line.\n\nThe monomer id with parenthesis (M) will in `fil_node_mon_ids`\nThe first monomer id is the first monomer id on the filament. The last monomer id is the last monomer id on the filament + 1\n\n\n\n\n\n\n\n\n\n\n\n\nfil_mon_states(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> OffsetArrays.OffsetVector{UInt8, Vector{UInt8}}\nReturn a read only OffsetVector of monomer states on a filament.\nThis can be invalid after any mutations to context, so copy if needed.\n\n\n\n\n\n\n\n\n\n\n\n\nvertex_state(\n    c::MEDYAN.Context,\n    vertexname::MEDYAN.VertexName\n) -> UInt8\nReturn the vertex state on a membrane.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_exists(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Bool\nReturn true iff the filament and monomer exists\n\n\n\n\n\n\n\n\n\n\n\n\nmon_minimized(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Bool\nReturn true iff the monomer has been minimized\n\n\n\n\n\n\n\n\n\n\n\n\nmon_3states(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Tuple{UInt8, UInt8, UInt8}\nReturn a tuple of three monomer states centered at a monomer.\nIf a monomer doesn’t exist, its state will be zero. The filament must exist.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_position(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> StaticArraysCore.SVector{3, Float64}\nReturn the monomer position.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_plusvector(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> StaticArraysCore.SVector{3, Float64}\nReturn the unit vector toward the plus end of the filament.\n\n\n\n\n\n\n\n\n\n\n\n\nmon_position_plusvector(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}\nReturn a tuple of position and plusvector at a monomer.\n\n\n\n\n\n\n\n\n\n\n\n\nset_time!(c::MEDYAN.Context, x::Float64) -> Float64\nTime (s)\n\n\n\n\n\n\n\n\n\n\n\n\nset_enable_cylinder_volume_exclusion!(\n    c::MEDYAN.Context,\n    x::Bool\n) -> Bool\nAre cylinder volume exclusion forces calculated.\n\n\n\n\n\n\n\n\n\n\n\n\nset_chemboundary!(\n    c::MEDYAN.Context;\n    meshindex_as_chemboundary,\n    kwargs...\n) -> MEDYAN.Boundary\nSet chemical boundary and update compartment volumes and diffusion rates. Note, the chemboundary should be outside the mechboundary so that it is rare for filaments to go outside the chemboundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the chemical boundary of the simulation\ninside = signbit(pos ⋅ planes[bi][1:3] - planes[bi][4])\nFor example, a plane [1,0,0,3] is inside if x < 3 nm.\n2.0*[1,0,0,3] is also inside if x < 3 nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the chemical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is ignored.\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\n\nmeshindex_as_chemboundary::Int = 0: Index of membrane mesh that further restricts the chem boundary. 0 for none.\n\nThe system geometry information must be up-to-date. This mesh index is not stored in the boundary object, but is directly set in the context.\n\n\n\n\n\n\n\n\n\n\n\n\n\nset_mechboundary!(\n    c::MEDYAN.Context;\n    kwargs...\n) -> MEDYAN.Boundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the mechanical boundary of the simulation\nE = 1//2 * relu(pos ⋅ planes[bi][1:3] - planes[bi][4])^2\nFor example, a mech bounding plane [1,0,0,3] would try and make x < 3 nm with a spring constant of 1 pN/nm.\n2.0*[1,0,0,3] would try and make x < 3 nm with a spring constant of 4 pN/nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the mechanical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is the spring constant (pN/nm).\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\nE = 1//2*k*relu(d - r0)^2 where:\n\nd is the distance of the point to the spine line segment described by capsules[bi][1:6].\nr0 is capsules[bi][7]\nk is capsules[bi][8]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchem_adddiffusingcount!(c::Context, sid, cid, inccount)\nAdd inccount to diffusing species id sid in compartment id cid\n\n\n\n\n\n\n\n\n\n\n\n\nchem_addfixedcount!(c::Context, sid, cid, inccount)\nAdd inccount to fixed species id sid in compartment id cid\n\n\n\n\n\n\n\n\n\n\n\n\nadddiffusingcount_rand!(c::Context, dsid, inccount)\nDistribute the added diffusing species count randomly to compartments weighted by volume.\n\ndsid: diffusing species id.\ninccount: amount to add.\n\n\n\n\n\n\n\n\n\n\n\n\n\naddmembranediffusingcount_rand!(\n    c::MEDYAN.Context,\n    membraneindex::Int64,\n    speciesindex::Int64,\n    addcount::Int64\n)\nDistribute the added membrane species count randomly to membrane cells, ignoring cell area difference. Does NOT update propensity.\n\n\n\n\n\n\n\n\n\n\n\n\nnewfilament_rand!(c::Context, monomerstates; iterations = 10^9, ftid = 1)\nAdd a filament with type id ftid to the Context with random center position and direction.\nReturn the filament id of a new filament.\nmonomerstates is a collection of the MonomerState of the monomers in the new filament.\nThe filament will be inside the mech boundary.\nErrors if it fails to add a filament.\nThe monomer are spaced by the value in the filament type’s mechanical parameters.\n\n\n\n\n\n\n\n\n\n\n\n\nrun_chemistry!(c::Context, Δt)\nRun chemistry for Δt time.\nUpdate c.time.\n\n\n\n\n\n\n\n\n\n\n\n\ndefer_chem_caching!(c::Context)::Nothing\nThis should only be used for advanced optimizations.\nDuring chemistry, the context mutating functions will typically try to avoid invalidating various cached data needed to quickly sample sites.\nHowever, if you want to mutate the context outside of chemistry, for example right before or after minimization, you may not want to pay the cost of revalidating all the caches because minimization will already invalidate the caches. Caching will be enabled again and caches will be made valid the next time chemistry is run. Caching can also be manually refreshed and reenabled with: refresh_chem_cache!\n\n\n\n\n\n\n\n\n\n\n\n\nrefresh_chem_cache!(c::Context)::Nothing\nNormally this isn’t needed as it will happen automatically.\n\n\n\n\n\n\n\n\n\n\n\n\nis_chem_cache_valid(c::Context)::Bool\nReturn true if the chemistry cache is valid, false otherwise.\n\n\n\n\n\n\n\n\n\n\n\n\nempty!(c::Context)\nRemove all filaments, membranes, link_2mons, cadherins, diffusing species, fixed species, bulk species, chemboundary, and mechboundary.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_setmonomerstate!(c::Context, name::MonomerName, state::MonomerState)\nUpdate a monomer state.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_polymerize!(c::Context, ftid, fid, isminusend::Bool, newstate::MonomerState)\nAdd a monomer with state newstate to the end of the filament with type id ftid and id fid.\nIf isminusend is true add the monomer to the minus end of the filament, if false add it to the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked link_2mons, or change any of the monomer names. New monomers are not linkable until after minimization.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_depolymerize!(c::Context, ftid, fid, isminusend::Bool)\nRemove a monomer from the end of the filament with type id ftid and id fid.\nIf isminusend is true remove the monomer from the minus end of the filament, if false remove it from the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked link_2mons, or change any of the monomer names.\nError if the filament isn’t initially over 2 monomers long.\nWarn if the old end monomer is referenced in a link2mon, and remove the link2mon.\nThe warning can be disabled by passing keyword argument warniflink_2mon_removed=false\n\n\n\n\n\n\n\n\n\n\n\n\nchem_newlink_2mon!(c::Context, ltid::Int, endnames::Pair{MonomerName,MonomerName}, link_2mon_state::Link2MonState;\n    new_lid::Union{Nothing,Int64} = nothing,\n)::Int64\n\nchem_newlink_2mon!(c::Context, ltid::Int, endnames::Pair{MonomerName,MonomerName};\n    changedchemstate = (;),\n    changedmechstate = (;),\n    is_minimized = c.link_2mon_data[ltid].params.defaultstate.is_minimized,\n    new_lid::Union{Nothing,Int64} = nothing,\n)::Int64\nAdd a new link_2mon with type id ltid between monemers endnames.\nReturn the link_2mon id.\nError if a link_2mon of the same type links the same monomers in the same order.\nIf the link2mon state isn’t provided, c.link*2mon*data[ltid].params.defaultstate is new link2mon’s state, optionally modified by the changedchemstate, changedmechstate, and is_minimized keyword arguments.\nKeyword arguments changedchemstate and changedmechstate are namedtuples that shadow fields from the default chemstate and mechstate for the new link_2mon.\nKeyword argument is_minimized can be used to set the new link*2mon’s is*minimized state.\nKeyword argument new_lid can be optionally used to set the new link_2mon’s id, if this id is currently used, error.\n\n\nlid = chem_newlink_2mon!(c, g.ltid, minusname=>plusname;\n        changedmechstate = (L0 = dist,),\n        changedchemstate = (numHeads = rand(g.numHeadsMin:g.numHeadsMax),),\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\nchem_removelink_2mon!(c::Context, ltid::Int, lid::Int64)\nRemove a link_2mon of type id ltid with id lid.\nError if the specified link_2mon doesn’t exist.\nDon’t modify monomer states.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_setlink_2mon_state!(c::Context, ltid, lid, link_2mon_state::Link2MonState)\nSet link2monstate of the link_2mon of type id ltid with id lid.\nError if the specified link_2mon doesn’t exist.\n\n\n\n\n\n\n\n\n\n\n\n\nchem_newfilament!(c::Context; ftid=1, monomerstates, node_mids, nodepositions)\nReturn the filament id of a new filament.\nError if the filament isn’t initially over 2 monomers long.\nNewly added filaments don’t have linkable sites, until after minimization.\n\n\n\nftid=1: filament type id.\nmonomerstates: Collection of the MonomerState of the monomers in the new filament. In order from minus end to plus end.\nlength(monomerstates)>1\nnodepositions: Collection of SVector{3,Float64}. The positions of the nodes, monomers are between nodes.\nnode_mids: Collection of Integer. The monomer ids at (slightly plus side of) the nodepositions\n                               |\n                    -----+-----|-----+-----\nminus end <----       M  |  M  | (M) |  M        ----> plus end\n                    -----+-----|-----+-----\n                               |\n                               ^ A nodeposition is indicated by the line.\nThe monomer id with parenthesis (M) will in node_mids\nlength(node_mids) == length(nodepositions) - 1\nendloadforces=(0.0=>0.0): end load forces, usually don’t use this, because load forces will automatically get updated at the next minimization.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nchem_removefilament!(c::Context; ftid=1, fid=maximum(filtype_fil_ids(c, ftid)))\nRemove the filament with type id ftid and id fid.\nBy default the last added filament with type id ftid is removed.\nWarn if any monomers on the filament are referenced by any link2mons, and remove those link2mons.\nThe warning can be disabled by passing keyword argument warniflink_2mon_removed=false\n\n\n\n\n\n\n\n\n\n\n\n\nnewmembrane!(c::MEDYAN.Context; type, meshinit)\nAdd a new membrane to the system.\n\n\n\nmeshinit is structure containing mesh shape initialization information, such as a named tuple (vertlist, trilist) containing vertex coordinates and triangle list, MeshInitEllipsoid, MeshInitPlane or a general MeshInitSurfaceFunc."
  },
  {
    "objectID": "docstrings/src/auxprocs.html",
    "href": "docstrings/src/auxprocs.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Remesh all membrane meshes.\n\n\n\n\n\n\n\n\n\n\n\n\nGiven an AABB tree corresponding to up-to-date membrane mesh triangles, resolve all filament-membrane intersections.\nRequires\n\nup-to-date unit normals of all triangles in the meshes.\nup-to-date AABB tree corresponding to all membrane meshes.\n\n\n\n\n\n\n\n\n\n\n\n\n\nUpdates all membrane geometries used across various parts of MEDYAN.\nThe list of all items can be found in the document for MEDYAN.compute_geometry!_system function.\nKeyword parameters:\n\ninclude_ff::Bool: If true, compute_geometry! used in energy computations will be applied as well, requiring vectorization of the membrane. This happens before system geometry computation in case some fields are overriden."
  },
  {
    "objectID": "docstrings/src/link_2mon_sites.html",
    "href": "docstrings/src/link_2mon_sites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Always returns 1.0\n\n\n\n\n\n\n\n\n\n\n\n\nReturns link_2mon_state.chemstate.sitecount\n\n\n\n\n\n\n\n\n\n\n\n\nReturns 1.0 if the monomer states match, otherwise, returns 0.0.\n\nminusstate::Tuple{UInt8, UInt8, UInt8}: minus end monomer state\nplusstate::Tuple{UInt8, UInt8, UInt8}: plus end monomer state\n\n\n\n\n\n\n\n\n\n\n\n\n\nModels unbinding rates based on the following exponential form of Bell et al, 1978: min(k0*exp(f/f0), kmax) Where f is the magnitude of the force. So as to exponetially increase the unbinding with more force.\nlink_2mon_sitecount returns the unbinding rate in units of 1/s It returns k0 if the link_2mon hasn’t been minimized yet.\n\nf0::Float64: The charicteristic force magnitude. Units of pN\nk0::Float64: Unbinding rate at zero force. Units of 1/s\nkmax::Float64: Maximum rate. Units of 1/s\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe catch-bond nature of myosin unbinding with multiple heads. Adopted from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the force increases, the motor unbinding rate decreases to a minimum of k0/10\nlink_2mon_sitecount returns the unbinding rate in units of 1/s It returns k0 if the link2mon hasn’t been minimized yet. It assumes link2monstate.chemstate.numHeads exists for the link2mon.\n\nf0::Float64: single head characteristic unbinding force, units of pN/head\nonRate::Float64: single head binding rate, units of 1/s\noffRate::Float64: single head unbinding rate, units of 1/s\nβ::Float64: slope of head binding, units of (head)/(pN/head)\n\n\n\n\n\n\n\n\n\n\n\n\n\nModels myosin walking rates from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the motor work per step increases, its walking rate goes to zero.\nReturns the walking rate of one end. The callback can then sample which end to move, or reject the move.\n\nfs::Float64: The stall force magnitude. Units of pN\nk0::Float64: Walking rate of one end at zero force. Units of 1/s\nα::Float64: Positive dimensionless parameter defining the steepness of the curve, smaller is more steep, if α is inf, the curve is linear\nwalking_direction::Int32: Motor walking direction, +1 is towards plus end, -1 is towards minus end\nisminusend::Bool: which motor end does this represent"
  },
  {
    "objectID": "docstrings/src/sysdefs.html",
    "href": "docstrings/src/sysdefs.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "ftid::Int64: filament type id\nfid::Int64: filament id\nmid::Int64: monomer id\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmembraneindex::Int64: membrane index\nvid::Int64: vertex id\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere is one instance of this per link_2mon.\n\nchemstate::NamedTuple: Other state.\nmechstate::NamedTuple: Used in link_2mon force calculation.\nis_minimized::Bool: Set to true after minimization\n\n\n\n\n\n\n\n\n\n\n\n\n\nLink2mon Parameters, there is one instance of this per link2mon type\n\ndefaultstate::MEDYAN.Link2MonState\nmechparams::Any\nno_collide::Bool: if true, allows cylinders this link_2mon type connects and adjacent cylinders to clip\n\n\n\n\n\n\n\n\n\n\n\n\n\nThere is one instance of this per cadherin.\n\nchemstate::NamedTuple: Other state.\nmechstate::NamedTuple: Used in link_2mon force calculation.\nis_minimized::Bool: Set to true after minimization\n\n\n\n\n\n\n\n\n\n\n\n\n\nCadherin Parameters, there is one instance of this per cadherin type\n\ndefaultstate::MEDYAN.CadherinState\nmechparams::Any\n\n\n\n\n\n\n\n\n\n\n\n\n\nadd_diffusion_coeff!(s::SysDef, diffusing_name::Symbol, diffusing_coeff::Float64)\nAdd the diffusing species to the system with diffusion coefficent in units of (nm²/s). Return s.\n\n\n\n\n\n\n\n\n\n\n\n\nadd_filament_params!(s::SysDef, filament_name::Symbol, filament_params::FilamentMechParams)\nAdd the filament parameters to the system. Return s.\nSee MEDYAN.FilamentMechParams\n\n\n\n\n\n\n\n\n\n\n\n\nadd_link_2mon!(s::SysDef,link_2mon_typename::Symbol,defaultstate::Link2MonState,mechparams;no_collide=false)\nAdd the link_2mon to the system. Return s.\nSetting no_collide to true allows cylinders this link_2mon type connects and adjacent cylinders to clip.\n\n:::\n\n## [`` MEDYAN.addfilamentsite! ``](/docstrings/medyan.addfilamentsite--eb6bfd871a21b6f4.qmd) {#medyan.addfilamentsite--eb6bfd871a21b6f4}\n:::{.callout-note appearance=\"minimal\"}\n```julia\naddfilamentsite!(s::SysDef,filamenttypename::Symbol,filamentsitename::Symbol,site)\n\n\n\n\n\n\n\n\n\n\n\n\naddfilamentendsite!(s::SysDef,filamenttypename::Symbol,filamentendsitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\nadd_link_2mon_site!(s::SysDef,link_2mon_typename::Symbol,link_2mon_sitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddlinkablesite!(s::SysDef,linkablesitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddcadherin!(s::SysDef,cadherintypename::Symbol,defaultstate::CadherinState,mechparams). Add the cadherin to the system. Return s.\n\n\n\n\n\n\n\n\n\n\n\n\naddcadherinsite!(s::SysDef,cadherintypename::Symbol,cadherinsitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddpossiblecadherinsite!(s::SysDef,possiblecadherinsitename::Symbol,site)::SysDef\n\n\n\n\n\n\n\n\n\n\n\n\naddmembranesite!(\n    s::MEDYAN.SysDef,\n    membranesitename::Symbol,\n    site\n) -> MEDYAN.SysDef\nAdd a new site with a specified name. During this process, a new fixed species is created suffixed with “membranesite.”.\n\n\n\n\n\n\n\n\n\n\n\n\naddreaction!(s::SysDef,reaction::CompartmentReaction)::SysDef\n\n\n\n\n\n\n\n\n\naddreaction!(s::SysDef,reactionexpr::AbstractString,rate::Float64,invvolumepower::Int)::SysDef\nAdd a reaction to the system. Return s\nreactionexpr is a string describing the reaction stoichiometry\nreactionexpr is comprised of reactant and product parts seperated by a \"-->\"\nAll whitespace characters are ignored.\nEach side is then split by \"+\" to get the species names.\nRepeated or extra \"+\" are ignored.\nA species name can be prepended by a positive integer to represent multiple copies.\n\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s) rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)).\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\"diffusing.a + diffusing.b --> diffusing.c\"\n\"diffusing.c --> diffusing.a + diffusing.b\"\n\"+ + diffusing.c + --> + diffusing.a + + diffusing.b + +\"\n\" --> diffusing.a + diffusing.b\"\n\"diffusing.a + diffusing.b --> \"\n\"diffusing.a + diffusing.a --> \"\n\"2diffusing.a --> \"\n\"2diffusing.a --> 20diffusing.a\"\n\"diffusing.c + diffusing.b --> diffusing.c + diffusing.b\"\n\"fixedspecies.rate1b --> fixedspecies.g\"\n\"fixedspecies.rate1b + fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.rate1b + 23fixedspecies.g --> fixedspecies.g\"\n\"fixedspecies.g --> fixedspecies.rate1b + 23fixedspecies.g\"\n\"fixedspecies.g + fixedspecies.rate1b--> 2fixedspecies.rate1b + 23fixedspecies.g\"\n\"filamentsite.MT.d --> filamentsite.MT.d\"\n\"filamentsite.MT.d + diffusing.a --> filamentsite.MT.d\"\n\"fixedspecies.g --> diffusing.a\"\n\"diffusing.a --> fixedspecies.g\"\n\"filamentsite.actin.pm + diffusing.a --> filamentsite.actin.pm\"\n\n\n\n\n\n\n\n\n\n\n\n\n\naddreactioncallback!(s::SysDef, reaction::CompartmentReaction, callback)::SysDef\naddreactioncallback!(s::SysDef, reactantexpr::AbstractString, rate::Float64, invvolumepower::Int, callback)::SysDef\nLike addreaction! but also adds callback. callback is called when the reaction happens with input of MEDYAN.Context and Int the compartment id where the reaction happened.\nThe reaction should normally have no net stoichiometry because the callback should handle updating species counts. If an AbstractString is passed instead of a CompartmentReaction for the reaction, that string will be parsed to determine the reactants. The net stoichiometry will be zero.\nMEDYAN.errorcheck_addcallback(callback,s::SysDef) can optionally be overloaded to add errorchecking when the callback is added.\n\n\n\n\n\n\n\n\n\nCallback for bulk reactions: Context -> Nothing.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd filament reaction. Return s. Add a filamentsite and reaction with callback to change the monomer state. This can be used for filament aging, filament catalyzed reactions, or simple binding reactions.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentsitename::Symbol: the new name of the filamentsite added. This can be used as a catalyst in other reactions.\nchangedstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the monomer states, the first is the states to match. The second is the new monomer states after the reaction. both should be the same length. Ordered minus end first.\ncenter::Int: Which index of changedstatenames.first is the actual location of the filamentsite. Used for determining what compartment the reaction goes in.\nreactantexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentsite.$(filamenttypename).$(filamentsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nstatedef = StateDef(\n    filamentnames= [(:filname,[\n                            :a,\n                            :b,\n                            :c,\n                        ]),\n    ],\n)\ns= SysDef(statedef)\naddfilament_reaction!(s, :filname, :ab,\n    [:a]=>[:b], 1,\n    \"-->\", 1.75E-3, 0,\n)\naddfilament_reaction!(s, :filname, :aabc,\n    [:a,:a]=>[:b,:c], 2,\n    \"-->\", 1.75E-3, 0,\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd filament end reaction. Return s. Add a filamentendsite and reaction with callback to change the filaments. This can be used for polymerization, depolymeriation, and changing end state.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentendsitename::Symbol: the new name of the filamentendsite added. This can be used as a catalyst in other reactions.\nisminusend::Bool: true if changing the minus end, false if changing the plus end.\nchangedendstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the end monomer states, the first is the states to match. The second is the new monomer states after the reaction. If the second has more states than the first, new monomers will be added, if the second has less, monomers will be removed. Ordered minus end first.\nspacing::Float64: Space needed at the filament end for this reaction. (nm) ratefactor= exp(-β*spacing*loadforce) where β is 1/kT, loadforce is the external force pushing axially on the end of the filament. and ratefactor affects this reaction propensity and any others using filamentendsitename\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentendsite.$(filamenttypename).$(filamentendsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentendsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nstatedef = StateDef(\n    diffusingspeciesnames= [:a,],\n    filamentnames= [(:filname,[\n                            :plus,\n                            :mid,\n                            :minus,\n                        ]),\n    ],\n)\ns= SysDef(statedef)\nmonomerspacing= 2.7\n#minus end polymerization\naddfilamentend_reaction!(s, :filname, :pm, true,\n    [:minus]=>[:minus,:mid], monomerspacing,\n    \"diffusing.a -->\", 10E3, 1,\n)\n#plus end depolymerization\naddfilamentend_reaction!(s, :filname, :dpp, false,\n    [:mid,:plus]=>[:plus], 0.0,\n    \"--> diffusing.a\", 1.75E-3, 0,\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd unbinding site, callback, and reaction. Return s.\n\n\n\ns::SysDef: the system to add to.\nlink_2mon_typename::Symbol: the link_2mon type name.\nlink_2mon_sitename::Symbol: the new name of the link_2mon_site added. This can be used as a catalyst in other reactions.\nlink_2mon_site: the link_2mon site to add.\nplusfilamenttypename::Symbol: the filament type name of the plus end.\nplusnewmonomerstatename::Symbol: the new name of the monomer state of the plus end.\nminusfilamenttypename::Symbol: the filament type name of the minus end.\nminusnewmonomerstatename::Symbol: the new name of the monomer state of the minus end.\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + link_2mon_site.$(link_2mon_typename).$(link_2mon_sitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using link_2mon_sitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd a membrane site with the corresponding reaction with callback.\nKeyword arguments:\n\ns: SysDef.\nname_newmembranesite: Symbol.\nmembranediffusingreactants: Vector of symbols as membrane reactants. 0 or 1 reactant is currently supported.\nmembranediffusingproducts: Vector of symbols as membrane products.\nreactionexpr_extra: Reaction expression for other species involved.\nrate: Float.\nchangerage_bypotentialenergy: Whether the rate is affected by potential energy.\ninvvolumepower: rate scaling with compartment volume.\n\nNotes:\n\nIf error occurs, this function does not ensure that s is unchanged."
  },
  {
    "objectID": "docstrings/src/filamentendsites.html",
    "href": "docstrings/src/filamentendsites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Filament end site that matches with a vector of monomer states.\n\nisminusend::Bool\nendstates::Vector{UInt8}\nspacing::Float64"
  },
  {
    "objectID": "docstrings/src/grids.html",
    "href": "docstrings/src/grids.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "n::StaticArraysCore.SVector{3, Int64}\ncompartmentsize::Float64\n\n\n\n\n\n\n\n\n\n\n\n\n\nTotal number of compartments in the grid"
  },
  {
    "objectID": "docstrings/src/linkablesites.html",
    "href": "docstrings/src/linkablesites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Any pair within max to min range are linkable if they have matching state with minusstate and plusstate.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64\n\n\n\n\n\n\n\n\n\n\n\n\n\nAny pair within max to min range are linkable if they have matching state with minusstate and plusstate and if both the angles between the filaments and line between the pair are greater than acos(cosminangle) for example if cosminangle is 1, all angles are ok, if cosminangle is sqrt(2)/2, and the line between the pair of monomers is parallel or anti parallel to either filament, it won’t be linkable.\nThis can be used to prevent link_2mons from binding both ends to the same filament.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64\ncosminangle::Float64"
  },
  {
    "objectID": "docstrings/src/util/bibliography.html",
    "href": "docstrings/src/util/bibliography.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "gen_citation(C::Context; ...)\nGiven a context, generate the citations from used components.\nKeyword arguments:\n\nbibtex_file: If specified, will also save to this file using bibtex format."
  },
  {
    "objectID": "docstrings/src/util/stableindex.html",
    "href": "docstrings/src/util/stableindex.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Whether an ID is in use.\n\n\n\n\n\n\n\n\n\n\n\n\nTotal number of IDs in use.\n\n\n\n\n\n\n\n\n\n\n\n\nGet index at ID.\n\n\n\n\n\n\n\n\n\n\n\n\nMap ID to a new index. The ID must be in use.\n\n\n\n\n\n\n\n\n\n\n\n\nAdd a new index. Returns its ID.\n\n\n\n\n\n\n\n\n\n\n\n\nRemove a recorded index at ID.\n\n\n\n\n\n\n\n\n\n\n\n\nClear all index records.\n\n\n\n\n\n\n\n\n\n\n\n\nIterates through valid IDs in the StableIndex."
  },
  {
    "objectID": "docstrings/src/util/math/cuboidslicing.html",
    "href": "docstrings/src/util/math/cuboidslicing.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "scale the volume and area\n\n\n\n\n\n\n\n\n\nscale the volume and area by different amounts in each direction"
  },
  {
    "objectID": "docstrings/src/trajectory-io/snapshot.html",
    "href": "docstrings/src/trajectory-io/snapshot.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "load_snapshot!(c::Context,group::StorageTrees.ZGroup)\nEmpty the context and load the state saved in the snapshot group.\nc should be constructed with the same SysDef and parameters as the Context used to create the snapshot. Trying to load a snapshot into a Context constructed with a different system or parameters may lead to unexpected results.\nSee Snapshot group for more details."
  },
  {
    "objectID": "docstrings/src/membrane/membranesites.html",
    "href": "docstrings/src/membrane/membranesites.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Allows up to 1 membrane diffusing species as reactants. Also stores net stoich of membrane diffusing species.\n\nid_membranediffusing_reactant::Int64: Set to 0 if no membrane diffusing species is involved.\ncanchangerate_bypotentialenergy::Bool: Whether the reaction rate depends on reactant species potential energy.\nmembranediffusingnet_stoich::Vector{Pair{Int64, Int64}}: Pairs of membrane diffusing species index => Δcount"
  },
  {
    "objectID": "docstrings/src/minimize_energy.html",
    "href": "docstrings/src/minimize_energy.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Force (re-)evaluation of the objective value at x. Returns f(x) and stores the value in obj.F also calculates the gradient and stores it in obj.DF\n\n\n\n\n\n\n\n\n\n\n\n\nminimize_energy!(c::Context)\nMinimize mechanical energy of the context."
  },
  {
    "objectID": "docstrings/medyan.linkablesiteminanglerange-fb2b6cfdc0e13e58.html",
    "href": "docstrings/medyan.linkablesiteminanglerange-fb2b6cfdc0e13e58.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Any pair within max to min range are linkable if they have matching state with minusstate and plusstate and if both the angles between the filaments and line between the pair are greater than acos(cosminangle) for example if cosminangle is 1, all angles are ok, if cosminangle is sqrt(2)/2, and the line between the pair of monomers is parallel or anti parallel to either filament, it won’t be linkable.\nThis can be used to prevent link_2mons from binding both ends to the same filament.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64\ncosminangle::Float64"
  },
  {
    "objectID": "docstrings/medyan.newmembrane--a714b4a1c87062be.html",
    "href": "docstrings/medyan.newmembrane--a714b4a1c87062be.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "newmembrane!(c::MEDYAN.Context; type, meshinit)\nAdd a new membrane to the system.\n\n\n\nmeshinit is structure containing mesh shape initialization information, such as a named tuple (vertlist, trilist) containing vertex coordinates and triangle list, MeshInitEllipsoid, MeshInitPlane or a general MeshInitSurfaceFunc."
  },
  {
    "objectID": "docstrings/medyan.link2monsitemotorcatch-0185d4c95b91e30b.html",
    "href": "docstrings/medyan.link2monsitemotorcatch-0185d4c95b91e30b.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "The catch-bond nature of myosin unbinding with multiple heads. Adopted from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the force increases, the motor unbinding rate decreases to a minimum of k0/10\nlink_2mon_sitecount returns the unbinding rate in units of 1/s It returns k0 if the link2mon hasn’t been minimized yet. It assumes link2monstate.chemstate.numHeads exists for the link2mon.\n\nf0::Float64: single head characteristic unbinding force, units of pN/head\nonRate::Float64: single head binding rate, units of 1/s\noffRate::Float64: single head unbinding rate, units of 1/s\nβ::Float64: slope of head binding, units of (head)/(pN/head)"
  },
  {
    "objectID": "docstrings/medyan.addfilament_reaction--63195cbff2ab4237.html",
    "href": "docstrings/medyan.addfilament_reaction--63195cbff2ab4237.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add filament reaction. Return s. Add a filamentsite and reaction with callback to change the monomer state. This can be used for filament aging, filament catalyzed reactions, or simple binding reactions.\n\n\n\ns::SysDef: the system to add to.\nfilamenttypename::Symbol: the filament type name.\nfilamentsitename::Symbol: the new name of the filamentsite added. This can be used as a catalyst in other reactions.\nchangedstatenames::Pair{Vector{Symbol}, Vector{Symbol}}: the changes to the monomer states, the first is the states to match. The second is the new monomer states after the reaction. both should be the same length. Ordered minus end first.\ncenter::Int: Which index of changedstatenames.first is the actual location of the filamentsite. Used for determining what compartment the reaction goes in.\nreactantexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + filamentsite.$(filamenttypename).$(filamentsitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using filamentsitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant.\n\n\n\n\nusing MEDYAN\nstatedef = StateDef(\n    filamentnames= [(:filname,[\n                            :a,\n                            :b,\n                            :c,\n                        ]),\n    ],\n)\ns= SysDef(statedef)\naddfilament_reaction!(s, :filname, :ab,\n    [:a]=>[:b], 1,\n    \"-->\", 1.75E-3, 0,\n)\naddfilament_reaction!(s, :filname, :aabc,\n    [:a,:a]=>[:b,:c], 2,\n    \"-->\", 1.75E-3, 0,\n)"
  },
  {
    "objectID": "docstrings/base.getindex-f593dde852851bc8.html",
    "href": "docstrings/base.getindex-f593dde852851bc8.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Get index at ID."
  },
  {
    "objectID": "docstrings/medyan.fil_mon_states-3db9714621903b78.html",
    "href": "docstrings/medyan.fil_mon_states-3db9714621903b78.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "fil_mon_states(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> OffsetArrays.OffsetVector{UInt8, Vector{UInt8}}\nReturn a read only OffsetVector of monomer states on a filament.\nThis can be invalid after any mutations to context, so copy if needed."
  },
  {
    "objectID": "docstrings/medyan.newfilament_rand--432ec27232aad41e.html",
    "href": "docstrings/medyan.newfilament_rand--432ec27232aad41e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "newfilament_rand!(c::Context, monomerstates; iterations = 10^9, ftid = 1)\nAdd a filament with type id ftid to the Context with random center position and direction.\nReturn the filament id of a new filament.\nmonomerstates is a collection of the MonomerState of the monomers in the new filament.\nThe filament will be inside the mech boundary.\nErrors if it fails to add a filament.\nThe monomer are spaced by the value in the filament type’s mechanical parameters."
  },
  {
    "objectID": "docstrings/medyan.set_mechboundary--b5e26b6b690256aa.html",
    "href": "docstrings/medyan.set_mechboundary--b5e26b6b690256aa.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_mechboundary!(\n    c::MEDYAN.Context;\n    kwargs...\n) -> MEDYAN.Boundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the mechanical boundary of the simulation\nE = 1//2 * relu(pos ⋅ planes[bi][1:3] - planes[bi][4])^2\nFor example, a mech bounding plane [1,0,0,3] would try and make x < 3 nm with a spring constant of 1 pN/nm.\n2.0*[1,0,0,3] would try and make x < 3 nm with a spring constant of 4 pN/nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the mechanical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is the spring constant (pN/nm).\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\nE = 1//2*k*relu(d - r0)^2 where:\n\nd is the distance of the point to the spine line segment described by capsules[bi][1:6].\nr0 is capsules[bi][7]\nk is capsules[bi][8]"
  },
  {
    "objectID": "docstrings/base.iterate-5228367cd62c0bf2.html",
    "href": "docstrings/base.iterate-5228367cd62c0bf2.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Iterates through valid IDs in the StableIndex."
  },
  {
    "objectID": "docstrings/medyan.addpossiblecadherinsite--ae8586daa0b5454a.html",
    "href": "docstrings/medyan.addpossiblecadherinsite--ae8586daa0b5454a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addpossiblecadherinsite!(s::SysDef,possiblecadherinsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.chem_newlink_2mon--e4f84fe5cfa9a727.html",
    "href": "docstrings/medyan.chem_newlink_2mon--e4f84fe5cfa9a727.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_newlink_2mon!(c::Context, ltid::Int, endnames::Pair{MonomerName,MonomerName}, link_2mon_state::Link2MonState;\n    new_lid::Union{Nothing,Int64} = nothing,\n)::Int64\n\nchem_newlink_2mon!(c::Context, ltid::Int, endnames::Pair{MonomerName,MonomerName};\n    changedchemstate = (;),\n    changedmechstate = (;),\n    is_minimized = c.link_2mon_data[ltid].params.defaultstate.is_minimized,\n    new_lid::Union{Nothing,Int64} = nothing,\n)::Int64\nAdd a new link_2mon with type id ltid between monemers endnames.\nReturn the link_2mon id.\nError if a link_2mon of the same type links the same monomers in the same order.\nIf the link2mon state isn’t provided, c.link*2mon*data[ltid].params.defaultstate is new link2mon’s state, optionally modified by the changedchemstate, changedmechstate, and is_minimized keyword arguments.\nKeyword arguments changedchemstate and changedmechstate are namedtuples that shadow fields from the default chemstate and mechstate for the new link_2mon.\nKeyword argument is_minimized can be used to set the new link*2mon’s is*minimized state.\nKeyword argument new_lid can be optionally used to set the new link_2mon’s id, if this id is currently used, error.\n\n\nlid = chem_newlink_2mon!(c, g.ltid, minusname=>plusname;\n        changedmechstate = (L0 = dist,),\n        changedchemstate = (numHeads = rand(g.numHeadsMin:g.numHeadsMax),),\n    )"
  },
  {
    "objectID": "docstrings/medyan.mon_3states-6c16efb303a60058.html",
    "href": "docstrings/medyan.mon_3states-6c16efb303a60058.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_3states(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Tuple{UInt8, UInt8, UInt8}\nReturn a tuple of three monomer states centered at a monomer.\nIf a monomer doesn’t exist, its state will be zero. The filament must exist."
  },
  {
    "objectID": "docstrings/medyan.add_link_2mon--b801c872b8ff168a.html",
    "href": "docstrings/medyan.add_link_2mon--b801c872b8ff168a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "add_link_2mon!(s::SysDef,link_2mon_typename::Symbol,defaultstate::Link2MonState,mechparams;no_collide=false)\nAdd the link_2mon to the system. Return s.\nSetting no_collide to true allows cylinders this link_2mon type connects and adjacent cylinders to clip.\n```julia"
  },
  {
    "objectID": "docstrings/base.---a21e771ed8ea7d6f.html",
    "href": "docstrings/base.---a21e771ed8ea7d6f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "scale the volume and area\n\n\n\n\n\n\n\n\n\n\n\n\nscale the volume and area by different amounts in each direction"
  },
  {
    "objectID": "docstrings/medyan.addcadherin--3c757785fa097c75.html",
    "href": "docstrings/medyan.addcadherin--3c757785fa097c75.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addcadherin!(s::SysDef,cadherintypename::Symbol,defaultstate::CadherinState,mechparams). Add the cadherin to the system. Return s."
  },
  {
    "objectID": "docstrings/medyan.chem_addfixedcount--0286edfebf8ea5e6.html",
    "href": "docstrings/medyan.chem_addfixedcount--0286edfebf8ea5e6.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_addfixedcount!(c::Context, sid, cid, inccount)\nAdd inccount to fixed species id sid in compartment id cid"
  },
  {
    "objectID": "docstrings/medyan.mon_position_plusvector-927d0affbbdfef6f.html",
    "href": "docstrings/medyan.mon_position_plusvector-927d0affbbdfef6f.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_position_plusvector(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Tuple{StaticArraysCore.SVector{3, Float64}, StaticArraysCore.SVector{3, Float64}}\nReturn a tuple of position and plusvector at a monomer."
  },
  {
    "objectID": "docstrings/medyan.resolve_all_filament_mesh_crossing--a8be83a7d2ad65c7.html",
    "href": "docstrings/medyan.resolve_all_filament_mesh_crossing--a8be83a7d2ad65c7.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Given an AABB tree corresponding to up-to-date membrane mesh triangles, resolve all filament-membrane intersections.\nRequires\n\nup-to-date unit normals of all triangles in the meshes.\nup-to-date AABB tree corresponding to all membrane meshes."
  },
  {
    "objectID": "docstrings/medyan.vertex_state-aa3350c08b68b63a.html",
    "href": "docstrings/medyan.vertex_state-aa3350c08b68b63a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "vertex_state(\n    c::MEDYAN.Context,\n    vertexname::MEDYAN.VertexName\n) -> UInt8\nReturn the vertex state on a membrane."
  },
  {
    "objectID": "docstrings/medyan.vertexname-2d87a6a86cabc4f5.html",
    "href": "docstrings/medyan.vertexname-2d87a6a86cabc4f5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "membraneindex::Int64: membrane index\nvid::Int64: vertex id"
  },
  {
    "objectID": "docstrings/medyan.link2monsiteslipbond-2cec57cbea12864e.html",
    "href": "docstrings/medyan.link2monsiteslipbond-2cec57cbea12864e.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Models unbinding rates based on the following exponential form of Bell et al, 1978: min(k0*exp(f/f0), kmax) Where f is the magnitude of the force. So as to exponetially increase the unbinding with more force.\nlink_2mon_sitecount returns the unbinding rate in units of 1/s It returns k0 if the link_2mon hasn’t been minimized yet.\n\nf0::Float64: The charicteristic force magnitude. Units of pN\nk0::Float64: Unbinding rate at zero force. Units of 1/s\nkmax::Float64: Maximum rate. Units of 1/s"
  },
  {
    "objectID": "docstrings/medyan.context-736368ed32b08894.html",
    "href": "docstrings/medyan.context-736368ed32b08894.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "statedef::MEDYAN.StateDef\ncompartments::Vector{MEDYAN.Compartment}\ngrid::Any\ntime::Ref{Float64}: time (s)\nstats::MEDYAN.PerformanceStats\nβ::Float64: inverse kT (1/(nm*pN))\nbase_diffusion_coeffs::Vector{Float64}: Diffusion coefficients indexed by diffusing species id (nm²/s)\nmembrane_species_params::StaticArraysCore.SVector{NUM_MEMBRANEDIFFUSINGSPECIES, MEDYAN.MembraneSpeciesParams} where NUM_MEMBRANEDIFFUSINGSPECIES: Membrane species parameters indexed by membrane diffusing species id.\nmin_compartment_volume_ratio::Float64: Smallest volume a compartment can have before being deactivated as a ratio to a full compartment volume.\nchemistryengine::MEDYAN.RDMESampler: The reaction diffusion master equation sampler, contains the diffusing and regular fixed species state\nlargestfilamentid::Vector{Int64}: The largest filament id, indexed by filament type id\nchem_cylinders::Vector{MEDYAN.ChemCylinders}: Data about filament cylinders, indexed by filament type id\nmembranes::Vector: All membrane meshes.\nlink_2mon_data::Tuple{Vararg{MEDYAN.Link2MonData}}: The linked link2mon parameters, indexed by link2mon type id, to give a Link2MonData\nlinkablesite_managers::Tuple{Vararg{MEDYAN.AbstractLinkableSiteManager}}: The linkable site managers, indexed by linkable site id\nlinked_monomers::Dictionaries.Dictionary{MEDYAN.MonomerName, Vector{Vector{Int64}}}: Dictionary of all monomers that have a bound link2mon. indexed by monomer name, then link2montypeid, to give a vector of unique link2mon ids that reference the monomer name\nfilamentsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filament site definitions, indexed by filament type id, filament site id to get a SiteData with fields of id, site, fxsid\nfilamentendsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The filamentend site definitions, indexed by filament type id, filamentend site id to get a SiteData with fields of id, site, fxsid\nmaxfilsite_plusrange::Vector{Int64}: The maximum plus range in monomers that any filament site or end site can see. Indexed by filament type id\nmaxfilsite_minusrange::Vector{Int64}: The maximum minus range in monomers that any filament site or end site can see. Indexed by filament type id\nmembranesites::Tuple{Vararg{MEDYAN.SiteData}}: Maps membrane site id to a SiteData with fields of id, site, fxsid.\nmap_membranediffusingspeciesindex_membranesiteindices::Tuple{Vararg{Vector{Int64}}}: Maps membrane diffusing species index to a list of membrane sites using this species as reactant. This is initialized during context init and should not be changed.\nlink_2mon_sites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}: The link2mon site definitions, indexed by link2mon type id, link_2mon site id to get a SiteData with fields of id, site, fxsid\nlinkablesites::Tuple{Vararg{MEDYAN.SiteData}}: The linkable site definitions, indexed by linkable site id to get a SiteData with fields of id, site, fxsid\ncadherinsites::Tuple{Vararg{Tuple{Vararg{MEDYAN.SiteData}}}}\ncadherindata::Tuple{Vararg{MEDYAN.CadherinData}}\npossiblecadherinsite_managers::Tuple{Vararg{MEDYAN.AbstractPossibleCadherinSiteManager}}: The linkable site managers, indexed by linkable site id\ncadherinlinked_vertices::Dictionaries.Dictionary{MEDYAN.VertexName, Vector{Vector{Pair{MEDYAN.VertexName, MEDYAN.MonomerName}}}}: Dictionary of all vertices that have a bound cadherin. indexed by vertex name, then cadherintypeid, to give a vector of unique cadherin endnames that reference the monomer name and vertex name\ncheck_sitecount_error::Bool: If true site counts are checked for errors on every chem update. This is extremely slow, but useful for testing chem update errors.\ncompartmentreactioncallbacks::Any\nbulkreactioncallbacks::Any\nmemdiff_bulks_index::Int64: Mock bulk species index for membrane diffusion.\ng_tol::Float64: maximum force magnitude after minimization (pN)\nshake_before_minimization::Bool: If true, add noise to coordinates before starting minimization.\niter_max_cg_minimization::Int64: Max number of steps in conjugate gradient minimization.\nmaxstep::Float64: max step to take during line search (nm)\nmax_cylinder_force::Float64: max cylinder force when two cylinders are at zero distance (pN)\ncheck_neighborlist_error::Bool: If true neighborlists are checked for errors on every force calc. This is extremely slow, but useful for testing neighborlist errors.\nnthreads::Int64: Experimental Set to more than 1 to enable multi threading. This is currently may result in non bitwise reproducable simulations. Results should be statistcally identical, but this is currently not well tested.\nenable_cylinder_volume_exclusion::Ref{Bool}: Are cylinder volume exclusion forces calculated\nenable_triangle_bead_volume_exclusion::Bool: Are triangle-bead volume exclusion forces calculated.\ncylinder_skin_radius::Float64: Extra cell list cutoff radius in nm. The cell lists are reset after a bead moves over this amount\nfilamentmechparams::Vector{MEDYAN.FilamentMechParams}: The filament mechanical parameters, indexed by filament type id\nmembranemechparams::Vector{MEDYAN.MembraneMechParams}: Membrane mechanical parameters, indexed by membrane type id.\nfunc_membranespeciespotentialenergy::Any: Membrane species potential energy function. See docs on default function for more info.\nfunc_membranespeciesfreeenergy!::Any: Membrane species total free energy function. See docs on default function for more info.\nmembranefilamentmechparams::MEDYAN.MembraneFilamentMechParams: Membrane-filament mechanical interaction parameters.\nexternal_energy_forces!::Any: External energy/force expressions. This should be a function (vectorizedforce, vectorizedx, vectorizeresult) -> energy, which also modifies the force as well. The energy and force must be consistent, and this is not checked. The neighbor lists and related are currently not accessible in the vectorizedinfo. This can be used as ad-hoc solutions to experiment with uncommon forces, such as specifically designed attachments, etc. If this variable is used often, consider moving it into MEDYAN.\nchemboundary::MEDYAN.Boundary: chemical boundary, updates compartment volumes and diffusion rates\nmeshindex_as_chemboundary::Ref{Int64}: The membrane index used as chemical boundary. If values other than 0 is used, the actual interior region of the chemical boundary is the intersection between\n\nthe interior of chemboundary, and\nthe interior of the membrane mesh at this index.\n\nNote: Since the membrane may change its shape often, set_chemboundary! might need to be called often accordingly to update volumes of compartments.\nmechboundary::MEDYAN.Boundary: mechanical boundary\nsharedtypedconfigs::MEDYAN.SharedTypedConfigs: Shared configurations stored in type parameters.\nvalidflags::MEDYAN.ValidFlags: Interval system consistency validation flags."
  },
  {
    "objectID": "docstrings/medyan.monomername-bb517706cb60c4f5.html",
    "href": "docstrings/medyan.monomername-bb517706cb60c4f5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "ftid::Int64: filament type id\nfid::Int64: filament id\nmid::Int64: monomer id"
  },
  {
    "objectID": "docstrings/medyan.mon_exists-898c415a5eddc619.html",
    "href": "docstrings/medyan.mon_exists-898c415a5eddc619.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_exists(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> Bool\nReturn true iff the filament and monomer exists"
  },
  {
    "objectID": "docstrings/medyan.addreactioncallback--9c9d46adeded2d88.html",
    "href": "docstrings/medyan.addreactioncallback--9c9d46adeded2d88.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addreactioncallback!(s::SysDef, reaction::CompartmentReaction, callback)::SysDef\naddreactioncallback!(s::SysDef, reactantexpr::AbstractString, rate::Float64, invvolumepower::Int, callback)::SysDef\nLike addreaction! but also adds callback. callback is called when the reaction happens with input of MEDYAN.Context and Int the compartment id where the reaction happened.\nThe reaction should normally have no net stoichiometry because the callback should handle updating species counts. If an AbstractString is passed instead of a CompartmentReaction for the reaction, that string will be parsed to determine the reactants. The net stoichiometry will be zero.\nMEDYAN.errorcheck_addcallback(callback,s::SysDef) can optionally be overloaded to add errorchecking when the callback is added.\n\n\n\n\n\n\n\n\n\n\n\n\nCallback for bulk reactions: Context -> Nothing."
  },
  {
    "objectID": "docstrings/base.haskey-e7d3f961991e2663.html",
    "href": "docstrings/base.haskey-e7d3f961991e2663.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Whether an ID is in use."
  },
  {
    "objectID": "docstrings/medyan.refresh_chem_cache--f90ebca1f896ad2c.html",
    "href": "docstrings/medyan.refresh_chem_cache--f90ebca1f896ad2c.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "refresh_chem_cache!(c::Context)::Nothing\nNormally this isn’t needed as it will happen automatically."
  },
  {
    "objectID": "docstrings/medyan.defer_chem_caching--9538a1c449f3da93.html",
    "href": "docstrings/medyan.defer_chem_caching--9538a1c449f3da93.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "defer_chem_caching!(c::Context)::Nothing\nThis should only be used for advanced optimizations.\nDuring chemistry, the context mutating functions will typically try to avoid invalidating various cached data needed to quickly sample sites.\nHowever, if you want to mutate the context outside of chemistry, for example right before or after minimization, you may not want to pay the cost of revalidating all the caches because minimization will already invalidate the caches. Caching will be enabled again and caches will be made valid the next time chemistry is run. Caching can also be manually refreshed and reenabled with: refresh_chem_cache!"
  },
  {
    "objectID": "docstrings/medyan.link2monsitemotorstall-deb10f7964d5bef9.html",
    "href": "docstrings/medyan.link2monsitemotorstall-deb10f7964d5bef9.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Models myosin walking rates from the results of Erdmann et al. 2013. The parallel cluster model.\nAs the motor work per step increases, its walking rate goes to zero.\nReturns the walking rate of one end. The callback can then sample which end to move, or reject the move.\n\nfs::Float64: The stall force magnitude. Units of pN\nk0::Float64: Walking rate of one end at zero force. Units of 1/s\nα::Float64: Positive dimensionless parameter defining the steepness of the curve, smaller is more steep, if α is inf, the curve is linear\nwalking_direction::Int32: Motor walking direction, +1 is towards plus end, -1 is towards minus end\nisminusend::Bool: which motor end does this represent"
  },
  {
    "objectID": "docstrings/medyan.chem_removefilament--f36888837f14bad7.html",
    "href": "docstrings/medyan.chem_removefilament--f36888837f14bad7.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_removefilament!(c::Context; ftid=1, fid=maximum(filtype_fil_ids(c, ftid)))\nRemove the filament with type id ftid and id fid.\nBy default the last added filament with type id ftid is removed.\nWarn if any monomers on the filament are referenced by any link2mons, and remove those link2mons.\nThe warning can be disabled by passing keyword argument warniflink_2mon_removed=false"
  },
  {
    "objectID": "docstrings/medyan.minimize_energy--84c4aeab5457d3ee.html",
    "href": "docstrings/medyan.minimize_energy--84c4aeab5457d3ee.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "minimize_energy!(c::Context)\nMinimize mechanical energy of the context."
  },
  {
    "objectID": "docstrings/medyan.cadherinparams-b70febdaf4c8fba5.html",
    "href": "docstrings/medyan.cadherinparams-b70febdaf4c8fba5.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Cadherin Parameters, there is one instance of this per cadherin type\n\ndefaultstate::MEDYAN.CadherinState\nmechparams::Any"
  },
  {
    "objectID": "docstrings/medyan.fil_node_positions-618a66637eb50781.html",
    "href": "docstrings/medyan.fil_node_positions-618a66637eb50781.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "fil_node_positions(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> Vector{StaticArraysCore.SVector{3, Float64}}\nReturn the node positions of the filament"
  },
  {
    "objectID": "docstrings/medyan.addunbindinglink_2mon_site--76d17dbe625169cd.html",
    "href": "docstrings/medyan.addunbindinglink_2mon_site--76d17dbe625169cd.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add unbinding site, callback, and reaction. Return s.\n\n\n\ns::SysDef: the system to add to.\nlink_2mon_typename::Symbol: the link_2mon type name.\nlink_2mon_sitename::Symbol: the new name of the link_2mon_site added. This can be used as a catalyst in other reactions.\nlink_2mon_site: the link_2mon site to add.\nplusfilamenttypename::Symbol: the filament type name of the plus end.\nplusnewmonomerstatename::Symbol: the new name of the monomer state of the plus end.\nminusfilamenttypename::Symbol: the filament type name of the minus end.\nminusnewmonomerstatename::Symbol: the new name of the monomer state of the minus end.\nreactionexpr::AbstractString: Allows adding other reactants or products to the reaction. \" + link_2mon_site.$(link_2mon_typename).$(link_2mon_sitename) + \" gets added to both sides this to create the full reaction expression. See addreaction! for syntax.\nrate::Float64: Base rate for the reaction. ((nm³)^(invvolumepower)/s)\ninvvolumepower::Int: volumefactor= (1/volume)^invvolumepower where volume is the volume of the compartment in nm³. volumefactor only applies to this reaction not any other reaction using link_2mon_sitename Generally this is 0 for reactions without another diffusing reactant, and 1 if there is another diffusing reactant."
  },
  {
    "objectID": "docstrings/medyan.mon_position-83983d8916347411.html",
    "href": "docstrings/medyan.mon_position-83983d8916347411.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "mon_position(\n    c::MEDYAN.Context,\n    monomer::MEDYAN.MonomerName\n) -> StaticArraysCore.SVector{3, Float64}\nReturn the monomer position."
  },
  {
    "objectID": "docstrings/medyan.set_chemboundary--0aa6e4e95c60f9f7.html",
    "href": "docstrings/medyan.set_chemboundary--0aa6e4e95c60f9f7.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "set_chemboundary!(\n    c::MEDYAN.Context;\n    meshindex_as_chemboundary,\n    kwargs...\n) -> MEDYAN.Boundary\nSet chemical boundary and update compartment volumes and diffusion rates. Note, the chemboundary should be outside the mechboundary so that it is rare for filaments to go outside the chemboundary\n\n\n\nplanes::Vector{SVector{4,Float64}} = []\n\nPlanes that make up the chemical boundary of the simulation\ninside = signbit(pos ⋅ planes[bi][1:3] - planes[bi][4])\nFor example, a plane [1,0,0,3] is inside if x < 3 nm.\n2.0*[1,0,0,3] is also inside if x < 3 nm.\n\ncapsules::Vector{SVector{8,Float64}} = []\n\nCapsules that make up the chemical boundary of the simulation.\ncapsules[bi][1:3] is the starting point of the spine line segment (nm). capsules[bi][4:6] is the axis of the spine line segment (nm). capsules[bi][7] is the radius (nm). capsules[bi][8] is ignored.\nif capsules[bi][4:6] is zero then the capsule is a sphere. Capsule boundaries can be combined with plane boundaries to create cylinder boundaries.\n\nmeshindex_as_chemboundary::Int = 0: Index of membrane mesh that further restricts the chem boundary. 0 for none.\n\nThe system geometry information must be up-to-date. This mesh index is not stored in the boundary object, but is directly set in the context."
  },
  {
    "objectID": "docstrings/medyan.linkablesiterange-8facd8a85195dbd0.html",
    "href": "docstrings/medyan.linkablesiterange-8facd8a85195dbd0.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Any pair within max to min range are linkable if they have matching state with minusstate and plusstate.\n\nminusftid::Int64\nplusftid::Int64\nminusskip::Int64\nplusskip::Int64\nminusstate::UInt8\nplusstate::UInt8\nminrange::Float64\nmaxrange::Float64"
  },
  {
    "objectID": "docstrings/medyan.addmembranediffusingcount_rand--7b719dca63a36b1b.html",
    "href": "docstrings/medyan.addmembranediffusingcount_rand--7b719dca63a36b1b.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addmembranediffusingcount_rand!(\n    c::MEDYAN.Context,\n    membraneindex::Int64,\n    speciesindex::Int64,\n    addcount::Int64\n)\nDistribute the added membrane species count randomly to membrane cells, ignoring cell area difference. Does NOT update propensity."
  },
  {
    "objectID": "docstrings/medyan.membranespeciesparams-548fecb643fc2599.html",
    "href": "docstrings/medyan.membranespeciesparams-548fecb643fc2599.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Membrane protein physical parameters.\n\ndiffusion_coeff::Float64: Membrane diffusion coefficients (nm^2/s).\narea::Float64: Protein area projected onto the surface (nm^2).\nkbend::Float64: Bending rigidity (pN nm).\neqcurv::Float64: The protein’s own spontaneous mean curvature (/nm). Can be used in bending energy computations with curvatures."
  },
  {
    "objectID": "docstrings/medyan.link2monstate-9845e7e08620ea8a.html",
    "href": "docstrings/medyan.link2monstate-9845e7e08620ea8a.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "There is one instance of this per link_2mon.\n\nchemstate::NamedTuple: Other state.\nmechstate::NamedTuple: Used in link_2mon force calculation.\nis_minimized::Bool: Set to true after minimization"
  },
  {
    "objectID": "docstrings/medyan.chem_polymerize--7a5e88ac36e4ccbf.html",
    "href": "docstrings/medyan.chem_polymerize--7a5e88ac36e4ccbf.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_polymerize!(c::Context, ftid, fid, isminusend::Bool, newstate::MonomerState)\nAdd a monomer with state newstate to the end of the filament with type id ftid and id fid.\nIf isminusend is true add the monomer to the minus end of the filament, if false add it to the plus end of the filament.\nThis doesn’t affect the other monomer states, positions, linked link_2mons, or change any of the monomer names. New monomers are not linkable until after minimization."
  },
  {
    "objectID": "docstrings/base.empty--418304748816268d.html",
    "href": "docstrings/base.empty--418304748816268d.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Clear all index records.\n\n\n\n\n\n\n\n\n\n\n\n\nempty!(c::Context)\nRemove all filaments, membranes, link_2mons, cadherins, diffusing species, fixed species, bulk species, chemboundary, and mechboundary."
  },
  {
    "objectID": "docstrings/medyan.addcadherinsite--9e21ac42968d0196.html",
    "href": "docstrings/medyan.addcadherinsite--9e21ac42968d0196.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addcadherinsite!(s::SysDef,cadherintypename::Symbol,cadherinsitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/base.setindex--725f722fff4cfa6d.html",
    "href": "docstrings/base.setindex--725f722fff4cfa6d.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Map ID to a new index. The ID must be in use."
  },
  {
    "objectID": "docstrings/medyan.chem_setmonomerstate--ed756af0de4db0ca.html",
    "href": "docstrings/medyan.chem_setmonomerstate--ed756af0de4db0ca.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "chem_setmonomerstate!(c::Context, name::MonomerName, state::MonomerState)\nUpdate a monomer state."
  },
  {
    "objectID": "docstrings/medyan.fil_node_mon_ids-b1d3d66a81296343.html",
    "href": "docstrings/medyan.fil_node_mon_ids-b1d3d66a81296343.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "fil_node_mon_ids(\n    c::MEDYAN.Context,\n    ftid::Int64,\n    fil_id::Int64\n) -> Vector{Int64}\nReturn the node monomer ids of the filament.\nThe fil_node_mon_ids are the monomer ids at (slightly plus side of) the fil_node_positions\n                                 |\n                      -----+-----|-----+-----\n  minus end <----       M  |  M  | (M) |  M        ----> plus end\n                      -----+-----|-----+-----\n                                 |\n                                 ^ A node position is indicated by the line.\n\nThe monomer id with parenthesis (M) will in `fil_node_mon_ids`\nThe first monomer id is the first monomer id on the filament. The last monomer id is the last monomer id on the filament + 1"
  },
  {
    "objectID": "docstrings/medyan.addlinkablesite--9ffc8c8377769414.html",
    "href": "docstrings/medyan.addlinkablesite--9ffc8c8377769414.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "addlinkablesite!(s::SysDef,linkablesitename::Symbol,site)::SysDef"
  },
  {
    "objectID": "docstrings/medyan.filamentendsitegeneral-7a32ac96fb4364ea.html",
    "href": "docstrings/medyan.filamentendsitegeneral-7a32ac96fb4364ea.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Filament end site that matches with a vector of monomer states.\n\nisminusend::Bool\nendstates::Vector{UInt8}\nspacing::Float64"
  },
  {
    "objectID": "docstrings/base.push--8715d52e2302aaeb.html",
    "href": "docstrings/base.push--8715d52e2302aaeb.html",
    "title": "MEDYAN.jl",
    "section": "",
    "text": "Add a new index. Returns its ID."
  }
]