{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MEDYAN The documentation for MEDYAN , an efficient and scalable computational model for mechanochemical simulations of active matter networks created by the Papoian lab at the University of Maryland. Installation To use MEDYAN, one needs to build it from the source. The full procedure for installation is described here .","title":"Home"},{"location":"#medyan","text":"The documentation for MEDYAN , an efficient and scalable computational model for mechanochemical simulations of active matter networks created by the Papoian lab at the University of Maryland.","title":"MEDYAN"},{"location":"#installation","text":"To use MEDYAN, one needs to build it from the source. The full procedure for installation is described here .","title":"Installation"},{"location":"development/debugging/","text":"Debugging MEDYAN VS Code Note: On MacOS the default VS Code C++ debugger is buggy so use the CodeLLDB extension instead. Build MEDYAN for debug > MEDYAN_CMAKE_EXTRA_ARGS=\"-DCMAKE_BUILD_TYPE=Debug\" ./conf.sh > cd build > make Set command line arguments Open Run and Debug side panel and click \"create a launch.json file\". Make \"program\": \"${workspaceFolder}/build/medyan\" .\\ Make \"cwd\": the directory to run MEDYAN from. For example, \"${workspaceFolder}/examples/2filaments\" Edit the \"args\": [], line to include the command line arguments you want to debug with. For example, [\"-s\", \"systeminput.txt\", \"-i\", \".\", \"-o\", \"./sampleResults\"] Save launch.json , and now you should be able to create breakpoints and debug in VS Code.","title":"Debugging MEDYAN"},{"location":"development/debugging/#debugging-medyan","text":"","title":"Debugging MEDYAN"},{"location":"development/debugging/#vs-code","text":"Note: On MacOS the default VS Code C++ debugger is buggy so use the CodeLLDB extension instead.","title":"VS Code"},{"location":"development/debugging/#build-medyan-for-debug","text":"> MEDYAN_CMAKE_EXTRA_ARGS=\"-DCMAKE_BUILD_TYPE=Debug\" ./conf.sh > cd build > make","title":"Build MEDYAN for debug"},{"location":"development/debugging/#set-command-line-arguments","text":"Open Run and Debug side panel and click \"create a launch.json file\". Make \"program\": \"${workspaceFolder}/build/medyan\" .\\ Make \"cwd\": the directory to run MEDYAN from. For example, \"${workspaceFolder}/examples/2filaments\" Edit the \"args\": [], line to include the command line arguments you want to debug with. For example, [\"-s\", \"systeminput.txt\", \"-i\", \".\", \"-o\", \"./sampleResults\"] Save launch.json , and now you should be able to create breakpoints and debug in VS Code.","title":"Set command line arguments"},{"location":"development/reaction/","text":"Chemical reaction structure in MEDYAN The chemistry diffusion-reaction simulation is implemented with variants of Gillespie's algorithms, which consists of the following parts that work cooperatively. Chemical species TODO: add description Chemical reactions ReactionBase is the abstract base class for all chemical reaction classes. It manages the chemical reaction rates and interacts with the chemistry simulation algorithm. Specifically, in the Next Reaction Method (NRM), it manages the reaction dependencies. It also specifies the interface for reactions, such that an implementation of the ReactionBase should include how to update dependencies what to do when the reaction is fired what to do when the reaction is activated or passivated how to calculate propensity what to do when the reaction rate is updated In practice, the implementation should be able to access information to all reactant and product species. An example of the implementation is the Reaction<M,N> class template, where M and N are, respectively, the number of reactants and products, which should be resolved at compile time. Another example of the implementation is the ReactionDy class where the number of reactants and products can be specified at run time. Below is a brief introduction of what a Reaction<M,N> can do, including its construction and destruction. ReactionDy has a similar implementation, so only the differences will be mentioned. (Constructor) The ReactionBase constructor will handle the initialization of reaction rate and factors. The Reaction<M,N> constructor will store the address of all the associated species, and then register all other activated reactions that have any reactant species showing up in reactant/product species of this reaction as dependents (ie the change of any species in this reaction will affect the propensities of all the dependent reactions). It also records the address of itself in all associated species. \u2139\ufe0f The constructor by default sets the new reaction to be passivated . (Destructor) The Reaction<M,N> destructor will unregister itself from all associated species. \u26a0\ufe0f To avoid dangling pointers, the address of each reaction should not be changed during its lifespan. \u26a0\ufe0f All the associated species of a reaction should remain valid and have the address unchanged during the reaction's lifespan. TODO: other functions","title":"Reaction"},{"location":"development/reaction/#chemical-reaction-structure-in-medyan","text":"The chemistry diffusion-reaction simulation is implemented with variants of Gillespie's algorithms, which consists of the following parts that work cooperatively.","title":"Chemical reaction structure in MEDYAN"},{"location":"development/reaction/#chemical-species","text":"TODO: add description","title":"Chemical species"},{"location":"development/reaction/#chemical-reactions","text":"ReactionBase is the abstract base class for all chemical reaction classes. It manages the chemical reaction rates and interacts with the chemistry simulation algorithm. Specifically, in the Next Reaction Method (NRM), it manages the reaction dependencies. It also specifies the interface for reactions, such that an implementation of the ReactionBase should include how to update dependencies what to do when the reaction is fired what to do when the reaction is activated or passivated how to calculate propensity what to do when the reaction rate is updated In practice, the implementation should be able to access information to all reactant and product species. An example of the implementation is the Reaction<M,N> class template, where M and N are, respectively, the number of reactants and products, which should be resolved at compile time. Another example of the implementation is the ReactionDy class where the number of reactants and products can be specified at run time. Below is a brief introduction of what a Reaction<M,N> can do, including its construction and destruction. ReactionDy has a similar implementation, so only the differences will be mentioned. (Constructor) The ReactionBase constructor will handle the initialization of reaction rate and factors. The Reaction<M,N> constructor will store the address of all the associated species, and then register all other activated reactions that have any reactant species showing up in reactant/product species of this reaction as dependents (ie the change of any species in this reaction will affect the propensities of all the dependent reactions). It also records the address of itself in all associated species. \u2139\ufe0f The constructor by default sets the new reaction to be passivated . (Destructor) The Reaction<M,N> destructor will unregister itself from all associated species. \u26a0\ufe0f To avoid dangling pointers, the address of each reaction should not be changed during its lifespan. \u26a0\ufe0f All the associated species of a reaction should remain valid and have the address unchanged during the reaction's lifespan. TODO: other functions","title":"Chemical reactions"},{"location":"development/units/","text":"Units used in MEDYAN SI Units usage Base units Quantity SI Base unit MEDYAN unit lg ratio Length m nm -9 Mass kg g -3 Time s s 0 Electric Current A - - Temperature K K 0 Amount of Substance mol - - Luminous Intensity cd - - Derived units Quantity SI Base unit SI Derived unit MEDYAN unit lg ratio Energy kg\u22c5m 2 \u22c5s -2 J pN\u22c5nm -21 Force kg\u22c5m\u22c5s -2 N pN -12","title":"Units"},{"location":"development/units/#units-used-in-medyan","text":"","title":"Units used in MEDYAN"},{"location":"development/units/#si-units-usage","text":"","title":"SI Units usage"},{"location":"development/units/#base-units","text":"Quantity SI Base unit MEDYAN unit lg ratio Length m nm -9 Mass kg g -3 Time s s 0 Electric Current A - - Temperature K K 0 Amount of Substance mol - - Luminous Intensity cd - -","title":"Base units"},{"location":"development/units/#derived-units","text":"Quantity SI Base unit SI Derived unit MEDYAN unit lg ratio Energy kg\u22c5m 2 \u22c5s -2 J pN\u22c5nm -21 Force kg\u22c5m\u22c5s -2 N pN -12","title":"Derived units"},{"location":"development/design/adaptive-mesh-impl/","text":"Adaptive surface meshing implementation in MEDYAN Goals The goals are to improve the correctness of numerical simulation of membrane deformations. Remeshing will be applied after energy minimization. Goal Explanation Proximity The new mesh and the original mesh must approximate the same geometry. Size quality The vertices should be denser where high local curvatures are observed. Shape quality The triangles should be as equilateral as possible. Implementations Achieving the goals The goal for proximity is discussed in [ Pascal J. Frey, About surface remeshing (2000)] and [ Pascal J. Frey et al, Geometric surface mesh optimization (1998)]. The remeshing operations must respect the geometic measures. Size quality is pursued in most adaptive mesh papers, as the mesh density should be controlled by the local geometry, typically curvature. In terms of the curvature mesh size adaptation, the idea is equivalent as the smoothness criterion, which requires that the normal vectors of any two neighboring triangles are almost parallel. Size quality is mainly achieved by adding/subtracting nodes from the mesh. Node addition are mainly by edge-splitting, and node subtraction are mainly by edge-collapsing. An additional goal discussed in [ Frey 1998 ] is the size gradation control , which means that the gradient of size quality on the surface should not be too big. This will help improve the shape quality below. Triangle shape quality is required by numerical simulations. Many local approximations render bad results when triangles are in bad shape, aka away from being equilateral. Errors might also arise when, for example, negative Voronoi area around a vertex due to bad neighbor triangle shapes. Point relocation (or relaxation) and edge-flipping are the main methods of achieving this goal. Mesh operations Relaxation is discussed in [ Vittorio Cristini et al, An adaptive mesh algorithm for evolving surfaces: simulations of drop breakup and coalescence (2001)]. The vertices are moved inside their tangent planes responding to forces that try to bring edges to their preferred lengths. The sizes of the edges are precomputed to best achieve the size quality and shape quality, via curvature criteria averaged over local regions. Node relocation discussed in [ Frey 1998 ] and [ Frey 2000 ] serves only to achieve shape quality, since size quality has already been achieved via other means. Edge-flipping is performed to increase the neighbor triangle shape quality. In general, it is only performed given (1) the topology after flipping is feasible, (2) the neighbor triangles are almost coplanar, and (3) the neighbor triangle quality will be improved after edge flipping. It is also mentioned in [ Frey 1998 ] that this operation could also improve geometric quality, but in [ Frey 2000 ], the coplanar criterion preserves geometric approximation. Edge-splitting is performed when new vertices are needed to improve the size quality. In [ Frey 1998 ], the new vertex is introduced in the middle of an edge (that is \"too long\") and then snapped to the geometric support, while in [ Cristini 2001 ], edge-splitting do not happen individually, but rather inserts 3 vertices at once on the edges of a triangle, equivalent to 3 edge-splittings plus 1 edge-flipping, followed by local relaxation. Local relaxation/edge-flipping might follow each edge-flipping process. Edge-collapsing is performed when vertices should be subtracted to improve the size quality. It is generally achieved by collapsing edges that are \"too short\". This operation will not be applied if the quality of the neighboring triangles decrease too much. Local relaxation might follow in [ Cristnin 2001 ]. Important value calculation Vertex normals Vertex normals could be computed as a weighted average of neighbor triangle normal vectors. Here we use angles of the vertex in the triangles as the weights, and the resulting vertex normal is effectively the so-called pseudo normal. Curvatures and size criteria Curvatures can be calculated in a variety of ways, and the size dependency on the curvature can also be different. The easiest way is described in [ Frey 1998 ] where only the neighbor edge direction and triangle normals are used. The curvature information is used to determine the preferred sizes of the edges. [ Frey 1998 ] and [ Frey 2000 ] discusses rectification of the preferred sizes to control mesh gradation using H-correction , while in [ Cristini 2001 ] the local averaging scheme achieves a similar goal.","title":"Adaptive surface meshing implementation in MEDYAN"},{"location":"development/design/adaptive-mesh-impl/#adaptive-surface-meshing-implementation-in-medyan","text":"","title":"Adaptive surface meshing implementation in MEDYAN"},{"location":"development/design/adaptive-mesh-impl/#goals","text":"The goals are to improve the correctness of numerical simulation of membrane deformations. Remeshing will be applied after energy minimization. Goal Explanation Proximity The new mesh and the original mesh must approximate the same geometry. Size quality The vertices should be denser where high local curvatures are observed. Shape quality The triangles should be as equilateral as possible.","title":"Goals"},{"location":"development/design/adaptive-mesh-impl/#implementations","text":"","title":"Implementations"},{"location":"development/design/adaptive-mesh-impl/#achieving-the-goals","text":"The goal for proximity is discussed in [ Pascal J. Frey, About surface remeshing (2000)] and [ Pascal J. Frey et al, Geometric surface mesh optimization (1998)]. The remeshing operations must respect the geometic measures. Size quality is pursued in most adaptive mesh papers, as the mesh density should be controlled by the local geometry, typically curvature. In terms of the curvature mesh size adaptation, the idea is equivalent as the smoothness criterion, which requires that the normal vectors of any two neighboring triangles are almost parallel. Size quality is mainly achieved by adding/subtracting nodes from the mesh. Node addition are mainly by edge-splitting, and node subtraction are mainly by edge-collapsing. An additional goal discussed in [ Frey 1998 ] is the size gradation control , which means that the gradient of size quality on the surface should not be too big. This will help improve the shape quality below. Triangle shape quality is required by numerical simulations. Many local approximations render bad results when triangles are in bad shape, aka away from being equilateral. Errors might also arise when, for example, negative Voronoi area around a vertex due to bad neighbor triangle shapes. Point relocation (or relaxation) and edge-flipping are the main methods of achieving this goal.","title":"Achieving the goals"},{"location":"development/design/adaptive-mesh-impl/#mesh-operations","text":"Relaxation is discussed in [ Vittorio Cristini et al, An adaptive mesh algorithm for evolving surfaces: simulations of drop breakup and coalescence (2001)]. The vertices are moved inside their tangent planes responding to forces that try to bring edges to their preferred lengths. The sizes of the edges are precomputed to best achieve the size quality and shape quality, via curvature criteria averaged over local regions. Node relocation discussed in [ Frey 1998 ] and [ Frey 2000 ] serves only to achieve shape quality, since size quality has already been achieved via other means. Edge-flipping is performed to increase the neighbor triangle shape quality. In general, it is only performed given (1) the topology after flipping is feasible, (2) the neighbor triangles are almost coplanar, and (3) the neighbor triangle quality will be improved after edge flipping. It is also mentioned in [ Frey 1998 ] that this operation could also improve geometric quality, but in [ Frey 2000 ], the coplanar criterion preserves geometric approximation. Edge-splitting is performed when new vertices are needed to improve the size quality. In [ Frey 1998 ], the new vertex is introduced in the middle of an edge (that is \"too long\") and then snapped to the geometric support, while in [ Cristini 2001 ], edge-splitting do not happen individually, but rather inserts 3 vertices at once on the edges of a triangle, equivalent to 3 edge-splittings plus 1 edge-flipping, followed by local relaxation. Local relaxation/edge-flipping might follow each edge-flipping process. Edge-collapsing is performed when vertices should be subtracted to improve the size quality. It is generally achieved by collapsing edges that are \"too short\". This operation will not be applied if the quality of the neighboring triangles decrease too much. Local relaxation might follow in [ Cristnin 2001 ].","title":"Mesh operations"},{"location":"development/design/adaptive-mesh-impl/#important-value-calculation","text":"","title":"Important value calculation"},{"location":"development/design/adaptive-mesh-impl/#vertex-normals","text":"Vertex normals could be computed as a weighted average of neighbor triangle normal vectors. Here we use angles of the vertex in the triangles as the weights, and the resulting vertex normal is effectively the so-called pseudo normal.","title":"Vertex normals"},{"location":"development/design/adaptive-mesh-impl/#curvatures-and-size-criteria","text":"Curvatures can be calculated in a variety of ways, and the size dependency on the curvature can also be different. The easiest way is described in [ Frey 1998 ] where only the neighbor edge direction and triangle normals are used. The curvature information is used to determine the preferred sizes of the edges. [ Frey 1998 ] and [ Frey 2000 ] discusses rectification of the preferred sizes to control mesh gradation using H-correction , while in [ Cristini 2001 ] the local averaging scheme achieves a similar goal.","title":"Curvatures and size criteria"},{"location":"development/design/array-of-dof/","text":"Array of degrees of freedom Used in energy minimization (or integration of equation of motion, or Monte Carlo methods). Currently, as of MEDYAN v4.1.1, we store all the coordinate data into a 1D array (wrapped in a VecArray class template, which mocks a 3 x N matrix using a 1D array with 3N elements). The forces and other auxiliary data are stored in the same way, and we'll use the coordinate array as the example. Beads hold references to the corresponding data in the array. When a bead is deleted, the Database class would mark in the 1D coordinate array with deleted indices, which do not affect other bead coordinate data. When a new bead is created, filling holes in the coordinate array will be prioritized than appending at the end. In this way, there's always a possibility that holes exist in the array. However, the energy minimization method expects a contiguous storage of coordinates, which requires us to \"rearrange\" the data in that 1D array, meaning to change indices of certain coordinate data to fill in all the holes. The 1D array structure is used and maintained throughout the simulation. However, those taking part in the energy minimization might not necessarily be Cartesian coordinates in $\\mathbb{R}^3$. Some examples are: the local 2D coordinates of a protein on the membrane and the parameters used in exponential curve interpolation for filament parametrization. How should we take care of these parameters? Should we pack these parameters together in that 1D array, or should we simply treat them separately? To answer these questions, we should revisit the decisions we've made to store coordinate data inside a 1D array, to see what are the benefits and what are the costs. Coordinates stored in 1D array Theoretical benefits: (Performance) Operations that are core to the minimization algorithm, like moving coordinates according to the forces, are highly vectorized, resulting in higher performance. (Performance) The bead coordinate data can be rearranged in a way that makes data access of some of the force fields contiguous. The filament stretching and bending force fields can potentially benefit from it. It is not obvious how more randomized access could benefit from this, such as the linker stretching force field. (Code) It is made clear that the 1D arrays mainly serve the purpose for the energy minimization algorithm. For example, the \"descent direction\" in the conjugate gradient method has no obvious physical meaning. Costs: (Code) When a rearrangement of the array happens, all array_view -like objects are invalidated, with only the references in Bead class updated. So any code referencing coordinate data must obtain the new data from the corresponding Beads. Currently, Cylinder::updateAllData() does this. Ties: Compared to the implementation where coordinates are stored separately in each bead, a random computation using the coordinates of the bead should not have very different performance, because both require some random access on the memory. It is worth pointing out that the coordinate array, the force arrays and other auxiliary arrays are not all the information required by the energy minimization process. The force field also needs to know the set of indices in those arrays to work with, the information given by the network. Intermediate computation results, such as triangle areas and their derivatives on the coordinates, are also needed by the force fields. Non-coordinate degrees of freedom The game changes if we want to incorporate coordinates that are not Cartesian coordinates in $\\mathbb{R}^3$. However, we would still want coordinates of a minimalistic set to be stored contiguously in memory. For example, for the coordinate $(x, y, z)$, with the pointer to the $x$ coordinate being px , the address of $y$ and $z$ should still be px + 1 and px + 2 . One way is to continue to store everything into the original 1D array, and then all the previous benefits on the performance of the minimization algorithm would still be there. However, the maintenance of the structure would be very hard. Outside the energy minimization, when different elements are dynamically destroyed, the holes left in the array would be of different sizes, depending on the number of degrees of freedom used by the elements, and, as a result, new elements created may not efficiently find the holes that are suitable to fill. For the same reason, rearrangement of this new 1D array would be hard as well. The solution is to switch back to the original implementation in MEDYAN, where the 1D array is only created when entering energy minimization, by the previous \"vectorization\" process. The array would not be used outside the mechanical processes. In this way, a new cost is introduced: the data copying to the array before energy minimization and from the array after energy minimization. This data copying should not be a bottleneck on the overall performance given that it is a one-time cost per minimization. Another way would be to store each set of coordinates with the same number of degrees of freedom into a standalone 1D array. For example, the normal coordinates can be stored in the original VecArray< 3, double > structure, while 2D coordinates like those used to mark the position on the membrane can be stored in a different VecArray< 2, double > structure. In this way, the dynamic element addition/removal works exactly as before, with easy mark-as-deletion and hole-filling processes. The benefit that comes from the highly vectorized operation in energy minimization would be slightly cut down because operations previously performed on a single array now needs to be performed on multiple arrays. The performance difference with these two ways should not be significantly different, since the cost they introduce is relatively small. From the perspective of writing clearer codes, however, the first way is better at separating purposes: it makes the energy minimization and the rest of the program less coupled, because the coordinate data layout in the memory is not restricted to the layout required by the energy minimization.","title":"Array of degrees of freedom"},{"location":"development/design/array-of-dof/#array-of-degrees-of-freedom","text":"Used in energy minimization (or integration of equation of motion, or Monte Carlo methods). Currently, as of MEDYAN v4.1.1, we store all the coordinate data into a 1D array (wrapped in a VecArray class template, which mocks a 3 x N matrix using a 1D array with 3N elements). The forces and other auxiliary data are stored in the same way, and we'll use the coordinate array as the example. Beads hold references to the corresponding data in the array. When a bead is deleted, the Database class would mark in the 1D coordinate array with deleted indices, which do not affect other bead coordinate data. When a new bead is created, filling holes in the coordinate array will be prioritized than appending at the end. In this way, there's always a possibility that holes exist in the array. However, the energy minimization method expects a contiguous storage of coordinates, which requires us to \"rearrange\" the data in that 1D array, meaning to change indices of certain coordinate data to fill in all the holes. The 1D array structure is used and maintained throughout the simulation. However, those taking part in the energy minimization might not necessarily be Cartesian coordinates in $\\mathbb{R}^3$. Some examples are: the local 2D coordinates of a protein on the membrane and the parameters used in exponential curve interpolation for filament parametrization. How should we take care of these parameters? Should we pack these parameters together in that 1D array, or should we simply treat them separately? To answer these questions, we should revisit the decisions we've made to store coordinate data inside a 1D array, to see what are the benefits and what are the costs.","title":"Array of degrees of freedom"},{"location":"development/design/array-of-dof/#coordinates-stored-in-1d-array","text":"Theoretical benefits: (Performance) Operations that are core to the minimization algorithm, like moving coordinates according to the forces, are highly vectorized, resulting in higher performance. (Performance) The bead coordinate data can be rearranged in a way that makes data access of some of the force fields contiguous. The filament stretching and bending force fields can potentially benefit from it. It is not obvious how more randomized access could benefit from this, such as the linker stretching force field. (Code) It is made clear that the 1D arrays mainly serve the purpose for the energy minimization algorithm. For example, the \"descent direction\" in the conjugate gradient method has no obvious physical meaning. Costs: (Code) When a rearrangement of the array happens, all array_view -like objects are invalidated, with only the references in Bead class updated. So any code referencing coordinate data must obtain the new data from the corresponding Beads. Currently, Cylinder::updateAllData() does this. Ties: Compared to the implementation where coordinates are stored separately in each bead, a random computation using the coordinates of the bead should not have very different performance, because both require some random access on the memory. It is worth pointing out that the coordinate array, the force arrays and other auxiliary arrays are not all the information required by the energy minimization process. The force field also needs to know the set of indices in those arrays to work with, the information given by the network. Intermediate computation results, such as triangle areas and their derivatives on the coordinates, are also needed by the force fields.","title":"Coordinates stored in 1D array"},{"location":"development/design/array-of-dof/#non-coordinate-degrees-of-freedom","text":"The game changes if we want to incorporate coordinates that are not Cartesian coordinates in $\\mathbb{R}^3$. However, we would still want coordinates of a minimalistic set to be stored contiguously in memory. For example, for the coordinate $(x, y, z)$, with the pointer to the $x$ coordinate being px , the address of $y$ and $z$ should still be px + 1 and px + 2 . One way is to continue to store everything into the original 1D array, and then all the previous benefits on the performance of the minimization algorithm would still be there. However, the maintenance of the structure would be very hard. Outside the energy minimization, when different elements are dynamically destroyed, the holes left in the array would be of different sizes, depending on the number of degrees of freedom used by the elements, and, as a result, new elements created may not efficiently find the holes that are suitable to fill. For the same reason, rearrangement of this new 1D array would be hard as well. The solution is to switch back to the original implementation in MEDYAN, where the 1D array is only created when entering energy minimization, by the previous \"vectorization\" process. The array would not be used outside the mechanical processes. In this way, a new cost is introduced: the data copying to the array before energy minimization and from the array after energy minimization. This data copying should not be a bottleneck on the overall performance given that it is a one-time cost per minimization. Another way would be to store each set of coordinates with the same number of degrees of freedom into a standalone 1D array. For example, the normal coordinates can be stored in the original VecArray< 3, double > structure, while 2D coordinates like those used to mark the position on the membrane can be stored in a different VecArray< 2, double > structure. In this way, the dynamic element addition/removal works exactly as before, with easy mark-as-deletion and hole-filling processes. The benefit that comes from the highly vectorized operation in energy minimization would be slightly cut down because operations previously performed on a single array now needs to be performed on multiple arrays. The performance difference with these two ways should not be significantly different, since the cost they introduce is relatively small. From the perspective of writing clearer codes, however, the first way is better at separating purposes: it makes the energy minimization and the rest of the program less coupled, because the coordinate data layout in the memory is not restricted to the layout required by the energy minimization.","title":"Non-coordinate degrees of freedom"},{"location":"development/design/command-line-parsing/","text":"Command line parsing An input from command line is important to specify important runtime environment variables other than simulation parameters (which are read using the input file). Command line input plays a different role from input file Command line input and the input files both provide runtime information for the program. Input files specify all the simulation related contents, while the command line input specifies the parameters needed only for how the software runs. That is to say, no matter how the command line input changes, if the input files stay the same, we could always consider them as the \"same simulations\" . Due to this difference, the two different sources of input could contain the following information. Command line input Where to find the input files, and where the output should go Methods of informational output (log level, log file, verbosity, ...) Fixed random seed if applicable Parallelization methods (number of cores, mpi, ...) Auto restart configuration (e.g. start with restart is a restart file is available) Input files Simulation duration, algorithms used and algorithm parameters Name of additional input files Simulation output categories (currently useless) Geometric, mechanochemical parameters Simulation initialization parameters Command line input information storage As the command line input provides different information from the input files, the structure that holds the information from command line input could also be separated from the system parameters. They could be stored as global variables in a certain namespace or as members of a class. We should limit the ability to change these global variables everywhere. To achieve that without adding get / set functions for every variable, we can put the global variables in a struct, and use this struct as a private static member of another class. The class could provide two accessors, one for const access and one for non-const access. The code might look like the follows. struct RuntimeGlobalVariableContainer { int some_integer; std::string some_string; // ... }; class Global { private: static RuntimeGlobalVariableContainer _runtime; // Definition elsewhere public: static const RuntimeGlobalVariableContainer& runtime() { return _runtime; } static RuntimeGlobalVariableContainer& runtimeMutable() { return _runtime; } }; Then, when trying to access a global variable without modification, one can use something like Global::runtime().some_integer to access the variable. For the functions like the parser that actually writes to the global variables, one has to use Global::runtimeMutable().some_integer to access the variables in a non-const manner. One could also provide only the const accessor, and mark certain functions as friend to the class Global , so that they can access the non-const members using Global::_runtime.some_integer . This method is similar to current implementation of SysParams class in MEDYAN. But in this way, one class can only implement one set of accessibility control. Command line parsing specs for MEDYAN No standard exists for command line parsing, and implementations vary a lot in popular programs. But there are some common conventions and other command line parsing libraries that we could follow. Currently, MEDYAN is using getopt as the command line parser, but getopt offers limited functionality and is not portable (GNU project). Therefore, it is natural to write our very own parser that suits our needs. The following specifies the MEDYAN command line syntax and parser. General For simplicity, the lexing, parsing, data writing and simple data validation should be combined to a one-pass process. More validations can be applied after parsing is complete, such as option mutual exclusivity, option requiredness and number range check. We do not explicitly support groups (optional or mutual exclusive) during parsing such as MEDYAN [-a (-b | -c -d)] [-e | -f -g] , though they could be checked in the validation process after parsing. In the help message, groups will not be hinted. The command line syntax looks like this cmd <required-options> [<options>] [--] <positional-arguments> cmd <sub-command> where <> encloses the name of an object and [] means optional. Positional argument A command can specify 0 or more positional arguments. To avoid recursive parsing, only one set of positional argument specification is allowed for a command, i.e. when reading a positional argument, the parser must know what this positional argument mean, and the type of this argument. And hence the following specifications. A positional argument can be required or optional. In a command, an optional positional argument must appear later than the last required positional argument. Therefore, the following is a correct usage of positional arguments cmd <file> [<path>] [<id>] and the following is illegal cmd [<file>] <path> A positional argument could also be a positional argument list, denoted as <argument-list>... . At most one positional argument list is allowed in one command, and must be after all the other positional arguments. A required positional argument list takes 1 or more arguments, and an optional positional argument list takes 0 or more arguments. If there exists at least one optional positional argument in a command that is not a list, then the positional argument list must be optional. Therefore, the following cases are the correct usages cmd <arg1> <arg2> <arg-list>... cmd <arg1> [<arg2>] [<arg-list>...] while the following are incorrect usages cmd <arg-list>... <arg1> cmd <arg1> <arg-list1>... <arg-list2>... cmd [<arg1>] <arg-list>... For illegal cases in specification, an error should be generated before parsing. During parsing, the parser will always fill the positional arguments from the first to the last, regardless of requiredness. For example, if the program specifies this cmd1 <arg1> [<arg2>] [<arg3>] [<arg-list>...] cmd2 <arg1> [<arg-list>...] and runs with the following cmd1 100 200 cmd2 100 200 then in cmd1 , 200 will always bind with arg2 , and in cmd2 , 200 is the first and only element in arg-list . If the number of positional arguments supplied is more than the maximum number of positional argument and there is no argument list specified, an error should be generated. If the number of positional arguments supplied is less than the number of required positional argument, the parsing could finish successfully, but should fail the validation process after parsing, which generates an error. Option A command can specify 0 or more options. Unlike positional arguments, options can appear anywhere after the command, before the positional argument delimiter -- (see next section). An option starts with an option marker, and can take 0 or 1 variable right after the option marker. The option marker could be a short option marker or a long option marker. A short option marker is 2 characters. The first character is - , and the second character is anything but - . During parsing, if the option takes 1 variable, then (1) if the argument is longer than 2 characters, the rest of the argument will be considered as the variable (2) otherwise the next argument will be considered as the argument. In the 2nd case, if the next argument does not exist (end of argument list), an error should be generated. For example, if -t is an option that takes 1 variable, then -t est and -test both mean taking \"est\" as the variable of -t option, and an error should be generated for -t without further arguments. If the option takes 0 variable and the argument has more than 2 characters, then append - before the rest, and parse it accordingly. For example, if -t does not take variable, then -test will be treated as the option -t showing up, and the parser will try to parse -est next. As a more complicated example, assume -s and -e are options that take 1 variable, and -t is an option that takes no variable, then -test is parsed as -t -e st where -t shows up, -e shows up and gets a variable \"st\" and -s does not show up. A long option marker has more than 2 characters and starts with -- , and should not contain the character = . During parsing, the longest starting part in an argument that satisfies the criteria will be considered the long option marker. If the option takes no variable and = shows up, an error should be generated. If the option takes 1 variable, then (1) if at least one = shows up, everything after the first = will be considered the variable (2) otherwise, the next argument will be considered the variable. In the 2nd case, if the next argument does not exist (end of argument list), an error should be generated. For example, if --test is an option that takes one variable, then --test=yes and --test yes both mean taking \"yes\" as the variable of the --test option, and an error should be generated for --test without further arguments. Specifically, using = allows specifying empty string variable for options using long option markers. For example, if --test takes one variable, then --test= means giving empty string to --test as the variable. During parsing, if an argument can be considered as an option, but the option does not exist, then an error is generated. If one really wants a positional argument that looks like an option, consider using the positional argument delimiter -- . Like positional arguments, an option can be required or optional. That an option is required means that the option must show up at least once. However, the requiredness should not have effect during parsing, as it can only be checked when parsing is finished. Nevertheless, the requiredness should be hinted in the help message. Positional argument delimiter -- During parsing, the positional argument delimiter is an argument that is exactly -- . In a command, anything after -- is considered positional arguments of that command, even if they look like options, subcommands or even the delimiter. For example, if the specified syntax looks like this cmd [-a] [-b] -c [--] <arg1> [<arg2>] [<arg-list>...] cmd subcmd1 cmd subcmd2 Then running cmd -b -c -- -a subcmd1 -- subcmd2 means that -b and -c show up, -a does not show up, arg1 = \"-a\" , arg2 = \"subcmd1\" and arg-list = [\"--\", \"subcmd2\"] . Notice that everything after the first -- is considered the positional argument. Subcommand A command can specify 0 or more subcommands. During parsing, the first argument that is not an option will be matched against the list of subcommands. If it matches a subcommand, the subcommand will take over and parse all the remaining arguments. The control will not return to the parent command, which implies that running multiple subcommands in the same nested level is not possible. For example, with specification cmd [--] [<arg1>] cmd subcmd1 then running with cmd subcmd1 will run subcommand subcmd1 and leave arg1 uninitialized (probably default value), but running with cmd subcmd2 will set arg1 to be subcmd2 , since there is no subcommand with name subcmd2 . If one really needs the positional argument that has the name of a subcommand, consider using the positional argument delimiter -- . A subcommand works like a command, and can specify its own positional arguments, options and subcommands. During parsing, when control moves to a subcommand, the subcommands and positional arguments of the parent command will no longer have effect. The options of the parent command, however, will be inherited to the subcommand, but subcommand options can overwrite the parent options with the same name. When parsing a subcommand, the parser should try to look for the option of an option-like argument from the most nested subcommand, all the way to the options of the main command, and if no option can be found, an error should be generated. Help message Help message displays the basic usage of a command. A typical help message might look like this: Usage: cmd <required-options> [<options>] [--] <arg1> [<arg2>] [<arg-list>...] Subcommands: subcmd-name Description subcmd-name-2 Description 2 Options: -o, --option [Required] Description -2, --option-2 Description 2 --option-3=<val> Description 3 The parser should provide an auxiliary function that generates the formatted help message with the given specification. By convention, -h and --help options should be added to every command and subcommand to generate the help message and exit the program. Also the help message should be printed on parsing errors of the associated subcommand. The subcommand help message should contain the chain of all parent command names. For example, $ cmd run install --help Usage: cmd run install [<options>] [--] <arg1> <arg-list>... Options: -f, --file=<path> File location Procedure and error handling The program should hard code the specification for all commands and subcommands. Before parsing, the specification will be checked against some rules, and if an violation happens, an exception should be thrown without handling, so that it aborts the parsing and the rest of the program, so no help message should be printed, as this is an internal error. During parsing, the arguments of the main function int argc, char *argv[] will be fed to the parser. The parsing process follows the rules mentioned in the previous sections. If an error occurs, an exception should be thrown, which should be handled outside the parser. The simple data writing and validation should happen along with the parsing process. The parser should decide whether the simple data writing and validation is successful, and if it is not, an exception should be thrown which should be handled outside the parser. The handler should print the error, print the help message generated by the parser, and abort the program. After parsing is complete, further validation and other initialization could kick in. The validation may decide to print the help message as needed. Specifically, an unprovided required option or unprovided required positional argument should result in the failure of the validation process, causing it to print the help message and abort the program.","title":"Command line parsing"},{"location":"development/design/command-line-parsing/#command-line-parsing","text":"An input from command line is important to specify important runtime environment variables other than simulation parameters (which are read using the input file).","title":"Command line parsing"},{"location":"development/design/command-line-parsing/#command-line-input-plays-a-different-role-from-input-file","text":"Command line input and the input files both provide runtime information for the program. Input files specify all the simulation related contents, while the command line input specifies the parameters needed only for how the software runs. That is to say, no matter how the command line input changes, if the input files stay the same, we could always consider them as the \"same simulations\" . Due to this difference, the two different sources of input could contain the following information.","title":"Command line input plays a different role from input file"},{"location":"development/design/command-line-parsing/#command-line-input","text":"Where to find the input files, and where the output should go Methods of informational output (log level, log file, verbosity, ...) Fixed random seed if applicable Parallelization methods (number of cores, mpi, ...) Auto restart configuration (e.g. start with restart is a restart file is available)","title":"Command line input"},{"location":"development/design/command-line-parsing/#input-files","text":"Simulation duration, algorithms used and algorithm parameters Name of additional input files Simulation output categories (currently useless) Geometric, mechanochemical parameters Simulation initialization parameters","title":"Input files"},{"location":"development/design/command-line-parsing/#command-line-input-information-storage","text":"As the command line input provides different information from the input files, the structure that holds the information from command line input could also be separated from the system parameters. They could be stored as global variables in a certain namespace or as members of a class. We should limit the ability to change these global variables everywhere. To achieve that without adding get / set functions for every variable, we can put the global variables in a struct, and use this struct as a private static member of another class. The class could provide two accessors, one for const access and one for non-const access. The code might look like the follows. struct RuntimeGlobalVariableContainer { int some_integer; std::string some_string; // ... }; class Global { private: static RuntimeGlobalVariableContainer _runtime; // Definition elsewhere public: static const RuntimeGlobalVariableContainer& runtime() { return _runtime; } static RuntimeGlobalVariableContainer& runtimeMutable() { return _runtime; } }; Then, when trying to access a global variable without modification, one can use something like Global::runtime().some_integer to access the variable. For the functions like the parser that actually writes to the global variables, one has to use Global::runtimeMutable().some_integer to access the variables in a non-const manner. One could also provide only the const accessor, and mark certain functions as friend to the class Global , so that they can access the non-const members using Global::_runtime.some_integer . This method is similar to current implementation of SysParams class in MEDYAN. But in this way, one class can only implement one set of accessibility control.","title":"Command line input information storage"},{"location":"development/design/command-line-parsing/#command-line-parsing-specs-for-medyan","text":"No standard exists for command line parsing, and implementations vary a lot in popular programs. But there are some common conventions and other command line parsing libraries that we could follow. Currently, MEDYAN is using getopt as the command line parser, but getopt offers limited functionality and is not portable (GNU project). Therefore, it is natural to write our very own parser that suits our needs. The following specifies the MEDYAN command line syntax and parser.","title":"Command line parsing specs for MEDYAN"},{"location":"development/design/command-line-parsing/#general","text":"For simplicity, the lexing, parsing, data writing and simple data validation should be combined to a one-pass process. More validations can be applied after parsing is complete, such as option mutual exclusivity, option requiredness and number range check. We do not explicitly support groups (optional or mutual exclusive) during parsing such as MEDYAN [-a (-b | -c -d)] [-e | -f -g] , though they could be checked in the validation process after parsing. In the help message, groups will not be hinted. The command line syntax looks like this cmd <required-options> [<options>] [--] <positional-arguments> cmd <sub-command> where <> encloses the name of an object and [] means optional.","title":"General"},{"location":"development/design/command-line-parsing/#positional-argument","text":"A command can specify 0 or more positional arguments. To avoid recursive parsing, only one set of positional argument specification is allowed for a command, i.e. when reading a positional argument, the parser must know what this positional argument mean, and the type of this argument. And hence the following specifications. A positional argument can be required or optional. In a command, an optional positional argument must appear later than the last required positional argument. Therefore, the following is a correct usage of positional arguments cmd <file> [<path>] [<id>] and the following is illegal cmd [<file>] <path> A positional argument could also be a positional argument list, denoted as <argument-list>... . At most one positional argument list is allowed in one command, and must be after all the other positional arguments. A required positional argument list takes 1 or more arguments, and an optional positional argument list takes 0 or more arguments. If there exists at least one optional positional argument in a command that is not a list, then the positional argument list must be optional. Therefore, the following cases are the correct usages cmd <arg1> <arg2> <arg-list>... cmd <arg1> [<arg2>] [<arg-list>...] while the following are incorrect usages cmd <arg-list>... <arg1> cmd <arg1> <arg-list1>... <arg-list2>... cmd [<arg1>] <arg-list>... For illegal cases in specification, an error should be generated before parsing. During parsing, the parser will always fill the positional arguments from the first to the last, regardless of requiredness. For example, if the program specifies this cmd1 <arg1> [<arg2>] [<arg3>] [<arg-list>...] cmd2 <arg1> [<arg-list>...] and runs with the following cmd1 100 200 cmd2 100 200 then in cmd1 , 200 will always bind with arg2 , and in cmd2 , 200 is the first and only element in arg-list . If the number of positional arguments supplied is more than the maximum number of positional argument and there is no argument list specified, an error should be generated. If the number of positional arguments supplied is less than the number of required positional argument, the parsing could finish successfully, but should fail the validation process after parsing, which generates an error.","title":"Positional argument"},{"location":"development/design/command-line-parsing/#option","text":"A command can specify 0 or more options. Unlike positional arguments, options can appear anywhere after the command, before the positional argument delimiter -- (see next section). An option starts with an option marker, and can take 0 or 1 variable right after the option marker. The option marker could be a short option marker or a long option marker. A short option marker is 2 characters. The first character is - , and the second character is anything but - . During parsing, if the option takes 1 variable, then (1) if the argument is longer than 2 characters, the rest of the argument will be considered as the variable (2) otherwise the next argument will be considered as the argument. In the 2nd case, if the next argument does not exist (end of argument list), an error should be generated. For example, if -t is an option that takes 1 variable, then -t est and -test both mean taking \"est\" as the variable of -t option, and an error should be generated for -t without further arguments. If the option takes 0 variable and the argument has more than 2 characters, then append - before the rest, and parse it accordingly. For example, if -t does not take variable, then -test will be treated as the option -t showing up, and the parser will try to parse -est next. As a more complicated example, assume -s and -e are options that take 1 variable, and -t is an option that takes no variable, then -test is parsed as -t -e st where -t shows up, -e shows up and gets a variable \"st\" and -s does not show up. A long option marker has more than 2 characters and starts with -- , and should not contain the character = . During parsing, the longest starting part in an argument that satisfies the criteria will be considered the long option marker. If the option takes no variable and = shows up, an error should be generated. If the option takes 1 variable, then (1) if at least one = shows up, everything after the first = will be considered the variable (2) otherwise, the next argument will be considered the variable. In the 2nd case, if the next argument does not exist (end of argument list), an error should be generated. For example, if --test is an option that takes one variable, then --test=yes and --test yes both mean taking \"yes\" as the variable of the --test option, and an error should be generated for --test without further arguments. Specifically, using = allows specifying empty string variable for options using long option markers. For example, if --test takes one variable, then --test= means giving empty string to --test as the variable. During parsing, if an argument can be considered as an option, but the option does not exist, then an error is generated. If one really wants a positional argument that looks like an option, consider using the positional argument delimiter -- . Like positional arguments, an option can be required or optional. That an option is required means that the option must show up at least once. However, the requiredness should not have effect during parsing, as it can only be checked when parsing is finished. Nevertheless, the requiredness should be hinted in the help message.","title":"Option"},{"location":"development/design/command-line-parsing/#positional-argument-delimiter-","text":"During parsing, the positional argument delimiter is an argument that is exactly -- . In a command, anything after -- is considered positional arguments of that command, even if they look like options, subcommands or even the delimiter. For example, if the specified syntax looks like this cmd [-a] [-b] -c [--] <arg1> [<arg2>] [<arg-list>...] cmd subcmd1 cmd subcmd2 Then running cmd -b -c -- -a subcmd1 -- subcmd2 means that -b and -c show up, -a does not show up, arg1 = \"-a\" , arg2 = \"subcmd1\" and arg-list = [\"--\", \"subcmd2\"] . Notice that everything after the first -- is considered the positional argument.","title":"Positional argument delimiter --"},{"location":"development/design/command-line-parsing/#subcommand","text":"A command can specify 0 or more subcommands. During parsing, the first argument that is not an option will be matched against the list of subcommands. If it matches a subcommand, the subcommand will take over and parse all the remaining arguments. The control will not return to the parent command, which implies that running multiple subcommands in the same nested level is not possible. For example, with specification cmd [--] [<arg1>] cmd subcmd1 then running with cmd subcmd1 will run subcommand subcmd1 and leave arg1 uninitialized (probably default value), but running with cmd subcmd2 will set arg1 to be subcmd2 , since there is no subcommand with name subcmd2 . If one really needs the positional argument that has the name of a subcommand, consider using the positional argument delimiter -- . A subcommand works like a command, and can specify its own positional arguments, options and subcommands. During parsing, when control moves to a subcommand, the subcommands and positional arguments of the parent command will no longer have effect. The options of the parent command, however, will be inherited to the subcommand, but subcommand options can overwrite the parent options with the same name. When parsing a subcommand, the parser should try to look for the option of an option-like argument from the most nested subcommand, all the way to the options of the main command, and if no option can be found, an error should be generated.","title":"Subcommand"},{"location":"development/design/command-line-parsing/#help-message","text":"Help message displays the basic usage of a command. A typical help message might look like this: Usage: cmd <required-options> [<options>] [--] <arg1> [<arg2>] [<arg-list>...] Subcommands: subcmd-name Description subcmd-name-2 Description 2 Options: -o, --option [Required] Description -2, --option-2 Description 2 --option-3=<val> Description 3 The parser should provide an auxiliary function that generates the formatted help message with the given specification. By convention, -h and --help options should be added to every command and subcommand to generate the help message and exit the program. Also the help message should be printed on parsing errors of the associated subcommand. The subcommand help message should contain the chain of all parent command names. For example, $ cmd run install --help Usage: cmd run install [<options>] [--] <arg1> <arg-list>... Options: -f, --file=<path> File location","title":"Help message"},{"location":"development/design/command-line-parsing/#procedure-and-error-handling","text":"The program should hard code the specification for all commands and subcommands. Before parsing, the specification will be checked against some rules, and if an violation happens, an exception should be thrown without handling, so that it aborts the parsing and the rest of the program, so no help message should be printed, as this is an internal error. During parsing, the arguments of the main function int argc, char *argv[] will be fed to the parser. The parsing process follows the rules mentioned in the previous sections. If an error occurs, an exception should be thrown, which should be handled outside the parser. The simple data writing and validation should happen along with the parsing process. The parser should decide whether the simple data writing and validation is successful, and if it is not, an exception should be thrown which should be handled outside the parser. The handler should print the error, print the help message generated by the parser, and abort the program. After parsing is complete, further validation and other initialization could kick in. The validation may decide to print the help message as needed. Specifically, an unprovided required option or unprovided required positional argument should result in the failure of the validation process, causing it to print the help message and abort the program.","title":"Procedure and error handling"},{"location":"manual/input-files/","text":"Input files The system file is a simple text file that defines all parameters of the simulation. The MEDYAN executable must take in a system file as a command line argument. The parameters are defined in a s-expressions: (parameter parameter-value) (parameter-group (property-1 property-1-value) (property-2 property-2-value)) The input files can also be generated using MEDYAN's interactive configuration by running medyan config , which provides limited configuration capabilities. All physical quantities in the input files will use the following base units, unless otherwise specified. name unit time s length nm mass g Some common derived units are displayed below. name unit force pN energy pN\u22c5nm diffusion coefficient nm\u00b2/s System input files Geometry The following geometric parameters can be set. All geometry parameters must be set in the system file, or a startup error will result. item type description NX int Number of compartments in X direction. NY int Number of compartments in Y direction. NZ int Number of compartments in Z direction. COMPARTMENTSIZEX double Size of compartment in X direction. COMPARTMENTSIZEY double Size of compartment in Y direction. COMPARTMENTSIZEZ double Size of compartment in Z direction. MONOMERSIZE double Size of monomer for filament growth (nm). CYLINDERSIZE double Size of cylinder in filament (nm). BOUNDARYSHAPE {SPHERICAL, CUBIC, CAPSULE} Boundary shape. BOUNDARYDIAMETER double Diameter for applicable shapes, including SPHERICAL and CAPSULE geometries. The CUBIC BOUNDARYSHAPE creates boundary planes 25nm in from the faces of compartment grid. If movement of boundaries is desired, the following parameters can also be set. If these parameters are not set, the system will assume non-moving boundaries. Currently, moving boundaries are only implemented for the CUBIC boundary shape. item type description BOUNDARYMOVE {NONE, ALL, TOP} Movement of a boundary. ALL specifies that all boundaries will move in the given direction, and top specifies that the top of the boundary in the z direction will move. BMOVESPEED double Speed of boundary movement in nm/s. If a negative value is given, the boundary will move towards the center of the grid. If positive, the boundary will move away from the center of the grid. BMOVESTARTTIME double Time at which the boundary will begin to move. If not specified, the boundary will start moving at the beginning of the simulation. BMOVEENDTIME double Time at which the boundary will stop movement. Mechanics The following mechanical parameters can be set. It is noted that the number of parameters for each force field must match the number of species of that type, specified in the system input file. This must be consistent for all simulation elements, including filaments, cross-linkers, motors, branchers, and bubbles. To set multiple parameters corresponding to multiple species, list the parameter values with space in between after the parameter qualifier. If a force field type is left blank, that force field will not be included in the simulation. item type description FSTRETCHINGTYPE {HARMONIC} Filament stretching force field. FSTRETCHINGK double Filament stretching force constant. FBENDINGTYPE {HARMONIC, COSINE} Filament bending force field. FBENDINGK double Filament bending force constant. FBENDINGTHETA double Filament bending angle (radians). LSTRETCHINGTYPE {HARMONIC} Cross-linker stretching force field. LSTRETCHINGK double Cross-linker stretching force constant. MSTRETCHINGTYPE {HARMONIC} Motor stretching force field. MSTRETCHINGK double Motor stretching force constant. BRSTRETCHINGTYPE {HARMONIC} Branching point stretching force field. BRSTRETCHINGK double Branching point stretching force constant. BRBENDINGTYPE {COSINE} Branching point bending force field. BRBENDINGK double Branching point bending force constant. BRBENDINGTHETA double Branching point bending angle (radians). BRDIHEDRALFFTYPE {COSINE} Branching point dihedral force field. BRDIHEDRALK double Branching point stretching force constant. BRPOSITIONTYPE {HARMONIC} Branching point position force field. BRPOSITIONK double Branching point position force constant. VOLUMEFFTYPE {integral, monomer} Volume force type. When monomer-based volume exclusion is used, volume-exclusion-monomer-interval can be specified as well. REPULSION is the old option for integral , but its use is deprecated. VOLUMECUTOFF double Volume interaction cutoff distance (nm). The volume force is only calculated on pairs of cylinders with mid points closer than this distance. This should always be larger than CYLINDERSIZE VOLUMEK double Volume force constant. volume-exclusion-monomer-interval list int Interval of monomer sampling for volume exclusion for each filament type. BOUNDARYFFTYPE {REPULSIONEXP} Boundary force type. BOUNDARYCUTOFF double Boundary interaction cutoff distance. BOUNDARYINTERACTIONK double Boundary force constant. BOUNDARYSCREENLENGTH double Boundary screening length constant. BUBBLEFFTYPE {REPULSIONEXP} Bubble force type. BUBBLECUTOFF double Boundary interaction cutoff distance. BUBBLEINTERACTIONK double Bubble force constant. BUBBLESCREENLENGTH double Bubble screening length constant. BUBBLERADIUS double Bubble radius. NUMBUBBLETYPES int Number of different bubble types. MTOCFFTYPE {ATTACHMENTHARMONIC} MTOC force type. membrane-tension-ff-type {CONSTANT} Membrane tension type. membrane-bending-ff-type {HELFRICH, HELFRICH_QUADRATIC} Membrane bending type. In quadratic mode, the spontaneous curvature is always assumed to be zero. volume-conservation-ff-type {MEMBRANE} Volume conservation type. triangle-bead-volume-ff-type {REPULSION} Triangle bead volume exclusion force type. triangle-bead-volume-k float Triangle bead volume exclusion force constant. triangle-bead-volume-cutoff float Triangle bead volume exclusion cutoff distance. triangle-bead-volume-cutoff-mech float Triangle bead volume exclusion cutoff distance during mechanical minimization. The system mechanical energy is minimized using the minimization algorithm, whose parameters can be specified as follows. item type description CONJUGATEGRADIENT {POLAKRIBIERE, FLETCHERRIEVES, STEEPESTDESCENT} Type of conjugate gradient minimization. GRADIENTTOLERANCE double Gradient tolerance in conjugate gradient (in pN). MAXDISTANCE double Maximum distance beads can be moved in minimization. LAMBDAMAX double Maximum lambda that can be returned in line search. try-to-recover-in-line-search-error {false, true} Defaults to true. If set to false, whenever line search fails to find a lower energy, the program will terminate with a diagnostic message. Chemistry The following chemical parameters can be set. It should be noted that the number of parameters listed for each chemical species type that resides on a filament must match the number of filament types, specified in the system input file. This must be consistent for all filament types. To set multiple parameters corresponding to multiple filaments, list the parameters with space in between after the parameter qualifier. All chemical parameters must be set unless otherwise noted in the description. For the motor parameters, the number of parameters must match the number of motor species in the system. For more information on chemical algorithms, see Popov et al (2016) . An alternate set of parameters can be specified in replacement of RUNTIME for smaller systems in which simulation time is based on explicit reaction steps; if RUNTIME is not initialized or set to zero, the parameter RUNSTEPS and its associated chemical step-based parameter set will be used if provided. item type description CHEMISTRYFILE string Input chemistry file. Should be in the input directory. CALGORITHM {GILLESPIE, NRM} Chemistry algorithm used. RUNSTEPS int Number of total chemical steps. If RUNTIME is set, will not be used. RUNTIME double Total runtime of simulation. SNAPSHOTSTEPS int Number of steps per snapshot. If SNAPSHOTTIME is set, will not be used. SNAPSHOTTIME double Time of each snapshot. MINIMIZATIONSTEPS int Number of chemical steps per mechanical equilibration. If MINIMIZATIONTIME is set, will not be used. MINIMIZATIONTIME double Time between each mechanical equilibration. NEIGHBORLISTSTEPS int Number of chemical steps per neighbor list update. This includes updating chemical reactions as well as force fields which rely on neighbor lists. If NEIGHBORLISTTIME is set, will not be used. NEIGHBORLISTTIME double Time between each neighbor list update. INITIALSLOWDOWNTIME double Length of time at the beginning of the simulation to run mechanical equilibrations and neighbor list updates 10x more frequently. Disabled by default. NUMFILAMENTTYPES int Number of different filament types. NUMBINDINGSITES int Number of binding sites per cylinder for each filament type defined. This will set binding sites for cross-linkers, motors, and other binding molecules. NUMMOTORHEADSMIN int Minimum number of motor heads per motor species defined. NUMMOTORHEADSMAX int Maximum number of motor heads per motor species defined. MOTORSTEPSIZE double Single motor head step size. DISSIPATIONTRACKING {OFF, ON} Whether to switch on the dissipation tracking feature. LINKERBINDINGSKIP int Switches on the different binding tracking feature to allow motors to have more binding spots per cylinder than linkers. The specified integer is the number of binding sites that the cross-linkers will skip before accepting a possible binding site. allow-same-filament-pair-binding bool Whether pairwise bindings on the same filament is allowed. Even if this is turned off, pairwise bindings will not happen on same or neighboring cylinders. EVENTTRACKING {OFF, ON} Whether to switch on the event tracking feature. Dynamic rates The following dynamic rate forms and parameters can be set. These parameters are characteristic lengths and amplitudes of the rate changing equations outlined in Popov et al (2016) . These can be tuned to mimic the stall and unbinding mechanochemical coupling of cross-linkers and myosin II motors. Note that if dynamic rates are enabled, the number of dynamic rate forms for each type of reaction must match the number of species of that type specified in the system input file, i.e. the number of forms for cross-linker unbinding must match the number of cross-linker species, etc. The number of parameters specified for each type of dynamic rate form must match the number of parameters required for those forms. See below for details, and see Popov et al (2016) for more information on the explicit forms. Parameters must be listed in order of the form that they correspond to, also corresponding to the species that they represent. item type description DFPOLYMERIZATIONTYPE {BROWRATCHET} Filament polymerization dynamic rate form. DFPOLYMERIZATIONLEN double Characteristic length for filament polymerization dynamic rate form. DLUNBINDINGTYPE {CATCHSLIP, SLIP} Cross-linker unbinding dynamic rate form. If CATCHSLIP , two parameters for DLUNBINDINGLEN and DLUNBINDINGAMP are needed to define the functional form. If SLIP , one DLUNBIDINGLEN is needed to define the functional form. DLUNBINDINGLEN double Characteristic length of cross-linker unbinding dynamic rate form. DLUNBINDINGAMP double Amplitude of cross-linker unbinding dynamic rate form. DMUNBINDINGTYPE {LOWDUTYCATCHSLIP, LOWDUTYSLIP} Myosin II unbinding dynamic rate form. If LOWDUTYCATCHSLIP , two parameters for DMUNBINDINGFORCE are needed to define the functional form. If LOWDUTYSLIP , one DMUNBIDINGFORCE is needed to define the functional form. DMUNBINDINGFORCE double Characteristic force of myosin II unbinding dynamic rate form. DMWALKINGTYPE {LOWDUTYSTALL} Myosin II walking dynamic rate form. Membrane profile and initialization A membrane profile can be defined using the following syntax: (membrane <profile-name> (<property> <value>) ...) where membrane properties include the following parameters. item type description vertex-system {material, general} In material vertex system, each vertex represents a patch of membrane with a fixed number of lipid molecules. In general vertex system, a vertex simply represents a point on the membrane surface. area-k float Area elasticity of membrane. Unit pN/nm. bending-k float Bending elasticity of membrane. Unit pN\u22c5nm. eq-curv float Spontaneous curvature of membrane. Unit 1/nm. tension float Membrane tension. Unit pN/nm. volume-k float Volume conservation force constant of a enclosing membrane. Unit pN/nm\u00b2. Membrane can be initialized with a specified membrane profile, using the following properties: (init-membrane <profile-name> (<property> <value>) ...) If the membrane profile name was not defined in the input file, a startup error will occur. The membrane initialization properties are defined using the following parameters. mesh : A list describing the initial membrane shape. Currently supporting the following shapes: An ellipsoid whose principal axes are parallel with the x, y, and z axes. Usage: ELLIPSOID center-x center-y center-z radius-x radius-y radius-z . A plane specified by a point and a normal vector. A bounding box is also needed to specify the sampling range. Usage: PLANE center_xyz... normal_xyz... box_origin_xyz... box_size_xyz... . eq-area-factor : A floating point value, such that the equilibrium area is the initial area multiplied by this factor. Starting filament configuration These parameters define the initial configuration and length of filaments in the system. It is noted that at least one filament, plus end, and minus end chemical species must be initialized in the chemistry input file, or a startup error will result. item type description FILAMENTFILE string Name of filament initialization file. This is not required. NUMFILAMENTS int Number of random filaments to initialize. These filaments will be randomly distributed in the system volume. FILAMENTLENGTH int Number of cylinders per filament to initialize, defining the initial length of the filaments. FILAMENTTYTPE int Filament type to initialize. PROJECTIONTYPE {STRAIGHT, ZIGZAG, ARC, PREDEFINED} Specifies how the beads are sampled between two ends of a filament. Projection type meaning for a filament specified by a set of 3D Cartesian coordinates [v0, v1, v2 ...] , and the number of beads. STRAIGHT - Creates a filament with minus end at v0 , and extends number-of-bead full-size cylinders in v0 -> v1 direction. v2, v3 ... are ignored. ZIGZAG - Creates a filament with minus end at v0 , and extends number-of-bead full-size cylinders in (1) v0 -> v1 direction (2) another different direction alternatively. v2, v3 ... are ignored. ARC - Not sure. (TODO: NEED DOCS) PREDEFINED - Creates a filament with bead coordinates [v0, v1, v2 ...] . WARNING: Each cylinder in the filament is treated as a full-sized cylinder, no matter what the initial bead coordinates are. That means each cylinder in the filament can be compressed or stretched initially. Starting bubble configuration The following bubble initialization parameters can be set. These parameters define the initial configuration of bubbles in the system, similar to the filament configuration parameters. It is noted that at least one type of bubble must be set, or a startup error will result. item type description BUBBLEFILE string Name of bubble initialization file. This is not required. NUMBUBBLES int Number of random filaments to initialize. These filaments will be randomly distributed in the system volume. BUBBLETYTPE int Bubble type to initialize. The following syntax is used to initialize a Microtubule Organizing Center (MTOC), or a bead for Atomic Force Microscopy (AFM), which are both implemented as a bubble with extra parameters. (init-mtoc (<property> <value>...) ...) (init-afm (<property> <value>...) ...) where most properties are shared by both MTOC and AFM. The properties are listed below. item type description bubble-type int Type of bubble to initialize. bubble-coord list float Coordinates of the bubble center. bubble-fixed {false, true} If the bubble is fixed, it's coordinates will not change during energy minimization. filament-type int Type of filament attachment. num-filaments int Number of filaments to attach to the bubble. num-cylinders-per-filament int Number of cylinders per filament to attach to the bubble. theta1, theta2, phi1, phi2 float Restricts the initial orientation of the filaments under certain transformations (read source code to see the details). Default to (0, 1, 0, 1), which allows all possible orientations. attachment-stretching-k float Stretching force constant for filament attachments. Special protocols The following special protocols can be initialized. These protocols must be set on different lines, so users should specify a new parameter, on separate lines, for each setup desired. (SPECIALPROTOCOL <name> <parameters>...) name parameters description PINBOUNDARYFILAMENTS <pinK> <pinDistance> <pinTime> Tether minus and plus ends that are within pinDistance (nm) from the boundary after pinTime (s). This will result in additional forces on the actin network form the boundary. PINLOWERBOUNDARYFILAMENTS <pinK> <pinTime> <pinFraction> Tether minus and plus ends that are within pinDistance (nm) from the lower boundary after pinTime (s). pinDistance has a default value (250 as of v5.1.0), but can be overwritten by other pinning protocols. pin-initial-filament-below-z <pinK> <pinZ> Pin all initial beads with z coordinate lower than pinZ (nm). MAKEFILAMENTSSTATIC, MAKELINKERSSTATIC <time> Make either filament or cross-linker chemistry static after a certain amount of time . RATEDEPEND <time> <force> Starting at time , increase plus end polymerization rate for actin filaments under larger tension than force (pN). AFM <step1> <step2> <iter-change> <step-total> <step-time> AFM protocol. scale-membrane-eq-area <rate> <min-eq-area> For all membranes without lipid reservoir, increase its equilibrium area with rate (nm^2/s). Each equilibrium area cannot drop below min-eq-area (nm^2). scale-membrane-eq-volume <rate> <min-eq-volume> For all closed membranes, increase its equilibrium volume with rate (nm^3/s). Each equilibrium volume cannot drop below min-eq-volume (nm^3). Chemistry input files The chemistry input file, whose name is specified in the system input file, contains the chemical configuration of the system, including species and reactions. It is noted that the order in which cross-linker, motor, and branches species are defined in the chemistry input file should match the relevant mechanical parameters, which are defined in the system input file. The number of species of each type should also match the SystemFile\u2019s species type numbers, or a startup error will result. All species names given must be unique strings, or a startup error will result. In all species and reaction definitions, FILAMENTTYPE is an integer that specifies the type of filament that this filament species belongs to. For example, if there are two filament types defined, the FILAMENTTYPE parameter could be 0 or 1. An invalid value of this parameter will result in an error. Species Different types of species can be defined as follows: A diffusing species is defined in the following form: \u26a0\ufe0f Breaking change starting MEDYAN v5.1.0, <DIFFCOEFF> means the 3D diffusion coefficient with dimension nm 2 /s. Previously, it meant the diffusion reaction rate between compartments with dimension s -1 , obtained from diffusion coefficient and the size of a cubic compartment. For example, if 500 nm compartments were used and the diffusion reaction rate was \"1.0\", it should be changed to \"0.25E6\". SPECIESDIFFUSING <NAME> <COPYNUMBER> <DIFFCOEFF> <RELEASETIME> <REMOVALTIME> <QUALIFIER> (<NUMEVENTS>) where NAME is any string defining the name of the species, COPYNUMBER is the number of molecules of that species in the system, and DIFFCOEFF is a float value that determines the diffusion coefficient of this molecule in the solution. RELEASETIME specifies when this molecule populates the system in simulation (in seconds). REMOVALTIME specifies whether the species should be removed from the simulation. If no removal is desired, this can be set to 0. The QUALIFIER field is used to define the type of reacting species. The options are the following: REG : A regular reacting species. Copy numbers are updated typically. AVG : An averaging reacting species. The species will use a copy number averaged over a set number of copy number changes ( NUMEVENTS ) for efficiency. The NUMEVENTS field, denoted in parentheses as optional, only used in the case of defining an averaging reacting species. If using a regular, this should not be included in the file or an error will result. A bulk species, which is assumed to be spatially homogeneous, is defined in the following form: SPECIESBULK <NAME> <COPYNUMBER> <RELEASETIME> <REMOVALTIME> <QUALIFIER> where NAME is any string defining the name of the species, COPYNUMBER is the number of molecules of that species in the system, and RELEASETIME specifies when this molecule populates the system in simulation (in seconds). REMOVALTIME specifies whether the species should be removed from the simulation. If no removal is desired, this can be set to 0. The QUALIFIER field is used to define the type of reacting species. The options are the following: REG : A regular reacting species. Copy numbers are updated typically. CONST : An constant reacting species. The species will never change copy number upon reacting. Any filament-related species can be defined in the following form: SPECIES<SPECIESTYPE> <NAME> <FILAMENTTYPE> where SPECIESTYPE can be: FILAMENT : A filamentous species. At least one filament species must be defined if using filaments in simulation. PLUSEND : A plus end species on a filament, which is defined as the front of the filament. There must be at least one plus end species for every filament species defined in the system. MINUSEND : A minus end species on a filament, which is defined as the back of the filament. There must be at least one minus end species for every filament species defined in the system. BOUND : A bound species on a filament. There must be at least one bound species defined for each filament type. LINKER : A cross-linker species. The ordering of cross-linker initializations should match their mechanical parameters, as stated above. MOTOR : A myosin II motor species. The ordering of motor initializations should match their mechanical parameters, as stated above. BRANCHER : A branching species. The ordering of branches initializations should match their mechanical parameters, as stated above. Binding sites For every species that binds to filaments (linkers, motors, branchers), a binding site species must be set. This binding site must be a bound species on any filament type. It is declared in the following form: LINKERBINDINGSITE <NAME> <FILAMENTTYPE> MOTORBINDINGSITE <NAME> <FILAMENTTYPE> BRANCHERBINDINGSITE <NAME> <FILAMENTTYPE> where NAME is the name of a pre-defined bound species on a filament of type FILAMENTTYPE . Reactions Reaction definitions must follow these common rules: Species that are defined in reactions must be previously defined in the chemistry file. For filament-related reactions, most species type and ordering parameters are fixed; if they are fixed, they will be pre-defined in the reaction definition below. If the ordering is not properly followed, a startup error will result. All species declarations in a reaction must be separated by white space, with + markers between reactants and products. A -> must be placed between reactants and products, separated by whitespace. If this syntax is not followed, a startup error will result. The optional string HRCDID and accompanying float DELGZERO specify the identity and the \u2206G_0 value for the reaction, respectively, for use in dissipation tracking. If this feature is turned on, then this field must be supplied, and if it is turned off then this field must be omitted. Currently only some reactions support dissipation tracking, as specified below, and it is only supported when the Next Reaction Method algorithm choice is used. For those reactions which do not support dissipation tracking, the HRCDID and DELGZERO fields should not be set. This allows those reactions to be included in the chemical system while allowing dissipation tracking for supported reactions. Different types of reactions can be defined as follows: A general reaction between any bulk or diffusing species can be defined in the following form: (GENREACTION [<DELGZERO>:<HRCDID>] <NAME>:BULK/DIFFUSING + <NAME>:BULK/DIFFUSING + ... -> <NAME>:BULK/DIFFUSING + <NAME>:BULK/DIFFUSING + ... <RATE>) where any bulk or diffusing species can be included, and RATE is a float value that determines the rate constant of the reaction. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A bulk reaction between bulk species only can be defined in the following form: BULKREACTION <NAME>:BULK + <NAME>:BULK + ... -> <NAME>:BULK + <NAME>:BULK + ... <RATE> where any bulk species can be included. If the reaction only contains bulk species, it must be specified as a bulk reaction. RATE is a float value that determines the rate constant of the reaction. This reaction does not support dissipation tracking, so HRCDID and DELGZERO should not be provided. A polymerization reaction can be defined in the following form: (POLYMERIZATIONREACTION [<DELGZERO>:<HRCDID>] <FILAMENTTYPE> <NAME>:BULK/DIFFUSING + <NAME>:PLUSEND/MINUSEND -> <NAME>:FILAMENT + <NAME>:PLUSEND/MINUSEND <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. It is noted that the first species listed can be either DIFFUSING or BULK , and the reaction can contain a PLUSEND or MINUSEND . This reaction will polymerize the filament, producing a new chemical species on the end of the filament and increasing the length of the filament by a single monomer. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A depolymerization reaction can be defined in the following form: (DEPOLYMERIZATIONREACTION [<DELGZERO>:<HRCDID>] <FILAMENTTYPE> <NAME>:FILAMENT + <NAME>:PLUSEND/MINUSEND -> <NAME>:BULK/DIFFUSING + <NAME>:PLUSEND/MINUSEND <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. It is noted that the third species listed can be either DIFFUSING or BULK , and the reaction can contain a PLUSEND or MINUSEND . This reaction will depolymerize the filament, removing a chemical species from the end of the filament and decreasing the length of the filament by a single monomer. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A cross-linker reaction between two filaments can be defined in the following form: (LINKERREACTION [<DELGZERO>:<HRCDID>] 0 <NAME>:BOUND:1 + <NAME>:BOUND:2 + <NAME>:BULK/DIFFUSING <-> <NAME>:LINKER:1 + <NAME>:LINKER:2 <ONRATE> <OFFRATE> <RMIN> <RMAX>) where NAME is the string name of the species, and ONRATE and OFFRATE are float values that determines the rate constant of the binding and unbinding reactions. RMIN and RMAX are the range of the chemical reaction, and this can be set depending on the structure of the simulated cross-linker. It is noted that the third species listed can be either DIFFUSING or BULK . The bound species listed must be the corresponding cross-linker binding site. This reaction produces cross-linker species at two separate positions on each respective filament which are chemically and mechanically connected. If mechanical force fields are defined for the cross-linkers, a potential will be created between the filaments. The unbinding reaction will remove these species from the filaments, as well as remove any linker potentials that have been created between the filaments. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A motor reaction between two filaments can be defined in the following form: (MOTORREACTION [<DELGZERO>:<HRCDID>] 0 <NAME>:BOUND:1 + <NAME>:BOUND:2 + <NAME>:BULK/DIFFUSING <-> <NAME>:MOTOR:1 + <NAME>:MOTOR:2 <ONRATE> <OFFRATE> <RMIN> <RMAX>) where NAME is the string name of the species, and ONRATE and OFFRATE are float values that determines the rate constant of the binding and unbinding reactions. RMIN and RMAX are the range of the chemical reaction, and this can be set depending on the structure of the simulated motor. It is noted that the third species listed can be either DIFFUSING or BULK . The bound species listed must be the corresponding motor binding site. This binding reaction produces motor species at two separate positions on each respective filament which are chemically and mechanically connected. If mechanical force fields are defined for the motor, a potential will be created between the filaments. The unbinding reaction will remove these species from the filaments, as well as remove any motor potentials that have been created between the filaments. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A motor walking reaction can be defined in the following form: (MOTORWALKINGREACTION [<DELGZERO>:<HRCDID>] <FILAMENTTYPE> <NAME>:MOTOR:N/N+1 + <NAME>:BOUND:N/N+1 -> <NAME>:MOTOR:N/N+1 + <NAME>:BOUND:N/N+1 <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. The choice of N / N+1 will determine whether the motor is stepping forward or backward. A motor movement from N to N+1 is defined as forward movement (towards the plus end of the filament), and the opposite is backward (towards the minus end). These choices for the reactants and products must be self-consistent as well as consistent with the bound species positions chosen in the reaction, or a startup error will result. The bound species listed must be the corresponding motor binding site. This reaction will move a motor head in the given direction. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A branching reaction can be defined in the following form: (BRANCHINGREACTION <FILAMENTTYPE> <NAME>:BULK/DIFFUSING + <NAME>:BULK/DIFFUSING + <NAME>:BOUND <-> <NAME>:BRANCHER + <NAME>:PLUSEND <ONRATE> <OFFRATE> <NUCLEATIONZONE> <NUCLEATIONDIST>) where NAME is the string name of the species, and ONRATE , OFFRATE are float values that determine the rate constants of the reaction. It is noted that the first and second species listed can be either DIFFUSING or BULK . The bound species listed must be the corresponding branching binding site. The NUCLEATIONZONE and NUCLEATIONDIST specify the volume in which a branching reaction can occur. The choices for the zone parameter are the following ALL : A new filament can nucleate anywhere in the simulation volume due to branching. BOUNDARY : A new filament can nucleate a given distance away from a boundary due to branching, specified by the NUCLEATIONDIST from the system boundary. TOPBOUNDARY : Similar to BOUNDARY except only in the top half of the volume (in the z direction). It is noted that NUCLEATIONDIST needs to be specified for all nucleation zones, but it is unused for ALL . This reaction will create a new branching point, as well as a filament with the desired chemical plus end. If mechanical force fields are defined for the branching point, a potential will be created between the parent and child filament. The unbinding reaction will remove the branching point from the filaments, thus freeing the child filament from the parent. It will also remove any branching point potentials that have been created between the filaments. This reaction does not support dissipation tracking, so HRCDID and DELGZERO should not be provided. A nucleation reaction can be defined in the following form: (NUCLEATIONREACTION <FILAMENTTYPE> <NAME>:BULK/DIFFUSING + <NAME>:BULK/DIFFUSING -> <NAME>:PLUSEND + <NAME>:FILAMENT + <NAME>:MINUSEND <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. It is noted that the first and second species listed can be either DIFFUSING or BULK . This reaction will create a new filament with the given chemical plus end, minus end, and filament species. PLEASE REFER TO THE EXAMPLE FILES FOR A COMPLETE NUCLEATION CYCLE. This reaction does not support dissipation tracking, so HRCDID and DELGZERO should not be provided. A destruction reaction can be defined in the following form: (DESTRUCTIONREACTION <FILAMENTTYPE> <NAME>:PLUSEND + <NAME>:MINUSEND -> <NAME>:BULK/DIFFUSING + <NAME>:BULK/DIFFUSING <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. It is noted that the third and fourth species listed can be either DIFFUSING or BULK . This reaction will destroy a filament, removing it from the system. This reaction does not support dissipation tracking, so HRCDID and DELGZERO should not be provided. A filament aging reaction can be defined in the following form: (AGINGREACTION [<DELGZERO>:<HRCDID>] <FILAMENTTYPE> <NAME>:FILAMENT/PLUSEND/MINUSEND -> <NAME>:FILAMENT/PLUSEND/MINUSEND <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. Either of the reactant or product species can be FILAMENT , PLUSEND , or MINUEND , but the product and reactant species must be the same type, or a startup error will result. This reaction will change the chemical species that resides in a filament. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A filament severing reaction can be defined in the following form: SEVERINGREACTION <FILAMENTTYPE> AT <NAME>:FILAMENT <RATE> where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. This reaction will sever the filament at the closest cylinder connection to a given chemical position, producing two child filaments. This reaction does not support dissipation tracking, so HRCDID and DELGZERO should not be provided.","title":"Input files"},{"location":"manual/input-files/#input-files","text":"The system file is a simple text file that defines all parameters of the simulation. The MEDYAN executable must take in a system file as a command line argument. The parameters are defined in a s-expressions: (parameter parameter-value) (parameter-group (property-1 property-1-value) (property-2 property-2-value)) The input files can also be generated using MEDYAN's interactive configuration by running medyan config , which provides limited configuration capabilities. All physical quantities in the input files will use the following base units, unless otherwise specified. name unit time s length nm mass g Some common derived units are displayed below. name unit force pN energy pN\u22c5nm diffusion coefficient nm\u00b2/s","title":"Input files"},{"location":"manual/input-files/#system-input-files","text":"","title":"System input files"},{"location":"manual/input-files/#geometry","text":"The following geometric parameters can be set. All geometry parameters must be set in the system file, or a startup error will result. item type description NX int Number of compartments in X direction. NY int Number of compartments in Y direction. NZ int Number of compartments in Z direction. COMPARTMENTSIZEX double Size of compartment in X direction. COMPARTMENTSIZEY double Size of compartment in Y direction. COMPARTMENTSIZEZ double Size of compartment in Z direction. MONOMERSIZE double Size of monomer for filament growth (nm). CYLINDERSIZE double Size of cylinder in filament (nm). BOUNDARYSHAPE {SPHERICAL, CUBIC, CAPSULE} Boundary shape. BOUNDARYDIAMETER double Diameter for applicable shapes, including SPHERICAL and CAPSULE geometries. The CUBIC BOUNDARYSHAPE creates boundary planes 25nm in from the faces of compartment grid. If movement of boundaries is desired, the following parameters can also be set. If these parameters are not set, the system will assume non-moving boundaries. Currently, moving boundaries are only implemented for the CUBIC boundary shape. item type description BOUNDARYMOVE {NONE, ALL, TOP} Movement of a boundary. ALL specifies that all boundaries will move in the given direction, and top specifies that the top of the boundary in the z direction will move. BMOVESPEED double Speed of boundary movement in nm/s. If a negative value is given, the boundary will move towards the center of the grid. If positive, the boundary will move away from the center of the grid. BMOVESTARTTIME double Time at which the boundary will begin to move. If not specified, the boundary will start moving at the beginning of the simulation. BMOVEENDTIME double Time at which the boundary will stop movement.","title":"Geometry"},{"location":"manual/input-files/#mechanics","text":"The following mechanical parameters can be set. It is noted that the number of parameters for each force field must match the number of species of that type, specified in the system input file. This must be consistent for all simulation elements, including filaments, cross-linkers, motors, branchers, and bubbles. To set multiple parameters corresponding to multiple species, list the parameter values with space in between after the parameter qualifier. If a force field type is left blank, that force field will not be included in the simulation. item type description FSTRETCHINGTYPE {HARMONIC} Filament stretching force field. FSTRETCHINGK double Filament stretching force constant. FBENDINGTYPE {HARMONIC, COSINE} Filament bending force field. FBENDINGK double Filament bending force constant. FBENDINGTHETA double Filament bending angle (radians). LSTRETCHINGTYPE {HARMONIC} Cross-linker stretching force field. LSTRETCHINGK double Cross-linker stretching force constant. MSTRETCHINGTYPE {HARMONIC} Motor stretching force field. MSTRETCHINGK double Motor stretching force constant. BRSTRETCHINGTYPE {HARMONIC} Branching point stretching force field. BRSTRETCHINGK double Branching point stretching force constant. BRBENDINGTYPE {COSINE} Branching point bending force field. BRBENDINGK double Branching point bending force constant. BRBENDINGTHETA double Branching point bending angle (radians). BRDIHEDRALFFTYPE {COSINE} Branching point dihedral force field. BRDIHEDRALK double Branching point stretching force constant. BRPOSITIONTYPE {HARMONIC} Branching point position force field. BRPOSITIONK double Branching point position force constant. VOLUMEFFTYPE {integral, monomer} Volume force type. When monomer-based volume exclusion is used, volume-exclusion-monomer-interval can be specified as well. REPULSION is the old option for integral , but its use is deprecated. VOLUMECUTOFF double Volume interaction cutoff distance (nm). The volume force is only calculated on pairs of cylinders with mid points closer than this distance. This should always be larger than CYLINDERSIZE VOLUMEK double Volume force constant. volume-exclusion-monomer-interval list int Interval of monomer sampling for volume exclusion for each filament type. BOUNDARYFFTYPE {REPULSIONEXP} Boundary force type. BOUNDARYCUTOFF double Boundary interaction cutoff distance. BOUNDARYINTERACTIONK double Boundary force constant. BOUNDARYSCREENLENGTH double Boundary screening length constant. BUBBLEFFTYPE {REPULSIONEXP} Bubble force type. BUBBLECUTOFF double Boundary interaction cutoff distance. BUBBLEINTERACTIONK double Bubble force constant. BUBBLESCREENLENGTH double Bubble screening length constant. BUBBLERADIUS double Bubble radius. NUMBUBBLETYPES int Number of different bubble types. MTOCFFTYPE {ATTACHMENTHARMONIC} MTOC force type. membrane-tension-ff-type {CONSTANT} Membrane tension type. membrane-bending-ff-type {HELFRICH, HELFRICH_QUADRATIC} Membrane bending type. In quadratic mode, the spontaneous curvature is always assumed to be zero. volume-conservation-ff-type {MEMBRANE} Volume conservation type. triangle-bead-volume-ff-type {REPULSION} Triangle bead volume exclusion force type. triangle-bead-volume-k float Triangle bead volume exclusion force constant. triangle-bead-volume-cutoff float Triangle bead volume exclusion cutoff distance. triangle-bead-volume-cutoff-mech float Triangle bead volume exclusion cutoff distance during mechanical minimization. The system mechanical energy is minimized using the minimization algorithm, whose parameters can be specified as follows. item type description CONJUGATEGRADIENT {POLAKRIBIERE, FLETCHERRIEVES, STEEPESTDESCENT} Type of conjugate gradient minimization. GRADIENTTOLERANCE double Gradient tolerance in conjugate gradient (in pN). MAXDISTANCE double Maximum distance beads can be moved in minimization. LAMBDAMAX double Maximum lambda that can be returned in line search. try-to-recover-in-line-search-error {false, true} Defaults to true. If set to false, whenever line search fails to find a lower energy, the program will terminate with a diagnostic message.","title":"Mechanics"},{"location":"manual/input-files/#chemistry","text":"The following chemical parameters can be set. It should be noted that the number of parameters listed for each chemical species type that resides on a filament must match the number of filament types, specified in the system input file. This must be consistent for all filament types. To set multiple parameters corresponding to multiple filaments, list the parameters with space in between after the parameter qualifier. All chemical parameters must be set unless otherwise noted in the description. For the motor parameters, the number of parameters must match the number of motor species in the system. For more information on chemical algorithms, see Popov et al (2016) . An alternate set of parameters can be specified in replacement of RUNTIME for smaller systems in which simulation time is based on explicit reaction steps; if RUNTIME is not initialized or set to zero, the parameter RUNSTEPS and its associated chemical step-based parameter set will be used if provided. item type description CHEMISTRYFILE string Input chemistry file. Should be in the input directory. CALGORITHM {GILLESPIE, NRM} Chemistry algorithm used. RUNSTEPS int Number of total chemical steps. If RUNTIME is set, will not be used. RUNTIME double Total runtime of simulation. SNAPSHOTSTEPS int Number of steps per snapshot. If SNAPSHOTTIME is set, will not be used. SNAPSHOTTIME double Time of each snapshot. MINIMIZATIONSTEPS int Number of chemical steps per mechanical equilibration. If MINIMIZATIONTIME is set, will not be used. MINIMIZATIONTIME double Time between each mechanical equilibration. NEIGHBORLISTSTEPS int Number of chemical steps per neighbor list update. This includes updating chemical reactions as well as force fields which rely on neighbor lists. If NEIGHBORLISTTIME is set, will not be used. NEIGHBORLISTTIME double Time between each neighbor list update. INITIALSLOWDOWNTIME double Length of time at the beginning of the simulation to run mechanical equilibrations and neighbor list updates 10x more frequently. Disabled by default. NUMFILAMENTTYPES int Number of different filament types. NUMBINDINGSITES int Number of binding sites per cylinder for each filament type defined. This will set binding sites for cross-linkers, motors, and other binding molecules. NUMMOTORHEADSMIN int Minimum number of motor heads per motor species defined. NUMMOTORHEADSMAX int Maximum number of motor heads per motor species defined. MOTORSTEPSIZE double Single motor head step size. DISSIPATIONTRACKING {OFF, ON} Whether to switch on the dissipation tracking feature. LINKERBINDINGSKIP int Switches on the different binding tracking feature to allow motors to have more binding spots per cylinder than linkers. The specified integer is the number of binding sites that the cross-linkers will skip before accepting a possible binding site. allow-same-filament-pair-binding bool Whether pairwise bindings on the same filament is allowed. Even if this is turned off, pairwise bindings will not happen on same or neighboring cylinders. EVENTTRACKING {OFF, ON} Whether to switch on the event tracking feature.","title":"Chemistry"},{"location":"manual/input-files/#dynamic-rates","text":"The following dynamic rate forms and parameters can be set. These parameters are characteristic lengths and amplitudes of the rate changing equations outlined in Popov et al (2016) . These can be tuned to mimic the stall and unbinding mechanochemical coupling of cross-linkers and myosin II motors. Note that if dynamic rates are enabled, the number of dynamic rate forms for each type of reaction must match the number of species of that type specified in the system input file, i.e. the number of forms for cross-linker unbinding must match the number of cross-linker species, etc. The number of parameters specified for each type of dynamic rate form must match the number of parameters required for those forms. See below for details, and see Popov et al (2016) for more information on the explicit forms. Parameters must be listed in order of the form that they correspond to, also corresponding to the species that they represent. item type description DFPOLYMERIZATIONTYPE {BROWRATCHET} Filament polymerization dynamic rate form. DFPOLYMERIZATIONLEN double Characteristic length for filament polymerization dynamic rate form. DLUNBINDINGTYPE {CATCHSLIP, SLIP} Cross-linker unbinding dynamic rate form. If CATCHSLIP , two parameters for DLUNBINDINGLEN and DLUNBINDINGAMP are needed to define the functional form. If SLIP , one DLUNBIDINGLEN is needed to define the functional form. DLUNBINDINGLEN double Characteristic length of cross-linker unbinding dynamic rate form. DLUNBINDINGAMP double Amplitude of cross-linker unbinding dynamic rate form. DMUNBINDINGTYPE {LOWDUTYCATCHSLIP, LOWDUTYSLIP} Myosin II unbinding dynamic rate form. If LOWDUTYCATCHSLIP , two parameters for DMUNBINDINGFORCE are needed to define the functional form. If LOWDUTYSLIP , one DMUNBIDINGFORCE is needed to define the functional form. DMUNBINDINGFORCE double Characteristic force of myosin II unbinding dynamic rate form. DMWALKINGTYPE {LOWDUTYSTALL} Myosin II walking dynamic rate form.","title":"Dynamic rates"},{"location":"manual/input-files/#membrane-profile-and-initialization","text":"A membrane profile can be defined using the following syntax: (membrane <profile-name> (<property> <value>) ...) where membrane properties include the following parameters. item type description vertex-system {material, general} In material vertex system, each vertex represents a patch of membrane with a fixed number of lipid molecules. In general vertex system, a vertex simply represents a point on the membrane surface. area-k float Area elasticity of membrane. Unit pN/nm. bending-k float Bending elasticity of membrane. Unit pN\u22c5nm. eq-curv float Spontaneous curvature of membrane. Unit 1/nm. tension float Membrane tension. Unit pN/nm. volume-k float Volume conservation force constant of a enclosing membrane. Unit pN/nm\u00b2. Membrane can be initialized with a specified membrane profile, using the following properties: (init-membrane <profile-name> (<property> <value>) ...) If the membrane profile name was not defined in the input file, a startup error will occur. The membrane initialization properties are defined using the following parameters. mesh : A list describing the initial membrane shape. Currently supporting the following shapes: An ellipsoid whose principal axes are parallel with the x, y, and z axes. Usage: ELLIPSOID center-x center-y center-z radius-x radius-y radius-z . A plane specified by a point and a normal vector. A bounding box is also needed to specify the sampling range. Usage: PLANE center_xyz... normal_xyz... box_origin_xyz... box_size_xyz... . eq-area-factor : A floating point value, such that the equilibrium area is the initial area multiplied by this factor.","title":"Membrane profile and initialization"},{"location":"manual/input-files/#starting-filament-configuration","text":"These parameters define the initial configuration and length of filaments in the system. It is noted that at least one filament, plus end, and minus end chemical species must be initialized in the chemistry input file, or a startup error will result. item type description FILAMENTFILE string Name of filament initialization file. This is not required. NUMFILAMENTS int Number of random filaments to initialize. These filaments will be randomly distributed in the system volume. FILAMENTLENGTH int Number of cylinders per filament to initialize, defining the initial length of the filaments. FILAMENTTYTPE int Filament type to initialize. PROJECTIONTYPE {STRAIGHT, ZIGZAG, ARC, PREDEFINED} Specifies how the beads are sampled between two ends of a filament. Projection type meaning for a filament specified by a set of 3D Cartesian coordinates [v0, v1, v2 ...] , and the number of beads. STRAIGHT - Creates a filament with minus end at v0 , and extends number-of-bead full-size cylinders in v0 -> v1 direction. v2, v3 ... are ignored. ZIGZAG - Creates a filament with minus end at v0 , and extends number-of-bead full-size cylinders in (1) v0 -> v1 direction (2) another different direction alternatively. v2, v3 ... are ignored. ARC - Not sure. (TODO: NEED DOCS) PREDEFINED - Creates a filament with bead coordinates [v0, v1, v2 ...] . WARNING: Each cylinder in the filament is treated as a full-sized cylinder, no matter what the initial bead coordinates are. That means each cylinder in the filament can be compressed or stretched initially.","title":"Starting filament configuration"},{"location":"manual/input-files/#starting-bubble-configuration","text":"The following bubble initialization parameters can be set. These parameters define the initial configuration of bubbles in the system, similar to the filament configuration parameters. It is noted that at least one type of bubble must be set, or a startup error will result. item type description BUBBLEFILE string Name of bubble initialization file. This is not required. NUMBUBBLES int Number of random filaments to initialize. These filaments will be randomly distributed in the system volume. BUBBLETYTPE int Bubble type to initialize. The following syntax is used to initialize a Microtubule Organizing Center (MTOC), or a bead for Atomic Force Microscopy (AFM), which are both implemented as a bubble with extra parameters. (init-mtoc (<property> <value>...) ...) (init-afm (<property> <value>...) ...) where most properties are shared by both MTOC and AFM. The properties are listed below. item type description bubble-type int Type of bubble to initialize. bubble-coord list float Coordinates of the bubble center. bubble-fixed {false, true} If the bubble is fixed, it's coordinates will not change during energy minimization. filament-type int Type of filament attachment. num-filaments int Number of filaments to attach to the bubble. num-cylinders-per-filament int Number of cylinders per filament to attach to the bubble. theta1, theta2, phi1, phi2 float Restricts the initial orientation of the filaments under certain transformations (read source code to see the details). Default to (0, 1, 0, 1), which allows all possible orientations. attachment-stretching-k float Stretching force constant for filament attachments.","title":"Starting bubble configuration"},{"location":"manual/input-files/#special-protocols","text":"The following special protocols can be initialized. These protocols must be set on different lines, so users should specify a new parameter, on separate lines, for each setup desired. (SPECIALPROTOCOL <name> <parameters>...) name parameters description PINBOUNDARYFILAMENTS <pinK> <pinDistance> <pinTime> Tether minus and plus ends that are within pinDistance (nm) from the boundary after pinTime (s). This will result in additional forces on the actin network form the boundary. PINLOWERBOUNDARYFILAMENTS <pinK> <pinTime> <pinFraction> Tether minus and plus ends that are within pinDistance (nm) from the lower boundary after pinTime (s). pinDistance has a default value (250 as of v5.1.0), but can be overwritten by other pinning protocols. pin-initial-filament-below-z <pinK> <pinZ> Pin all initial beads with z coordinate lower than pinZ (nm). MAKEFILAMENTSSTATIC, MAKELINKERSSTATIC <time> Make either filament or cross-linker chemistry static after a certain amount of time . RATEDEPEND <time> <force> Starting at time , increase plus end polymerization rate for actin filaments under larger tension than force (pN). AFM <step1> <step2> <iter-change> <step-total> <step-time> AFM protocol. scale-membrane-eq-area <rate> <min-eq-area> For all membranes without lipid reservoir, increase its equilibrium area with rate (nm^2/s). Each equilibrium area cannot drop below min-eq-area (nm^2). scale-membrane-eq-volume <rate> <min-eq-volume> For all closed membranes, increase its equilibrium volume with rate (nm^3/s). Each equilibrium volume cannot drop below min-eq-volume (nm^3).","title":"Special protocols"},{"location":"manual/input-files/#chemistry-input-files","text":"The chemistry input file, whose name is specified in the system input file, contains the chemical configuration of the system, including species and reactions. It is noted that the order in which cross-linker, motor, and branches species are defined in the chemistry input file should match the relevant mechanical parameters, which are defined in the system input file. The number of species of each type should also match the SystemFile\u2019s species type numbers, or a startup error will result. All species names given must be unique strings, or a startup error will result. In all species and reaction definitions, FILAMENTTYPE is an integer that specifies the type of filament that this filament species belongs to. For example, if there are two filament types defined, the FILAMENTTYPE parameter could be 0 or 1. An invalid value of this parameter will result in an error.","title":"Chemistry input files"},{"location":"manual/input-files/#species","text":"Different types of species can be defined as follows: A diffusing species is defined in the following form: \u26a0\ufe0f Breaking change starting MEDYAN v5.1.0, <DIFFCOEFF> means the 3D diffusion coefficient with dimension nm 2 /s. Previously, it meant the diffusion reaction rate between compartments with dimension s -1 , obtained from diffusion coefficient and the size of a cubic compartment. For example, if 500 nm compartments were used and the diffusion reaction rate was \"1.0\", it should be changed to \"0.25E6\". SPECIESDIFFUSING <NAME> <COPYNUMBER> <DIFFCOEFF> <RELEASETIME> <REMOVALTIME> <QUALIFIER> (<NUMEVENTS>) where NAME is any string defining the name of the species, COPYNUMBER is the number of molecules of that species in the system, and DIFFCOEFF is a float value that determines the diffusion coefficient of this molecule in the solution. RELEASETIME specifies when this molecule populates the system in simulation (in seconds). REMOVALTIME specifies whether the species should be removed from the simulation. If no removal is desired, this can be set to 0. The QUALIFIER field is used to define the type of reacting species. The options are the following: REG : A regular reacting species. Copy numbers are updated typically. AVG : An averaging reacting species. The species will use a copy number averaged over a set number of copy number changes ( NUMEVENTS ) for efficiency. The NUMEVENTS field, denoted in parentheses as optional, only used in the case of defining an averaging reacting species. If using a regular, this should not be included in the file or an error will result. A bulk species, which is assumed to be spatially homogeneous, is defined in the following form: SPECIESBULK <NAME> <COPYNUMBER> <RELEASETIME> <REMOVALTIME> <QUALIFIER> where NAME is any string defining the name of the species, COPYNUMBER is the number of molecules of that species in the system, and RELEASETIME specifies when this molecule populates the system in simulation (in seconds). REMOVALTIME specifies whether the species should be removed from the simulation. If no removal is desired, this can be set to 0. The QUALIFIER field is used to define the type of reacting species. The options are the following: REG : A regular reacting species. Copy numbers are updated typically. CONST : An constant reacting species. The species will never change copy number upon reacting. Any filament-related species can be defined in the following form: SPECIES<SPECIESTYPE> <NAME> <FILAMENTTYPE> where SPECIESTYPE can be: FILAMENT : A filamentous species. At least one filament species must be defined if using filaments in simulation. PLUSEND : A plus end species on a filament, which is defined as the front of the filament. There must be at least one plus end species for every filament species defined in the system. MINUSEND : A minus end species on a filament, which is defined as the back of the filament. There must be at least one minus end species for every filament species defined in the system. BOUND : A bound species on a filament. There must be at least one bound species defined for each filament type. LINKER : A cross-linker species. The ordering of cross-linker initializations should match their mechanical parameters, as stated above. MOTOR : A myosin II motor species. The ordering of motor initializations should match their mechanical parameters, as stated above. BRANCHER : A branching species. The ordering of branches initializations should match their mechanical parameters, as stated above.","title":"Species"},{"location":"manual/input-files/#binding-sites","text":"For every species that binds to filaments (linkers, motors, branchers), a binding site species must be set. This binding site must be a bound species on any filament type. It is declared in the following form: LINKERBINDINGSITE <NAME> <FILAMENTTYPE> MOTORBINDINGSITE <NAME> <FILAMENTTYPE> BRANCHERBINDINGSITE <NAME> <FILAMENTTYPE> where NAME is the name of a pre-defined bound species on a filament of type FILAMENTTYPE .","title":"Binding sites"},{"location":"manual/input-files/#reactions","text":"Reaction definitions must follow these common rules: Species that are defined in reactions must be previously defined in the chemistry file. For filament-related reactions, most species type and ordering parameters are fixed; if they are fixed, they will be pre-defined in the reaction definition below. If the ordering is not properly followed, a startup error will result. All species declarations in a reaction must be separated by white space, with + markers between reactants and products. A -> must be placed between reactants and products, separated by whitespace. If this syntax is not followed, a startup error will result. The optional string HRCDID and accompanying float DELGZERO specify the identity and the \u2206G_0 value for the reaction, respectively, for use in dissipation tracking. If this feature is turned on, then this field must be supplied, and if it is turned off then this field must be omitted. Currently only some reactions support dissipation tracking, as specified below, and it is only supported when the Next Reaction Method algorithm choice is used. For those reactions which do not support dissipation tracking, the HRCDID and DELGZERO fields should not be set. This allows those reactions to be included in the chemical system while allowing dissipation tracking for supported reactions. Different types of reactions can be defined as follows: A general reaction between any bulk or diffusing species can be defined in the following form: (GENREACTION [<DELGZERO>:<HRCDID>] <NAME>:BULK/DIFFUSING + <NAME>:BULK/DIFFUSING + ... -> <NAME>:BULK/DIFFUSING + <NAME>:BULK/DIFFUSING + ... <RATE>) where any bulk or diffusing species can be included, and RATE is a float value that determines the rate constant of the reaction. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A bulk reaction between bulk species only can be defined in the following form: BULKREACTION <NAME>:BULK + <NAME>:BULK + ... -> <NAME>:BULK + <NAME>:BULK + ... <RATE> where any bulk species can be included. If the reaction only contains bulk species, it must be specified as a bulk reaction. RATE is a float value that determines the rate constant of the reaction. This reaction does not support dissipation tracking, so HRCDID and DELGZERO should not be provided. A polymerization reaction can be defined in the following form: (POLYMERIZATIONREACTION [<DELGZERO>:<HRCDID>] <FILAMENTTYPE> <NAME>:BULK/DIFFUSING + <NAME>:PLUSEND/MINUSEND -> <NAME>:FILAMENT + <NAME>:PLUSEND/MINUSEND <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. It is noted that the first species listed can be either DIFFUSING or BULK , and the reaction can contain a PLUSEND or MINUSEND . This reaction will polymerize the filament, producing a new chemical species on the end of the filament and increasing the length of the filament by a single monomer. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A depolymerization reaction can be defined in the following form: (DEPOLYMERIZATIONREACTION [<DELGZERO>:<HRCDID>] <FILAMENTTYPE> <NAME>:FILAMENT + <NAME>:PLUSEND/MINUSEND -> <NAME>:BULK/DIFFUSING + <NAME>:PLUSEND/MINUSEND <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. It is noted that the third species listed can be either DIFFUSING or BULK , and the reaction can contain a PLUSEND or MINUSEND . This reaction will depolymerize the filament, removing a chemical species from the end of the filament and decreasing the length of the filament by a single monomer. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A cross-linker reaction between two filaments can be defined in the following form: (LINKERREACTION [<DELGZERO>:<HRCDID>] 0 <NAME>:BOUND:1 + <NAME>:BOUND:2 + <NAME>:BULK/DIFFUSING <-> <NAME>:LINKER:1 + <NAME>:LINKER:2 <ONRATE> <OFFRATE> <RMIN> <RMAX>) where NAME is the string name of the species, and ONRATE and OFFRATE are float values that determines the rate constant of the binding and unbinding reactions. RMIN and RMAX are the range of the chemical reaction, and this can be set depending on the structure of the simulated cross-linker. It is noted that the third species listed can be either DIFFUSING or BULK . The bound species listed must be the corresponding cross-linker binding site. This reaction produces cross-linker species at two separate positions on each respective filament which are chemically and mechanically connected. If mechanical force fields are defined for the cross-linkers, a potential will be created between the filaments. The unbinding reaction will remove these species from the filaments, as well as remove any linker potentials that have been created between the filaments. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A motor reaction between two filaments can be defined in the following form: (MOTORREACTION [<DELGZERO>:<HRCDID>] 0 <NAME>:BOUND:1 + <NAME>:BOUND:2 + <NAME>:BULK/DIFFUSING <-> <NAME>:MOTOR:1 + <NAME>:MOTOR:2 <ONRATE> <OFFRATE> <RMIN> <RMAX>) where NAME is the string name of the species, and ONRATE and OFFRATE are float values that determines the rate constant of the binding and unbinding reactions. RMIN and RMAX are the range of the chemical reaction, and this can be set depending on the structure of the simulated motor. It is noted that the third species listed can be either DIFFUSING or BULK . The bound species listed must be the corresponding motor binding site. This binding reaction produces motor species at two separate positions on each respective filament which are chemically and mechanically connected. If mechanical force fields are defined for the motor, a potential will be created between the filaments. The unbinding reaction will remove these species from the filaments, as well as remove any motor potentials that have been created between the filaments. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A motor walking reaction can be defined in the following form: (MOTORWALKINGREACTION [<DELGZERO>:<HRCDID>] <FILAMENTTYPE> <NAME>:MOTOR:N/N+1 + <NAME>:BOUND:N/N+1 -> <NAME>:MOTOR:N/N+1 + <NAME>:BOUND:N/N+1 <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. The choice of N / N+1 will determine whether the motor is stepping forward or backward. A motor movement from N to N+1 is defined as forward movement (towards the plus end of the filament), and the opposite is backward (towards the minus end). These choices for the reactants and products must be self-consistent as well as consistent with the bound species positions chosen in the reaction, or a startup error will result. The bound species listed must be the corresponding motor binding site. This reaction will move a motor head in the given direction. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A branching reaction can be defined in the following form: (BRANCHINGREACTION <FILAMENTTYPE> <NAME>:BULK/DIFFUSING + <NAME>:BULK/DIFFUSING + <NAME>:BOUND <-> <NAME>:BRANCHER + <NAME>:PLUSEND <ONRATE> <OFFRATE> <NUCLEATIONZONE> <NUCLEATIONDIST>) where NAME is the string name of the species, and ONRATE , OFFRATE are float values that determine the rate constants of the reaction. It is noted that the first and second species listed can be either DIFFUSING or BULK . The bound species listed must be the corresponding branching binding site. The NUCLEATIONZONE and NUCLEATIONDIST specify the volume in which a branching reaction can occur. The choices for the zone parameter are the following ALL : A new filament can nucleate anywhere in the simulation volume due to branching. BOUNDARY : A new filament can nucleate a given distance away from a boundary due to branching, specified by the NUCLEATIONDIST from the system boundary. TOPBOUNDARY : Similar to BOUNDARY except only in the top half of the volume (in the z direction). It is noted that NUCLEATIONDIST needs to be specified for all nucleation zones, but it is unused for ALL . This reaction will create a new branching point, as well as a filament with the desired chemical plus end. If mechanical force fields are defined for the branching point, a potential will be created between the parent and child filament. The unbinding reaction will remove the branching point from the filaments, thus freeing the child filament from the parent. It will also remove any branching point potentials that have been created between the filaments. This reaction does not support dissipation tracking, so HRCDID and DELGZERO should not be provided. A nucleation reaction can be defined in the following form: (NUCLEATIONREACTION <FILAMENTTYPE> <NAME>:BULK/DIFFUSING + <NAME>:BULK/DIFFUSING -> <NAME>:PLUSEND + <NAME>:FILAMENT + <NAME>:MINUSEND <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. It is noted that the first and second species listed can be either DIFFUSING or BULK . This reaction will create a new filament with the given chemical plus end, minus end, and filament species. PLEASE REFER TO THE EXAMPLE FILES FOR A COMPLETE NUCLEATION CYCLE. This reaction does not support dissipation tracking, so HRCDID and DELGZERO should not be provided. A destruction reaction can be defined in the following form: (DESTRUCTIONREACTION <FILAMENTTYPE> <NAME>:PLUSEND + <NAME>:MINUSEND -> <NAME>:BULK/DIFFUSING + <NAME>:BULK/DIFFUSING <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. It is noted that the third and fourth species listed can be either DIFFUSING or BULK . This reaction will destroy a filament, removing it from the system. This reaction does not support dissipation tracking, so HRCDID and DELGZERO should not be provided. A filament aging reaction can be defined in the following form: (AGINGREACTION [<DELGZERO>:<HRCDID>] <FILAMENTTYPE> <NAME>:FILAMENT/PLUSEND/MINUSEND -> <NAME>:FILAMENT/PLUSEND/MINUSEND <RATE>) where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. Either of the reactant or product species can be FILAMENT , PLUSEND , or MINUEND , but the product and reactant species must be the same type, or a startup error will result. This reaction will change the chemical species that resides in a filament. This reaction supports dissipation tracking, so if the feature is turned on, then HRCDID should be set to a user specified short unique string, and DELGZERO should be set to a float value based on the user\u2019s parameterization of the chemical energetics. A filament severing reaction can be defined in the following form: SEVERINGREACTION <FILAMENTTYPE> AT <NAME>:FILAMENT <RATE> where NAME is the string name of the species, and RATE is a float value that determines the rate constant of the reaction. This reaction will sever the filament at the closest cylinder connection to a given chemical position, producing two child filaments. This reaction does not support dissipation tracking, so HRCDID and DELGZERO should not be provided.","title":"Reactions"},{"location":"manual/installation/","text":"Building MEDYAN To use MEDYAN, one needs to build it from the source code. The source code is available for download at http://medyan.org/download.html . One can also clone the git repository for the latest version. Requirements A C++17 compatible compiler such as the following is required: gcc >= 7 clang >= 5 MSVC with Visual Studio 2017 15.7 and above The following tools are also required: CMake >= 3.13 git >= 2.7.0 medyan is also dependent on several external libraries, which will be automatically installed before building. Steps The preferred way of building medyan is to generate the build files using CMake. From the MEDYAN root directory, use either of the following scripts to generate build files. conf.sh on Linux and MacOS. It will generate Makefile in the build directory by default. conf.ps1 on Windows. It will generate the Visual Project solution in the build directory by default. Under the hood, the scripts use vcpkg to install and configure the required external libraries, and use cmake to generate the build files. The external library installation normally happens only for the first build. External variables can be used to control some of the behaviors of the script. Setting MEDYAN_NO_GUI=\"true\" disables installing GUI libraries and building the GUI. Setting MEDYAN_CMAKE_EXTRA_ARGS passes those arguments to the cmake command; for example, setting MEDYAN_CMAKE_EXTRA_ARGS=\"-DCMAKE_BUILD_TYPE=Debug\" will build for debug. On MacOS, one can also change the target build system of the CMake from make to Xcode project, by setting MEDYAN_BUILD_TOOL to be \"Xcode\" . Example 1 : I am building medyan on Linux, and I do not have boost installed anywhere. > ./conf.sh > cd build > make And the medyan would be built in the build directory. Example 2 : I want to build medyan on my Mac using Xcode. > MEDYAN_BUILD_TOOL=\"Xcode\" ./conf.sh And an Xcode project file would be in the build directory. Example 3 : I want to build medyan on Windows. > .\\conf.ps1 And a Visual Studio solution file named medyan.sln would be in the build directory.","title":"Installation"},{"location":"manual/installation/#building-medyan","text":"To use MEDYAN, one needs to build it from the source code. The source code is available for download at http://medyan.org/download.html . One can also clone the git repository for the latest version.","title":"Building MEDYAN"},{"location":"manual/installation/#requirements","text":"A C++17 compatible compiler such as the following is required: gcc >= 7 clang >= 5 MSVC with Visual Studio 2017 15.7 and above The following tools are also required: CMake >= 3.13 git >= 2.7.0 medyan is also dependent on several external libraries, which will be automatically installed before building.","title":"Requirements"},{"location":"manual/installation/#steps","text":"The preferred way of building medyan is to generate the build files using CMake. From the MEDYAN root directory, use either of the following scripts to generate build files. conf.sh on Linux and MacOS. It will generate Makefile in the build directory by default. conf.ps1 on Windows. It will generate the Visual Project solution in the build directory by default. Under the hood, the scripts use vcpkg to install and configure the required external libraries, and use cmake to generate the build files. The external library installation normally happens only for the first build. External variables can be used to control some of the behaviors of the script. Setting MEDYAN_NO_GUI=\"true\" disables installing GUI libraries and building the GUI. Setting MEDYAN_CMAKE_EXTRA_ARGS passes those arguments to the cmake command; for example, setting MEDYAN_CMAKE_EXTRA_ARGS=\"-DCMAKE_BUILD_TYPE=Debug\" will build for debug. On MacOS, one can also change the target build system of the CMake from make to Xcode project, by setting MEDYAN_BUILD_TOOL to be \"Xcode\" . Example 1 : I am building medyan on Linux, and I do not have boost installed anywhere. > ./conf.sh > cd build > make And the medyan would be built in the build directory. Example 2 : I want to build medyan on my Mac using Xcode. > MEDYAN_BUILD_TOOL=\"Xcode\" ./conf.sh And an Xcode project file would be in the build directory. Example 3 : I want to build medyan on Windows. > .\\conf.ps1 And a Visual Studio solution file named medyan.sln would be in the build directory.","title":"Steps"},{"location":"manual/output-files/","text":"Output files MEDYAN can produce a number of output types, set in the SystemFile , produced at a snapshot frequency also defined in the SystemFile . These output files will be placed in the OutputDirectory specified at runtime. The output types are described below. snapshot.traj \u26a0\ufe0f Breaking change Starting MEDYAN v5.1.0, brancher output is similar to other linkers, where two 3D coordinates (on mother/daughter filament, respectively) are recorded. Previously, only the starting coordinates (on the mother filament) were recorded. The snapshot file gives the basic trajectory information of the system. It includes a brief description for all filaments, cross-linkers, motors, and branching points in the system, as well as information on the current chemical step. It is produced with the following form: chemstepnumber time numfilaments numlinkers nummotors numbranchers FILAMENT filamentid filamenttype filamentcyllength deltal deltar beadcoord1x beadcoord1y beadcoord1z beadcoord2x beadcoord2y beadcoord2z ... ... LINKER linkerid linkertype startcoordx startcoordy startcoordz endcoordx endcoordy endcoordz ... MOTOR motorid motortype startcoordx startcoordy startcoordz endcoordx endcoordy endcoordz ... BRANCHER brancherid branchertype startcoordx startcoordy startcoordz endcoordx endcoordy endcoordz plusend.traj The plusend file gives the plus end coordinates and types information. The plus end coordinates should be the same as the last bead coordinates in the snapshot.traj for each filament. The plus end type is recorded as 0, 1, 2, etc. that follows the same order as the SPECIESPLUSEND in chemistry input files. It is produced with the following form: chemstepnumber time numfilaments numlinkers nummotors numbranchers F filamentid filamenttype filamentcyllength deltal deltar plusendcoordx plusendcoordx plusendcoordx PLUSEND: type forces.traj, stresses.traj, and birthtimes.traj The forces file gives the forces on each element in the system, in similar form to the snapshot file. It is produced with the following format: chemstepnumber time numfilaments numlinkers nummotors numbranchers F filamentid filamenttype filamentcyllength deltal deltar bead1property bead2property ... ... L linkerid linkertype linkerproperty ... M motorid motortype motorproperty ... B brancherid branchertype *no property printed for branching points* ... where the properties are as follows: - forces.traj : the magnitude forces on each cylinder, as well as the magnitude of stretching force on each cross-linker and motor are printed. - stresses.traj : the stretching stress on cylinders, cross-linkers, and motors are printed. - birthtimes.traj : the birth time of on cylinders, cross-linkers, and motors are printed. chemistry.traj The chemistry trajectory file gives the copy numbers of all species in the system, along with the current chemical step and time. It is produced with the following form: chemstepnumber time SPECIESNAME COPYNUMBER where SPECIESNAME represents the name of the system species and COPYNUMBER is the current copy number of that species at the given timestep. concentration.traj The concentration trajectory file gives the center point coordinates of compartments and the copy numbers of all diffusing species in the compartment. It is produced with the following form: chemstepnumber time COMPARTMENT: coordx coordy coordz SPECIESNAME COPYNUMBER monomers.traj The monomers trajectory files gives the number of reactions occurred since last snapshot. DeltaMinusEnd and DeltaPlusEnd shows the number of cylinder is created and destructed. (Dd)Poly refers to (de)polymerization. IfNucleation = 1 suggests that this filament is nucleated by nucleation reaction during this period. It is produced with the following form: chemstepnumber time numfilaments numlinkers nummotors numbranchers F filamentid filamenttype filamentcyllength DeltaMinusEnd DeltaPlusEnd DeltaMinusEnd DeltaPlusEnd PolyMinusEnd PolyPlusEnd DepolyMinusEnd DepolyPlusEnd IfNucleation TotalNumMonomers dissipation.traj The dissipation file gives the cumulative changes in the Gibbs free energy of the system resulting from chemical reactions and mechanical rearrangements. The difference between the values at consecutive times will approximate the dissipation rates. The distinction between chemdiss and chemenergy and between mechdiss and mechenergy is explained in accompanying material. The format of the output file is: chemstepnumber time total chemdiss mechdiss chemenergy mechenergy HRCD.traj The high resolution chemical dissipation file gives the cumulative changes in the Gibbs free energy of the system resulting from chemical reactions, with the contributions from each reaction specified separately. The order of the reactions is preserved from time step to time step and is set by the order of their first occurrence in the trajectory. For the change in Gibbs free energy resulting from diffusion of a diffusing species, the HRCDDID is given as DIF_SPECIESNAME . For the change in Gibbs free energy resulting from the unbinding of linkers or motors, the HRCDDID is given as HRCDIDoff , where HRCDID is that of the corresponding binding reaction. The format of the output file is: chemstepnumber time HRCDID1 HRCDID2 ... chemenergy1 chemenergy2 ... Here the chemenergy fields are cumulative changes in Gibbs free energy owing to this reaction. HRMD.traj The high resolution mechanical dissipation file gives the cumulative values of \u2206G mech and \u2206G mech, diss , with contributions from each force field specified separately. The format of the output file is: chemstepnumber time ForceField1 ForceField2 ... mechenergy1 mechenergy2 ... mechdiss1 mechdiss2 ... Here the mechenergy1 fields are cumulative net changes in mechanical energy owing to force field 1, and the mechdiss1 are cumulative changes in mechanical energy during energy minimization owing to force field 1. The difference between these two quantities is explained in accompanying material. Summing across the rows of the mechenergy and mechdiss lines will give the corresponding values found at that time point in the dissipation.traj file. When parsing this file, note that the Excluded Volume force field consists of two words whereas the other force fields (e.g. Bubble ) consist of only one word. CMGraph.traj The connectivity-based mapping output gives information which can be used to construct a weighted graph, in which filaments are nodes and the weighted edges between them represent the number of cross-linkers connecting them. The format of the output file is: chemstepnumber time filid1a filid1b numlinks1 filid2a fildid2b numlinks2 ... Here the filida and filidb fields are the filament identification numbers, indicating that this pair of filaments is connected by numlinks cross-linkers. motorwalkingevents.traj, linkerbindingevents.traj, linkerunbindingevents.traj These output files will be generated if the event tracking feature is turned on. They give detailed information on the spatiotemporal occurrences of motor walking, and cross-linker binding and unbinding. The format for these output files is: event_t event_x event_y event_z traj.h5 All desired system information should be stored in the traj.h5 file. The file has the following structure. Some items are documented inline. \ud83d\uddc2\ufe0f HDF5.File: traj.h5 \u251c\u2500 \ud83d\udcc2 header <- contains information about the simulation \u2502 \u251c\u2500 \ud83c\udff7\ufe0f version <- version of medyan generating this file \u2502 \u251c\u2500 \ud83d\udd22 count <- number of snapshot frames \u2502 \u251c\u2500 \ud83d\udd22 finished <- whether the simulation finished successfully \u2502 \u2514\u2500 \ud83d\udcc2 meta \u2502 \u251c\u2500 \ud83d\udd22 chem <- reconstituded chemistry input file \u2502 \u251c\u2500 \ud83d\udd22 diffusingSpeciesNames \u2502 \u251c\u2500 \ud83d\udd22 energyNames \u2502 \u251c\u2500 \ud83d\udd22 globalFilamentModel \u2502 \u251c\u2500 \ud83d\udd22 globalSpeciesNames <- names of species reported in each snapshot \u2502 \u251c\u2500 \ud83d\udd22 system <- reconstituted system input file \u2502 \u251c\u2500 \ud83d\udd22 vertexColumnNamesFloat64 \u2502 \u2514\u2500 \ud83d\udd22 vertexColumnNamesInt64 \u2514\u2500 \ud83d\udcc2 snapshots <- all snapshot data \u251c\u2500 \ud83d\udcc2 0 <- snapshot id starting from 0 \u2502 \u251c\u2500 \ud83d\udcc2 bubbles \u2502 \u2502 \u251c\u2500 \ud83d\udcc2 0 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 coords \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 id \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 radius \u2502 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 type \u2502 \u2502 \u2514\u2500 \ud83d\udd22 count <- number of bubbles \u2502 \u251c\u2500 \ud83d\udcc2 filaments \u2502 \u2502 \u251c\u2500 \ud83d\udcc2 0 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 beadCoords <- 3 x NUM_BEADS matrix \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 monomerIds <- 3 x (NUM_BEADS-1) matrix of Int32 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 extraCoords <- All coordinates to determine shape of filament \u2502 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 monomerStates <- 1 x NUM_MONOMERS matrix of UInt8 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 count <- number of filaments \u2502 \u251c\u2500 \ud83d\udcc2 linkers \u2502 \u2502 \u251c\u2500 \ud83d\udcc2 0 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 coords \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 id \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 subtype <- integer subtype of linker \u2502 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 type <- string of \"linker\", \"motor\" or \"brancher\" \u2502 \u2502 \u2514\u2500 \ud83d\udd22 count <- number of linkers \u2502 \u251c\u2500 \ud83d\udcc2 membranes \u2502 \u2502 \u251c\u2500 \ud83d\udcc2 0 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 numBorders \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 numTriangles \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 numVertices \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 packedBorderVertices <- read \"struct OutputStructMembrane\" in OutputStruct.hpp for details \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 triangleDataInt64 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 type \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 vertexDataFloat64 \u2502 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 vertexDataInt64 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 count <- number of membranes \u2502 \u251c\u2500 \ud83d\udd22 diffusingSpeciesCopyNumbers <- 4D array indexed by [species index, x, y, z] \u2502 \u251c\u2500 \ud83d\udd22 globalSpeciesCopyNumbers <- some selected species copy numbers \u2502 \u251c\u2500 \ud83d\udd22 energies <- mechanical energies after minimization \u2502 \u2514\u2500 \ud83d\udd22 time <- current time of simulation \u2514\u2500 \ud83d\udcc2 ...","title":"Output files"},{"location":"manual/output-files/#output-files","text":"MEDYAN can produce a number of output types, set in the SystemFile , produced at a snapshot frequency also defined in the SystemFile . These output files will be placed in the OutputDirectory specified at runtime. The output types are described below.","title":"Output files"},{"location":"manual/output-files/#snapshottraj","text":"\u26a0\ufe0f Breaking change Starting MEDYAN v5.1.0, brancher output is similar to other linkers, where two 3D coordinates (on mother/daughter filament, respectively) are recorded. Previously, only the starting coordinates (on the mother filament) were recorded. The snapshot file gives the basic trajectory information of the system. It includes a brief description for all filaments, cross-linkers, motors, and branching points in the system, as well as information on the current chemical step. It is produced with the following form: chemstepnumber time numfilaments numlinkers nummotors numbranchers FILAMENT filamentid filamenttype filamentcyllength deltal deltar beadcoord1x beadcoord1y beadcoord1z beadcoord2x beadcoord2y beadcoord2z ... ... LINKER linkerid linkertype startcoordx startcoordy startcoordz endcoordx endcoordy endcoordz ... MOTOR motorid motortype startcoordx startcoordy startcoordz endcoordx endcoordy endcoordz ... BRANCHER brancherid branchertype startcoordx startcoordy startcoordz endcoordx endcoordy endcoordz","title":"snapshot.traj"},{"location":"manual/output-files/#plusendtraj","text":"The plusend file gives the plus end coordinates and types information. The plus end coordinates should be the same as the last bead coordinates in the snapshot.traj for each filament. The plus end type is recorded as 0, 1, 2, etc. that follows the same order as the SPECIESPLUSEND in chemistry input files. It is produced with the following form: chemstepnumber time numfilaments numlinkers nummotors numbranchers F filamentid filamenttype filamentcyllength deltal deltar plusendcoordx plusendcoordx plusendcoordx PLUSEND: type","title":"plusend.traj"},{"location":"manual/output-files/#forcestraj-stressestraj-and-birthtimestraj","text":"The forces file gives the forces on each element in the system, in similar form to the snapshot file. It is produced with the following format: chemstepnumber time numfilaments numlinkers nummotors numbranchers F filamentid filamenttype filamentcyllength deltal deltar bead1property bead2property ... ... L linkerid linkertype linkerproperty ... M motorid motortype motorproperty ... B brancherid branchertype *no property printed for branching points* ... where the properties are as follows: - forces.traj : the magnitude forces on each cylinder, as well as the magnitude of stretching force on each cross-linker and motor are printed. - stresses.traj : the stretching stress on cylinders, cross-linkers, and motors are printed. - birthtimes.traj : the birth time of on cylinders, cross-linkers, and motors are printed.","title":"forces.traj, stresses.traj, and birthtimes.traj"},{"location":"manual/output-files/#chemistrytraj","text":"The chemistry trajectory file gives the copy numbers of all species in the system, along with the current chemical step and time. It is produced with the following form: chemstepnumber time SPECIESNAME COPYNUMBER where SPECIESNAME represents the name of the system species and COPYNUMBER is the current copy number of that species at the given timestep.","title":"chemistry.traj"},{"location":"manual/output-files/#concentrationtraj","text":"The concentration trajectory file gives the center point coordinates of compartments and the copy numbers of all diffusing species in the compartment. It is produced with the following form: chemstepnumber time COMPARTMENT: coordx coordy coordz SPECIESNAME COPYNUMBER","title":"concentration.traj"},{"location":"manual/output-files/#monomerstraj","text":"The monomers trajectory files gives the number of reactions occurred since last snapshot. DeltaMinusEnd and DeltaPlusEnd shows the number of cylinder is created and destructed. (Dd)Poly refers to (de)polymerization. IfNucleation = 1 suggests that this filament is nucleated by nucleation reaction during this period. It is produced with the following form: chemstepnumber time numfilaments numlinkers nummotors numbranchers F filamentid filamenttype filamentcyllength DeltaMinusEnd DeltaPlusEnd DeltaMinusEnd DeltaPlusEnd PolyMinusEnd PolyPlusEnd DepolyMinusEnd DepolyPlusEnd IfNucleation TotalNumMonomers","title":"monomers.traj"},{"location":"manual/output-files/#dissipationtraj","text":"The dissipation file gives the cumulative changes in the Gibbs free energy of the system resulting from chemical reactions and mechanical rearrangements. The difference between the values at consecutive times will approximate the dissipation rates. The distinction between chemdiss and chemenergy and between mechdiss and mechenergy is explained in accompanying material. The format of the output file is: chemstepnumber time total chemdiss mechdiss chemenergy mechenergy","title":"dissipation.traj"},{"location":"manual/output-files/#hrcdtraj","text":"The high resolution chemical dissipation file gives the cumulative changes in the Gibbs free energy of the system resulting from chemical reactions, with the contributions from each reaction specified separately. The order of the reactions is preserved from time step to time step and is set by the order of their first occurrence in the trajectory. For the change in Gibbs free energy resulting from diffusion of a diffusing species, the HRCDDID is given as DIF_SPECIESNAME . For the change in Gibbs free energy resulting from the unbinding of linkers or motors, the HRCDDID is given as HRCDIDoff , where HRCDID is that of the corresponding binding reaction. The format of the output file is: chemstepnumber time HRCDID1 HRCDID2 ... chemenergy1 chemenergy2 ... Here the chemenergy fields are cumulative changes in Gibbs free energy owing to this reaction.","title":"HRCD.traj"},{"location":"manual/output-files/#hrmdtraj","text":"The high resolution mechanical dissipation file gives the cumulative values of \u2206G mech and \u2206G mech, diss , with contributions from each force field specified separately. The format of the output file is: chemstepnumber time ForceField1 ForceField2 ... mechenergy1 mechenergy2 ... mechdiss1 mechdiss2 ... Here the mechenergy1 fields are cumulative net changes in mechanical energy owing to force field 1, and the mechdiss1 are cumulative changes in mechanical energy during energy minimization owing to force field 1. The difference between these two quantities is explained in accompanying material. Summing across the rows of the mechenergy and mechdiss lines will give the corresponding values found at that time point in the dissipation.traj file. When parsing this file, note that the Excluded Volume force field consists of two words whereas the other force fields (e.g. Bubble ) consist of only one word.","title":"HRMD.traj"},{"location":"manual/output-files/#cmgraphtraj","text":"The connectivity-based mapping output gives information which can be used to construct a weighted graph, in which filaments are nodes and the weighted edges between them represent the number of cross-linkers connecting them. The format of the output file is: chemstepnumber time filid1a filid1b numlinks1 filid2a fildid2b numlinks2 ... Here the filida and filidb fields are the filament identification numbers, indicating that this pair of filaments is connected by numlinks cross-linkers.","title":"CMGraph.traj"},{"location":"manual/output-files/#motorwalkingeventstraj-linkerbindingeventstraj-linkerunbindingeventstraj","text":"These output files will be generated if the event tracking feature is turned on. They give detailed information on the spatiotemporal occurrences of motor walking, and cross-linker binding and unbinding. The format for these output files is: event_t event_x event_y event_z","title":"motorwalkingevents.traj, linkerbindingevents.traj, linkerunbindingevents.traj"},{"location":"manual/output-files/#trajh5","text":"All desired system information should be stored in the traj.h5 file. The file has the following structure. Some items are documented inline. \ud83d\uddc2\ufe0f HDF5.File: traj.h5 \u251c\u2500 \ud83d\udcc2 header <- contains information about the simulation \u2502 \u251c\u2500 \ud83c\udff7\ufe0f version <- version of medyan generating this file \u2502 \u251c\u2500 \ud83d\udd22 count <- number of snapshot frames \u2502 \u251c\u2500 \ud83d\udd22 finished <- whether the simulation finished successfully \u2502 \u2514\u2500 \ud83d\udcc2 meta \u2502 \u251c\u2500 \ud83d\udd22 chem <- reconstituded chemistry input file \u2502 \u251c\u2500 \ud83d\udd22 diffusingSpeciesNames \u2502 \u251c\u2500 \ud83d\udd22 energyNames \u2502 \u251c\u2500 \ud83d\udd22 globalFilamentModel \u2502 \u251c\u2500 \ud83d\udd22 globalSpeciesNames <- names of species reported in each snapshot \u2502 \u251c\u2500 \ud83d\udd22 system <- reconstituted system input file \u2502 \u251c\u2500 \ud83d\udd22 vertexColumnNamesFloat64 \u2502 \u2514\u2500 \ud83d\udd22 vertexColumnNamesInt64 \u2514\u2500 \ud83d\udcc2 snapshots <- all snapshot data \u251c\u2500 \ud83d\udcc2 0 <- snapshot id starting from 0 \u2502 \u251c\u2500 \ud83d\udcc2 bubbles \u2502 \u2502 \u251c\u2500 \ud83d\udcc2 0 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 coords \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 id \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 radius \u2502 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 type \u2502 \u2502 \u2514\u2500 \ud83d\udd22 count <- number of bubbles \u2502 \u251c\u2500 \ud83d\udcc2 filaments \u2502 \u2502 \u251c\u2500 \ud83d\udcc2 0 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 beadCoords <- 3 x NUM_BEADS matrix \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 monomerIds <- 3 x (NUM_BEADS-1) matrix of Int32 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 extraCoords <- All coordinates to determine shape of filament \u2502 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 monomerStates <- 1 x NUM_MONOMERS matrix of UInt8 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 count <- number of filaments \u2502 \u251c\u2500 \ud83d\udcc2 linkers \u2502 \u2502 \u251c\u2500 \ud83d\udcc2 0 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 coords \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 id \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 subtype <- integer subtype of linker \u2502 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 type <- string of \"linker\", \"motor\" or \"brancher\" \u2502 \u2502 \u2514\u2500 \ud83d\udd22 count <- number of linkers \u2502 \u251c\u2500 \ud83d\udcc2 membranes \u2502 \u2502 \u251c\u2500 \ud83d\udcc2 0 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 numBorders \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 numTriangles \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 numVertices \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 packedBorderVertices <- read \"struct OutputStructMembrane\" in OutputStruct.hpp for details \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 triangleDataInt64 \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 type \u2502 \u2502 \u2502 \u251c\u2500 \ud83d\udd22 vertexDataFloat64 \u2502 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 vertexDataInt64 \u2502 \u2502 \u2514\u2500 \ud83d\udd22 count <- number of membranes \u2502 \u251c\u2500 \ud83d\udd22 diffusingSpeciesCopyNumbers <- 4D array indexed by [species index, x, y, z] \u2502 \u251c\u2500 \ud83d\udd22 globalSpeciesCopyNumbers <- some selected species copy numbers \u2502 \u251c\u2500 \ud83d\udd22 energies <- mechanical energies after minimization \u2502 \u2514\u2500 \ud83d\udd22 time <- current time of simulation \u2514\u2500 \ud83d\udcc2 ...","title":"traj.h5"},{"location":"manual/predefined-macro/","text":"Predefined macros A list of all the predefined macros and their usages Macro Description BOOST_MEM_POOL Enable boost memory pool optimizations. BOOL_POOL_NSIZE Set boost memory pool size. CHECKFORCES_INF_NAN Enable checks for inf or NaN forces. FLOAT_PRECISION If defined, float will be used in most places, instead of double . HYBRID_NLSTENCILLIST An optimized neighbor list implementation. Conflicts with NLORIGINAL and SIMDBINDINGSEARCH . NLORIGINAL The neighbor list implementation similar to MEDYAN v3.2. Conflicts with HYBRID_NLSTENCILLIST and SIMDBINDINGSEARCH . SIMDBINDINGSEARCH Enable SIMD-based neighbor list and binding site pair search protocol. Conflicts with NLORIGINAL and HYBRID_NLSTENCILLIST . TRACK_DEPENDENTS Track reaction dependents in system. TRACK_ZERO_COPY_N Passivate reactions with zero copy number. TRACK_UPPER_COPY_N Passivate reactions with big copy number.","title":"Predefined Macro"},{"location":"manual/predefined-macro/#predefined-macros","text":"A list of all the predefined macros and their usages Macro Description BOOST_MEM_POOL Enable boost memory pool optimizations. BOOL_POOL_NSIZE Set boost memory pool size. CHECKFORCES_INF_NAN Enable checks for inf or NaN forces. FLOAT_PRECISION If defined, float will be used in most places, instead of double . HYBRID_NLSTENCILLIST An optimized neighbor list implementation. Conflicts with NLORIGINAL and SIMDBINDINGSEARCH . NLORIGINAL The neighbor list implementation similar to MEDYAN v3.2. Conflicts with HYBRID_NLSTENCILLIST and SIMDBINDINGSEARCH . SIMDBINDINGSEARCH Enable SIMD-based neighbor list and binding site pair search protocol. Conflicts with NLORIGINAL and HYBRID_NLSTENCILLIST . TRACK_DEPENDENTS Track reaction dependents in system. TRACK_ZERO_COPY_N Passivate reactions with zero copy number. TRACK_UPPER_COPY_N Passivate reactions with big copy number.","title":"Predefined macros"}]}